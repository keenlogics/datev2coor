// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef COOR_HXX
#define COOR_HXX

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_WCHAR
#define XSD_USE_WCHAR
#endif

#ifndef XSD_CXX_TREE_USE_WCHAR
#define XSD_CXX_TREE_USE_WCHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< wchar_t, type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< wchar_t, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< wchar_t, string > normalized_string;
  typedef ::xsd::cxx::tree::token< wchar_t, normalized_string > token;
  typedef ::xsd::cxx::tree::name< wchar_t, token > name;
  typedef ::xsd::cxx::tree::nmtoken< wchar_t, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< wchar_t, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< wchar_t, name > ncname;
  typedef ::xsd::cxx::tree::language< wchar_t, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< wchar_t, ncname > id;
  typedef ::xsd::cxx::tree::idref< wchar_t, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< wchar_t, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< wchar_t, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< wchar_t, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< wchar_t > buffer;
  typedef ::xsd::cxx::tree::base64_binary< wchar_t, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< wchar_t, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< wchar_t, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< wchar_t, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< wchar_t, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< wchar_t, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< wchar_t, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< wchar_t, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< wchar_t, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< wchar_t, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< wchar_t, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< wchar_t, ncname > entity;
  typedef ::xsd::cxx::tree::entities< wchar_t, simple_type, entity > entities;

  typedef ::xsd::cxx::tree::content_order content_order;
  // Namespace information and list stream. Used in
  // serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info< wchar_t > namespace_info;
  typedef ::xsd::cxx::xml::dom::namespace_infomap< wchar_t > namespace_infomap;
  typedef ::xsd::cxx::tree::list_stream< wchar_t > list_stream;
  typedef ::xsd::cxx::tree::as_double< double_ > as_double;
  typedef ::xsd::cxx::tree::as_decimal< decimal > as_decimal;
  typedef ::xsd::cxx::tree::facet facet;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< wchar_t > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< wchar_t > error;
  typedef ::xsd::cxx::tree::diagnostics< wchar_t > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< wchar_t > exception;
  typedef ::xsd::cxx::tree::bounds< wchar_t > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< wchar_t > duplicate_id;
  typedef ::xsd::cxx::tree::unexpected_element< wchar_t > unexpected_element;
  typedef ::xsd::cxx::tree::serialization< wchar_t > serialization;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< wchar_t > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::unique_ptr;
  }
}

// Forward declarations.
//
class bool_type;
class collect_type;
class text256_type;
class text128_type;
class text64_type;
class text48_type;
class text32_type;
class text16_type;
class text12_type;
class text8_type;
class text4_type;
class invoicetype_type;
class scope_type;
class valuedata_type;
class normdata_type;
class externalkey_type;
class decimal_type;
class decimal8_type;
class percent_type;
class documentviewertype_type;
class matchfieldrange_type;
class matchfielduser_type;
class matchfieldresponse_type;
class matchfieldcity_type;
class matchfielddocument_type;
class matchfieldkeyvalue_type;
class matchfieldparish_type;
class matchfieldcontact_type;
class matchfieldcounterpart_type;
class matchfieldproject_type;
class matchfieldpart_type;
class matchfieldplacing_type;
class matchfieldrevision_type;
class matchfieldorder_type;
class matchfieldaddition_type;
class matchfieldevident_type;
class matchfieldbackup_type;
class matchfieldavaorder_type;
class matchfieldavaunit_type;
class matchfieldinvoice_type;
class matchfieldpayment_type;
class matchfieldbank_type;
class coordata;
class bkm_response;
class bkm_user;
class bkm_range;
class bkm_city;
class bkm_bank;
class bkm_parish;
class bkm_contact;
class bkm_counterpart;
class bkm_project;
class bkm_part;
class bkm_splititem;
class bkm_placing;
class bkm_revision;
class bkm_revisionitem;
class ret_revisionitem;
class bkm_order;
class bkm_addition;
class bkm_evident;
class bkm_backup;
class bkm_invdeftype;
class bkm_invoice;
class bkm_invoicedef;
class bkm_invoicepos;
class bkm_splitinvoice;
class bkm_payment;
class ava_unit;
class ava_order;
class ava_orderpos;
class bkm_document;
class bkm_keyvalue;
class ret_order;
class ret_invoice;
class ret_payment;

#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

class bool_type: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, wchar_t, ::xml_schema::simple_type >
{
  public:
  bool_type (::xml_schema::int_ v);

  bool_type (const bool_type& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  virtual bool_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;
};

class collect_type: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, wchar_t, ::xml_schema::simple_type >
{
  public:
  collect_type (::xml_schema::int_ v);

  collect_type (const collect_type& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual collect_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;
};

class text256_type: public ::xml_schema::string
{
  public:
  // Constructors.
  //
  text256_type ();

  text256_type (const wchar_t*);

  text256_type (const ::std::wstring&);

  text256_type (const ::xml_schema::string&);

  text256_type (const text256_type& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual text256_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~text256_type ();
};

class text128_type: public ::xml_schema::string
{
  public:
  // Constructors.
  //
  text128_type ();

  text128_type (const wchar_t*);

  text128_type (const ::std::wstring&);

  text128_type (const ::xml_schema::string&);

  text128_type (const text128_type& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual text128_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~text128_type ();
};

class text64_type: public ::xml_schema::string
{
  public:
  // Constructors.
  //
  text64_type ();

  text64_type (const wchar_t*);

  text64_type (const ::std::wstring&);

  text64_type (const ::xml_schema::string&);

  text64_type (const text64_type& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  virtual text64_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~text64_type ();
};

class text48_type: public ::xml_schema::string
{
  public:
  // Constructors.
  //
  text48_type ();

  text48_type (const wchar_t*);

  text48_type (const ::std::wstring&);

  text48_type (const ::xml_schema::string&);

  text48_type (const text48_type& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  virtual text48_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~text48_type ();
};

class text32_type: public ::xml_schema::string
{
  public:
  // Constructors.
  //
  text32_type ();

  text32_type (const wchar_t*);

  text32_type (const ::std::wstring&);

  text32_type (const ::xml_schema::string&);

  text32_type (const text32_type& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  virtual text32_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~text32_type ();
};

class text16_type: public ::xml_schema::string
{
  public:
  // Constructors.
  //
  text16_type ();

  text16_type (const wchar_t*);

  text16_type (const ::std::wstring&);

  text16_type (const ::xml_schema::string&);

  text16_type (const text16_type& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  virtual text16_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~text16_type ();
};

class text12_type: public ::xml_schema::string
{
  public:
  // Constructors.
  //
  text12_type ();

  text12_type (const wchar_t*);

  text12_type (const ::std::wstring&);

  text12_type (const ::xml_schema::string&);

  text12_type (const text12_type& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  virtual text12_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~text12_type ();
};

class text8_type: public ::xml_schema::string
{
  public:
  // Constructors.
  //
  text8_type ();

  text8_type (const wchar_t*);

  text8_type (const ::std::wstring&);

  text8_type (const ::xml_schema::string&);

  text8_type (const text8_type& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual text8_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~text8_type ();
};

class text4_type: public ::xml_schema::string
{
  public:
  // Constructors.
  //
  text4_type ();

  text4_type (const wchar_t*);

  text4_type (const ::std::wstring&);

  text4_type (const ::xml_schema::string&);

  text4_type (const text4_type& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual text4_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~text4_type ();
};

class invoicetype_type: public ::xml_schema::string
{
  public:
  // Constructors.
  //
  invoicetype_type ();

  invoicetype_type (const wchar_t*);

  invoicetype_type (const ::std::wstring&);

  invoicetype_type (const ::xml_schema::string&);

  invoicetype_type (const invoicetype_type& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  virtual invoicetype_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~invoicetype_type ();
};

class scope_type: public ::xml_schema::string
{
  public:
  enum value
  {
    bkm_city,
    bkm_bank,
    bkm_part,
    bkm_order,
    bkm_parish,
    bkm_project,
    bkm_placing,
    bkm_payment,
    bkm_contact,
    bkm_invoice,
    bkm_addition,
    bkm_evident,
    bkm_revision,
    bkm_backup,
    bkm_counterpart,
    ret_invoice
  };

  scope_type (value v);

  scope_type (const wchar_t* v);

  scope_type (const ::std::wstring& v);

  scope_type (const ::xml_schema::string& v);

  scope_type (const scope_type& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual scope_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  scope_type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_scope_type_convert ();
  }

  protected:
  value
  _xsd_scope_type_convert () const;

  public:
  static const wchar_t* const _xsd_scope_type_literals_[16];
  static const value _xsd_scope_type_indexes_[16];
};

class valuedata_type: public ::xml_schema::string
{
  public:
  enum value
  {
    string,
    int_,
    double_,
    date,
    list,
    percent,
    contact,
    counterpart,
    enlisted,
    user,
    workgroup
  };

  valuedata_type (value v);

  valuedata_type (const wchar_t* v);

  valuedata_type (const ::std::wstring& v);

  valuedata_type (const ::xml_schema::string& v);

  valuedata_type (const valuedata_type& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  virtual valuedata_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  valuedata_type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_valuedata_type_convert ();
  }

  protected:
  value
  _xsd_valuedata_type_convert () const;

  public:
  static const wchar_t* const _xsd_valuedata_type_literals_[11];
  static const value _xsd_valuedata_type_indexes_[11];
};

class normdata_type: public ::xml_schema::string
{
  public:
  enum value
  {
    oenorm,
    gaeb
  };

  normdata_type (value v);

  normdata_type (const wchar_t* v);

  normdata_type (const ::std::wstring& v);

  normdata_type (const ::xml_schema::string& v);

  normdata_type (const normdata_type& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  virtual normdata_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  normdata_type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_normdata_type_convert ();
  }

  protected:
  value
  _xsd_normdata_type_convert () const;

  public:
  static const wchar_t* const _xsd_normdata_type_literals_[2];
  static const value _xsd_normdata_type_indexes_[2];
};

class externalkey_type: public ::xml_schema::string
{
  public:
  // Constructors.
  //
  externalkey_type ();

  externalkey_type (const wchar_t*);

  externalkey_type (const ::std::wstring&);

  externalkey_type (const ::xml_schema::string&);

  externalkey_type (const externalkey_type& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  virtual externalkey_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~externalkey_type ();
};

class decimal_type: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >
{
  public:
  // Constructors.
  //
  decimal_type (const ::xml_schema::decimal&);

  decimal_type (const decimal_type& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual decimal_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~decimal_type ();
};

class decimal8_type: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >
{
  public:
  // Constructors.
  //
  decimal8_type (const ::xml_schema::decimal&);

  decimal8_type (const decimal8_type& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  virtual decimal8_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~decimal8_type ();
};

class percent_type: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >
{
  public:
  // Constructors.
  //
  percent_type (const ::xml_schema::decimal&);

  percent_type (const percent_type& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual percent_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~percent_type ();
};

class documentviewertype_type: public ::xml_schema::string
{
  public:
  enum value
  {
    STD,
    IE
  };

  documentviewertype_type (value v);

  documentviewertype_type (const wchar_t* v);

  documentviewertype_type (const ::std::wstring& v);

  documentviewertype_type (const ::xml_schema::string& v);

  documentviewertype_type (const documentviewertype_type& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  virtual documentviewertype_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  documentviewertype_type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_documentviewertype_type_convert ();
  }

  protected:
  value
  _xsd_documentviewertype_type_convert () const;

  public:
  static const wchar_t* const _xsd_documentviewertype_type_literals_[2];
  static const value _xsd_documentviewertype_type_indexes_[2];
};

class matchfieldrange_type: public ::xml_schema::string
{
  public:
  enum value
  {
    id,
    code,
    key
  };

  matchfieldrange_type (value v);

  matchfieldrange_type (const wchar_t* v);

  matchfieldrange_type (const ::std::wstring& v);

  matchfieldrange_type (const ::xml_schema::string& v);

  matchfieldrange_type (const matchfieldrange_type& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  virtual matchfieldrange_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  matchfieldrange_type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_matchfieldrange_type_convert ();
  }

  protected:
  value
  _xsd_matchfieldrange_type_convert () const;

  public:
  static const wchar_t* const _xsd_matchfieldrange_type_literals_[3];
  static const value _xsd_matchfieldrange_type_indexes_[3];
};

class matchfielduser_type: public ::xml_schema::string
{
  public:
  enum value
  {
    id,
    code,
    extern3,
    login
  };

  matchfielduser_type (value v);

  matchfielduser_type (const wchar_t* v);

  matchfielduser_type (const ::std::wstring& v);

  matchfielduser_type (const ::xml_schema::string& v);

  matchfielduser_type (const matchfielduser_type& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  virtual matchfielduser_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  matchfielduser_type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_matchfielduser_type_convert ();
  }

  protected:
  value
  _xsd_matchfielduser_type_convert () const;

  public:
  static const wchar_t* const _xsd_matchfielduser_type_literals_[4];
  static const value _xsd_matchfielduser_type_indexes_[4];
};

class matchfieldresponse_type: public ::xml_schema::string
{
  public:
  enum value
  {
    id
  };

  matchfieldresponse_type (value v);

  matchfieldresponse_type (const wchar_t* v);

  matchfieldresponse_type (const ::std::wstring& v);

  matchfieldresponse_type (const ::xml_schema::string& v);

  matchfieldresponse_type (const matchfieldresponse_type& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  virtual matchfieldresponse_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  matchfieldresponse_type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_matchfieldresponse_type_convert ();
  }

  protected:
  value
  _xsd_matchfieldresponse_type_convert () const;

  public:
  static const wchar_t* const _xsd_matchfieldresponse_type_literals_[1];
  static const value _xsd_matchfieldresponse_type_indexes_[1];
};

class matchfieldcity_type: public ::xml_schema::string
{
  public:
  enum value
  {
    zipcode
  };

  matchfieldcity_type (value v);

  matchfieldcity_type (const wchar_t* v);

  matchfieldcity_type (const ::std::wstring& v);

  matchfieldcity_type (const ::xml_schema::string& v);

  matchfieldcity_type (const matchfieldcity_type& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  virtual matchfieldcity_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  matchfieldcity_type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_matchfieldcity_type_convert ();
  }

  protected:
  value
  _xsd_matchfieldcity_type_convert () const;

  public:
  static const wchar_t* const _xsd_matchfieldcity_type_literals_[1];
  static const value _xsd_matchfieldcity_type_indexes_[1];
};

class matchfielddocument_type: public ::xml_schema::string
{
  public:
  enum value
  {
    id,
    name
  };

  matchfielddocument_type (value v);

  matchfielddocument_type (const wchar_t* v);

  matchfielddocument_type (const ::std::wstring& v);

  matchfielddocument_type (const ::xml_schema::string& v);

  matchfielddocument_type (const matchfielddocument_type& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  virtual matchfielddocument_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  matchfielddocument_type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_matchfielddocument_type_convert ();
  }

  protected:
  value
  _xsd_matchfielddocument_type_convert () const;

  public:
  static const wchar_t* const _xsd_matchfielddocument_type_literals_[2];
  static const value _xsd_matchfielddocument_type_indexes_[2];
};

class matchfieldkeyvalue_type: public ::xml_schema::string
{
  public:
  enum value
  {
    id,
    code
  };

  matchfieldkeyvalue_type (value v);

  matchfieldkeyvalue_type (const wchar_t* v);

  matchfieldkeyvalue_type (const ::std::wstring& v);

  matchfieldkeyvalue_type (const ::xml_schema::string& v);

  matchfieldkeyvalue_type (const matchfieldkeyvalue_type& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  virtual matchfieldkeyvalue_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  matchfieldkeyvalue_type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_matchfieldkeyvalue_type_convert ();
  }

  protected:
  value
  _xsd_matchfieldkeyvalue_type_convert () const;

  public:
  static const wchar_t* const _xsd_matchfieldkeyvalue_type_literals_[2];
  static const value _xsd_matchfieldkeyvalue_type_indexes_[2];
};

class matchfieldparish_type: public ::xml_schema::string
{
  public:
  enum value
  {
    id,
    code,
    parish
  };

  matchfieldparish_type (value v);

  matchfieldparish_type (const wchar_t* v);

  matchfieldparish_type (const ::std::wstring& v);

  matchfieldparish_type (const ::xml_schema::string& v);

  matchfieldparish_type (const matchfieldparish_type& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  virtual matchfieldparish_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  matchfieldparish_type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_matchfieldparish_type_convert ();
  }

  protected:
  value
  _xsd_matchfieldparish_type_convert () const;

  public:
  static const wchar_t* const _xsd_matchfieldparish_type_literals_[3];
  static const value _xsd_matchfieldparish_type_indexes_[3];
};

class matchfieldcontact_type: public ::xml_schema::string
{
  public:
  enum value
  {
    id,
    keyid,
    synonym,
    vatid
  };

  matchfieldcontact_type (value v);

  matchfieldcontact_type (const wchar_t* v);

  matchfieldcontact_type (const ::std::wstring& v);

  matchfieldcontact_type (const ::xml_schema::string& v);

  matchfieldcontact_type (const matchfieldcontact_type& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  virtual matchfieldcontact_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  matchfieldcontact_type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_matchfieldcontact_type_convert ();
  }

  protected:
  value
  _xsd_matchfieldcontact_type_convert () const;

  public:
  static const wchar_t* const _xsd_matchfieldcontact_type_literals_[4];
  static const value _xsd_matchfieldcontact_type_indexes_[4];
};

class matchfieldcounterpart_type: public ::xml_schema::string
{
  public:
  enum value
  {
    id,
    lastname,
    mail
  };

  matchfieldcounterpart_type (value v);

  matchfieldcounterpart_type (const wchar_t* v);

  matchfieldcounterpart_type (const ::std::wstring& v);

  matchfieldcounterpart_type (const ::xml_schema::string& v);

  matchfieldcounterpart_type (const matchfieldcounterpart_type& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

  virtual matchfieldcounterpart_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  matchfieldcounterpart_type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_matchfieldcounterpart_type_convert ();
  }

  protected:
  value
  _xsd_matchfieldcounterpart_type_convert () const;

  public:
  static const wchar_t* const _xsd_matchfieldcounterpart_type_literals_[3];
  static const value _xsd_matchfieldcounterpart_type_indexes_[3];
};

class matchfieldproject_type: public ::xml_schema::string
{
  public:
  enum value
  {
    id,
    code,
    number,
    extern3,
    extern3_partstruct,
    part
  };

  matchfieldproject_type (value v);

  matchfieldproject_type (const wchar_t* v);

  matchfieldproject_type (const ::std::wstring& v);

  matchfieldproject_type (const ::xml_schema::string& v);

  matchfieldproject_type (const matchfieldproject_type& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  virtual matchfieldproject_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  matchfieldproject_type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_matchfieldproject_type_convert ();
  }

  protected:
  value
  _xsd_matchfieldproject_type_convert () const;

  public:
  static const wchar_t* const _xsd_matchfieldproject_type_literals_[6];
  static const value _xsd_matchfieldproject_type_indexes_[6];
};

class matchfieldpart_type: public ::xml_schema::string
{
  public:
  enum value
  {
    id,
    code,
    extern3
  };

  matchfieldpart_type (value v);

  matchfieldpart_type (const wchar_t* v);

  matchfieldpart_type (const ::std::wstring& v);

  matchfieldpart_type (const ::xml_schema::string& v);

  matchfieldpart_type (const matchfieldpart_type& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  virtual matchfieldpart_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  matchfieldpart_type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_matchfieldpart_type_convert ();
  }

  protected:
  value
  _xsd_matchfieldpart_type_convert () const;

  public:
  static const wchar_t* const _xsd_matchfieldpart_type_literals_[3];
  static const value _xsd_matchfieldpart_type_indexes_[3];
};

class matchfieldplacing_type: public ::xml_schema::string
{
  public:
  enum value
  {
    id,
    code,
    code_partcode1,
    code_groupcode,
    extern3
  };

  matchfieldplacing_type (value v);

  matchfieldplacing_type (const wchar_t* v);

  matchfieldplacing_type (const ::std::wstring& v);

  matchfieldplacing_type (const ::xml_schema::string& v);

  matchfieldplacing_type (const matchfieldplacing_type& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  virtual matchfieldplacing_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  matchfieldplacing_type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_matchfieldplacing_type_convert ();
  }

  protected:
  value
  _xsd_matchfieldplacing_type_convert () const;

  public:
  static const wchar_t* const _xsd_matchfieldplacing_type_literals_[5];
  static const value _xsd_matchfieldplacing_type_indexes_[5];
};

class matchfieldrevision_type: public ::xml_schema::string
{
  public:
  enum value
  {
    id,
    number
  };

  matchfieldrevision_type (value v);

  matchfieldrevision_type (const wchar_t* v);

  matchfieldrevision_type (const ::std::wstring& v);

  matchfieldrevision_type (const ::xml_schema::string& v);

  matchfieldrevision_type (const matchfieldrevision_type& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  virtual matchfieldrevision_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  matchfieldrevision_type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_matchfieldrevision_type_convert ();
  }

  protected:
  value
  _xsd_matchfieldrevision_type_convert () const;

  public:
  static const wchar_t* const _xsd_matchfieldrevision_type_literals_[2];
  static const value _xsd_matchfieldrevision_type_indexes_[2];
};

class matchfieldorder_type: public ::xml_schema::string
{
  public:
  enum value
  {
    id,
    number,
    numbercol,
    numbercol_parentkey,
    contract,
    extern3,
    placingkey_vendorkey
  };

  matchfieldorder_type (value v);

  matchfieldorder_type (const wchar_t* v);

  matchfieldorder_type (const ::std::wstring& v);

  matchfieldorder_type (const ::xml_schema::string& v);

  matchfieldorder_type (const matchfieldorder_type& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  virtual matchfieldorder_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  matchfieldorder_type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_matchfieldorder_type_convert ();
  }

  protected:
  value
  _xsd_matchfieldorder_type_convert () const;

  public:
  static const wchar_t* const _xsd_matchfieldorder_type_literals_[7];
  static const value _xsd_matchfieldorder_type_indexes_[7];
};

class matchfieldaddition_type: public ::xml_schema::string
{
  public:
  enum value
  {
    id,
    number,
    statuscode
  };

  matchfieldaddition_type (value v);

  matchfieldaddition_type (const wchar_t* v);

  matchfieldaddition_type (const ::std::wstring& v);

  matchfieldaddition_type (const ::xml_schema::string& v);

  matchfieldaddition_type (const matchfieldaddition_type& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  virtual matchfieldaddition_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  matchfieldaddition_type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_matchfieldaddition_type_convert ();
  }

  protected:
  value
  _xsd_matchfieldaddition_type_convert () const;

  public:
  static const wchar_t* const _xsd_matchfieldaddition_type_literals_[3];
  static const value _xsd_matchfieldaddition_type_indexes_[3];
};

class matchfieldevident_type: public ::xml_schema::string
{
  public:
  enum value
  {
    id,
    number,
    numberproject
  };

  matchfieldevident_type (value v);

  matchfieldevident_type (const wchar_t* v);

  matchfieldevident_type (const ::std::wstring& v);

  matchfieldevident_type (const ::xml_schema::string& v);

  matchfieldevident_type (const matchfieldevident_type& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  virtual matchfieldevident_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  matchfieldevident_type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_matchfieldevident_type_convert ();
  }

  protected:
  value
  _xsd_matchfieldevident_type_convert () const;

  public:
  static const wchar_t* const _xsd_matchfieldevident_type_literals_[3];
  static const value _xsd_matchfieldevident_type_indexes_[3];
};

class matchfieldbackup_type: public ::xml_schema::string
{
  public:
  enum value
  {
    id,
    code
  };

  matchfieldbackup_type (value v);

  matchfieldbackup_type (const wchar_t* v);

  matchfieldbackup_type (const ::std::wstring& v);

  matchfieldbackup_type (const ::xml_schema::string& v);

  matchfieldbackup_type (const matchfieldbackup_type& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  virtual matchfieldbackup_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  matchfieldbackup_type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_matchfieldbackup_type_convert ();
  }

  protected:
  value
  _xsd_matchfieldbackup_type_convert () const;

  public:
  static const wchar_t* const _xsd_matchfieldbackup_type_literals_[2];
  static const value _xsd_matchfieldbackup_type_indexes_[2];
};

class matchfieldavaorder_type: public ::xml_schema::string
{
  public:
  enum value
  {
    id,
    number,
    order,
    code
  };

  matchfieldavaorder_type (value v);

  matchfieldavaorder_type (const wchar_t* v);

  matchfieldavaorder_type (const ::std::wstring& v);

  matchfieldavaorder_type (const ::xml_schema::string& v);

  matchfieldavaorder_type (const matchfieldavaorder_type& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  virtual matchfieldavaorder_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  matchfieldavaorder_type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_matchfieldavaorder_type_convert ();
  }

  protected:
  value
  _xsd_matchfieldavaorder_type_convert () const;

  public:
  static const wchar_t* const _xsd_matchfieldavaorder_type_literals_[4];
  static const value _xsd_matchfieldavaorder_type_indexes_[4];
};

class matchfieldavaunit_type: public ::xml_schema::string
{
  public:
  enum value
  {
    id,
    code
  };

  matchfieldavaunit_type (value v);

  matchfieldavaunit_type (const wchar_t* v);

  matchfieldavaunit_type (const ::std::wstring& v);

  matchfieldavaunit_type (const ::xml_schema::string& v);

  matchfieldavaunit_type (const matchfieldavaunit_type& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  virtual matchfieldavaunit_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  matchfieldavaunit_type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_matchfieldavaunit_type_convert ();
  }

  protected:
  value
  _xsd_matchfieldavaunit_type_convert () const;

  public:
  static const wchar_t* const _xsd_matchfieldavaunit_type_literals_[2];
  static const value _xsd_matchfieldavaunit_type_indexes_[2];
};

class matchfieldinvoice_type: public ::xml_schema::string
{
  public:
  enum value
  {
    id,
    number,
    extern1,
    extern2,
    extern3
  };

  matchfieldinvoice_type (value v);

  matchfieldinvoice_type (const wchar_t* v);

  matchfieldinvoice_type (const ::std::wstring& v);

  matchfieldinvoice_type (const ::xml_schema::string& v);

  matchfieldinvoice_type (const matchfieldinvoice_type& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  virtual matchfieldinvoice_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  matchfieldinvoice_type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_matchfieldinvoice_type_convert ();
  }

  protected:
  value
  _xsd_matchfieldinvoice_type_convert () const;

  public:
  static const wchar_t* const _xsd_matchfieldinvoice_type_literals_[5];
  static const value _xsd_matchfieldinvoice_type_indexes_[5];
};

class matchfieldpayment_type: public ::xml_schema::string
{
  public:
  enum value
  {
    id,
    number
  };

  matchfieldpayment_type (value v);

  matchfieldpayment_type (const wchar_t* v);

  matchfieldpayment_type (const ::std::wstring& v);

  matchfieldpayment_type (const ::xml_schema::string& v);

  matchfieldpayment_type (const matchfieldpayment_type& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  virtual matchfieldpayment_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  matchfieldpayment_type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_matchfieldpayment_type_convert ();
  }

  protected:
  value
  _xsd_matchfieldpayment_type_convert () const;

  public:
  static const wchar_t* const _xsd_matchfieldpayment_type_literals_[2];
  static const value _xsd_matchfieldpayment_type_indexes_[2];
};

class matchfieldbank_type: public ::xml_schema::string
{
  public:
  enum value
  {
    id,
    bin,
    blz,
    swift
  };

  matchfieldbank_type (value v);

  matchfieldbank_type (const wchar_t* v);

  matchfieldbank_type (const ::std::wstring& v);

  matchfieldbank_type (const ::xml_schema::string& v);

  matchfieldbank_type (const matchfieldbank_type& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  virtual matchfieldbank_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  matchfieldbank_type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_matchfieldbank_type_convert ();
  }

  protected:
  value
  _xsd_matchfieldbank_type_convert () const;

  public:
  static const wchar_t* const _xsd_matchfieldbank_type_literals_[4];
  static const value _xsd_matchfieldbank_type_indexes_[4];
};

class coordata: public ::xml_schema::type
{
  public:
  // bkm.response
  //
  typedef ::bkm_response bkm_response_type;
  typedef ::xsd::cxx::tree::sequence< bkm_response_type > bkm_response_sequence;
  typedef bkm_response_sequence::iterator bkm_response_iterator;
  typedef bkm_response_sequence::const_iterator bkm_response_const_iterator;
  typedef ::xsd::cxx::tree::traits< bkm_response_type, wchar_t > bkm_response_traits;

  const bkm_response_sequence&
  bkm_response () const;

  bkm_response_sequence&
  bkm_response ();

  void
  bkm_response (const bkm_response_sequence& s);

  // bkm.user
  //
  typedef ::bkm_user bkm_user_type;
  typedef ::xsd::cxx::tree::sequence< bkm_user_type > bkm_user_sequence;
  typedef bkm_user_sequence::iterator bkm_user_iterator;
  typedef bkm_user_sequence::const_iterator bkm_user_const_iterator;
  typedef ::xsd::cxx::tree::traits< bkm_user_type, wchar_t > bkm_user_traits;

  const bkm_user_sequence&
  bkm_user () const;

  bkm_user_sequence&
  bkm_user ();

  void
  bkm_user (const bkm_user_sequence& s);

  // bkm.range
  //
  typedef ::bkm_range bkm_range_type;
  typedef ::xsd::cxx::tree::optional< bkm_range_type > bkm_range_optional;
  typedef ::xsd::cxx::tree::traits< bkm_range_type, wchar_t > bkm_range_traits;

  const bkm_range_optional&
  bkm_range () const;

  bkm_range_optional&
  bkm_range ();

  void
  bkm_range (const bkm_range_type& x);

  void
  bkm_range (const bkm_range_optional& x);

  void
  bkm_range (::std::unique_ptr< bkm_range_type > p);

  // bkm.bank
  //
  typedef ::bkm_bank bkm_bank_type;
  typedef ::xsd::cxx::tree::sequence< bkm_bank_type > bkm_bank_sequence;
  typedef bkm_bank_sequence::iterator bkm_bank_iterator;
  typedef bkm_bank_sequence::const_iterator bkm_bank_const_iterator;
  typedef ::xsd::cxx::tree::traits< bkm_bank_type, wchar_t > bkm_bank_traits;

  const bkm_bank_sequence&
  bkm_bank () const;

  bkm_bank_sequence&
  bkm_bank ();

  void
  bkm_bank (const bkm_bank_sequence& s);

  // bkm.parish
  //
  typedef ::bkm_parish bkm_parish_type;
  typedef ::xsd::cxx::tree::optional< bkm_parish_type > bkm_parish_optional;
  typedef ::xsd::cxx::tree::traits< bkm_parish_type, wchar_t > bkm_parish_traits;

  const bkm_parish_optional&
  bkm_parish () const;

  bkm_parish_optional&
  bkm_parish ();

  void
  bkm_parish (const bkm_parish_type& x);

  void
  bkm_parish (const bkm_parish_optional& x);

  void
  bkm_parish (::std::unique_ptr< bkm_parish_type > p);

  // bkm.city
  //
  typedef ::bkm_city bkm_city_type;
  typedef ::xsd::cxx::tree::sequence< bkm_city_type > bkm_city_sequence;
  typedef bkm_city_sequence::iterator bkm_city_iterator;
  typedef bkm_city_sequence::const_iterator bkm_city_const_iterator;
  typedef ::xsd::cxx::tree::traits< bkm_city_type, wchar_t > bkm_city_traits;

  const bkm_city_sequence&
  bkm_city () const;

  bkm_city_sequence&
  bkm_city ();

  void
  bkm_city (const bkm_city_sequence& s);

  // bkm.contact
  //
  typedef ::bkm_contact bkm_contact_type;
  typedef ::xsd::cxx::tree::sequence< bkm_contact_type > bkm_contact_sequence;
  typedef bkm_contact_sequence::iterator bkm_contact_iterator;
  typedef bkm_contact_sequence::const_iterator bkm_contact_const_iterator;
  typedef ::xsd::cxx::tree::traits< bkm_contact_type, wchar_t > bkm_contact_traits;

  const bkm_contact_sequence&
  bkm_contact () const;

  bkm_contact_sequence&
  bkm_contact ();

  void
  bkm_contact (const bkm_contact_sequence& s);

  // bkm.counterpart
  //
  typedef ::bkm_counterpart bkm_counterpart_type;
  typedef ::xsd::cxx::tree::optional< bkm_counterpart_type > bkm_counterpart_optional;
  typedef ::xsd::cxx::tree::traits< bkm_counterpart_type, wchar_t > bkm_counterpart_traits;

  const bkm_counterpart_optional&
  bkm_counterpart () const;

  bkm_counterpart_optional&
  bkm_counterpart ();

  void
  bkm_counterpart (const bkm_counterpart_type& x);

  void
  bkm_counterpart (const bkm_counterpart_optional& x);

  void
  bkm_counterpart (::std::unique_ptr< bkm_counterpart_type > p);

  // bkm.part
  //
  typedef ::bkm_part bkm_part_type;
  typedef ::xsd::cxx::tree::optional< bkm_part_type > bkm_part_optional;
  typedef ::xsd::cxx::tree::traits< bkm_part_type, wchar_t > bkm_part_traits;

  const bkm_part_optional&
  bkm_part () const;

  bkm_part_optional&
  bkm_part ();

  void
  bkm_part (const bkm_part_type& x);

  void
  bkm_part (const bkm_part_optional& x);

  void
  bkm_part (::std::unique_ptr< bkm_part_type > p);

  // bkm.placing
  //
  typedef ::bkm_placing bkm_placing_type;
  typedef ::xsd::cxx::tree::optional< bkm_placing_type > bkm_placing_optional;
  typedef ::xsd::cxx::tree::traits< bkm_placing_type, wchar_t > bkm_placing_traits;

  const bkm_placing_optional&
  bkm_placing () const;

  bkm_placing_optional&
  bkm_placing ();

  void
  bkm_placing (const bkm_placing_type& x);

  void
  bkm_placing (const bkm_placing_optional& x);

  void
  bkm_placing (::std::unique_ptr< bkm_placing_type > p);

  // bkm.invoice
  //
  typedef ::bkm_invoice bkm_invoice_type;
  typedef ::xsd::cxx::tree::sequence< bkm_invoice_type > bkm_invoice_sequence;
  typedef bkm_invoice_sequence::iterator bkm_invoice_iterator;
  typedef bkm_invoice_sequence::const_iterator bkm_invoice_const_iterator;
  typedef ::xsd::cxx::tree::traits< bkm_invoice_type, wchar_t > bkm_invoice_traits;

  const bkm_invoice_sequence&
  bkm_invoice () const;

  bkm_invoice_sequence&
  bkm_invoice ();

  void
  bkm_invoice (const bkm_invoice_sequence& s);

  // bkm.payment
  //
  typedef ::bkm_payment bkm_payment_type;
  typedef ::xsd::cxx::tree::optional< bkm_payment_type > bkm_payment_optional;
  typedef ::xsd::cxx::tree::traits< bkm_payment_type, wchar_t > bkm_payment_traits;

  const bkm_payment_optional&
  bkm_payment () const;

  bkm_payment_optional&
  bkm_payment ();

  void
  bkm_payment (const bkm_payment_type& x);

  void
  bkm_payment (const bkm_payment_optional& x);

  void
  bkm_payment (::std::unique_ptr< bkm_payment_type > p);

  // ava.unit
  //
  typedef ::ava_unit ava_unit_type;
  typedef ::xsd::cxx::tree::optional< ava_unit_type > ava_unit_optional;
  typedef ::xsd::cxx::tree::traits< ava_unit_type, wchar_t > ava_unit_traits;

  const ava_unit_optional&
  ava_unit () const;

  ava_unit_optional&
  ava_unit ();

  void
  ava_unit (const ava_unit_type& x);

  void
  ava_unit (const ava_unit_optional& x);

  void
  ava_unit (::std::unique_ptr< ava_unit_type > p);

  // bkm.project
  //
  typedef ::bkm_project bkm_project_type;
  typedef ::xsd::cxx::tree::sequence< bkm_project_type > bkm_project_sequence;
  typedef bkm_project_sequence::iterator bkm_project_iterator;
  typedef bkm_project_sequence::const_iterator bkm_project_const_iterator;
  typedef ::xsd::cxx::tree::traits< bkm_project_type, wchar_t > bkm_project_traits;

  const bkm_project_sequence&
  bkm_project () const;

  bkm_project_sequence&
  bkm_project ();

  void
  bkm_project (const bkm_project_sequence& s);

  // name
  //
  typedef ::text128_type name_type;
  typedef ::xsd::cxx::tree::optional< name_type > name_optional;
  typedef ::xsd::cxx::tree::traits< name_type, wchar_t > name_traits;

  const name_optional&
  name () const;

  name_optional&
  name ();

  void
  name (const name_type& x);

  void
  name (const name_optional& x);

  void
  name (::std::unique_ptr< name_type > p);

  // mandant
  //
  typedef ::text64_type mandant_type;
  typedef ::xsd::cxx::tree::optional< mandant_type > mandant_optional;
  typedef ::xsd::cxx::tree::traits< mandant_type, wchar_t > mandant_traits;

  const mandant_optional&
  mandant () const;

  mandant_optional&
  mandant ();

  void
  mandant (const mandant_type& x);

  void
  mandant (const mandant_optional& x);

  void
  mandant (::std::unique_ptr< mandant_type > p);

  // exchangeid
  //
  typedef ::xml_schema::int_ exchangeid_type;
  typedef ::xsd::cxx::tree::optional< exchangeid_type > exchangeid_optional;
  typedef ::xsd::cxx::tree::traits< exchangeid_type, wchar_t > exchangeid_traits;

  const exchangeid_optional&
  exchangeid () const;

  exchangeid_optional&
  exchangeid ();

  void
  exchangeid (const exchangeid_type& x);

  void
  exchangeid (const exchangeid_optional& x);

  // external
  //
  typedef ::text16_type external_type;
  typedef ::xsd::cxx::tree::traits< external_type, wchar_t > external_traits;

  const external_type&
  external () const;

  external_type&
  external ();

  void
  external (const external_type& x);

  void
  external (::std::unique_ptr< external_type > p);

  static const external_type&
  external_default_value ();

  // version
  //
  typedef ::text16_type version_type;
  typedef ::xsd::cxx::tree::traits< version_type, wchar_t > version_traits;

  const version_type&
  version () const;

  version_type&
  version ();

  void
  version (const version_type& x);

  void
  version (::std::unique_ptr< version_type > p);

  static const version_type&
  version_default_value ();

  // response
  //
  typedef ::text256_type response_type;
  typedef ::xsd::cxx::tree::optional< response_type > response_optional;
  typedef ::xsd::cxx::tree::traits< response_type, wchar_t > response_traits;

  const response_optional&
  response () const;

  response_optional&
  response ();

  void
  response (const response_type& x);

  void
  response (const response_optional& x);

  void
  response (::std::unique_ptr< response_type > p);

  // winuser
  //
  typedef ::text128_type winuser_type;
  typedef ::xsd::cxx::tree::optional< winuser_type > winuser_optional;
  typedef ::xsd::cxx::tree::traits< winuser_type, wchar_t > winuser_traits;

  const winuser_optional&
  winuser () const;

  winuser_optional&
  winuser ();

  void
  winuser (const winuser_type& x);

  void
  winuser (const winuser_optional& x);

  void
  winuser (::std::unique_ptr< winuser_type > p);

  // winuserkey
  //
  typedef ::externalkey_type winuserkey_type;
  typedef ::xsd::cxx::tree::optional< winuserkey_type > winuserkey_optional;
  typedef ::xsd::cxx::tree::traits< winuserkey_type, wchar_t > winuserkey_traits;

  const winuserkey_optional&
  winuserkey () const;

  winuserkey_optional&
  winuserkey ();

  void
  winuserkey (const winuserkey_type& x);

  void
  winuserkey (const winuserkey_optional& x);

  void
  winuserkey (::std::unique_ptr< winuserkey_type > p);

  // infodate
  //
  typedef ::xml_schema::date infodate_type;
  typedef ::xsd::cxx::tree::optional< infodate_type > infodate_optional;
  typedef ::xsd::cxx::tree::traits< infodate_type, wchar_t > infodate_traits;

  const infodate_optional&
  infodate () const;

  infodate_optional&
  infodate ();

  void
  infodate (const infodate_type& x);

  void
  infodate (const infodate_optional& x);

  void
  infodate (::std::unique_ptr< infodate_type > p);

  // info
  //
  typedef ::text256_type info_type;
  typedef ::xsd::cxx::tree::optional< info_type > info_optional;
  typedef ::xsd::cxx::tree::traits< info_type, wchar_t > info_traits;

  const info_optional&
  info () const;

  info_optional&
  info ();

  void
  info (const info_type& x);

  void
  info (const info_optional& x);

  void
  info (::std::unique_ptr< info_type > p);

  // infouser
  //
  typedef ::text128_type infouser_type;
  typedef ::xsd::cxx::tree::optional< infouser_type > infouser_optional;
  typedef ::xsd::cxx::tree::traits< infouser_type, wchar_t > infouser_traits;

  const infouser_optional&
  infouser () const;

  infouser_optional&
  infouser ();

  void
  infouser (const infouser_type& x);

  void
  infouser (const infouser_optional& x);

  void
  infouser (::std::unique_ptr< infouser_type > p);

  // Constructors.
  //
  coordata ();

  coordata (const coordata& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual coordata*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  coordata&
  operator= (const coordata& x);

  virtual 
  ~coordata ();

  // Implementation.
  //
  protected:
  bkm_response_sequence bkm_response_;
  bkm_user_sequence bkm_user_;
  bkm_range_optional bkm_range_;
  bkm_bank_sequence bkm_bank_;
  bkm_parish_optional bkm_parish_;
  bkm_city_sequence bkm_city_;
  bkm_contact_sequence bkm_contact_;
  bkm_counterpart_optional bkm_counterpart_;
  bkm_part_optional bkm_part_;
  bkm_placing_optional bkm_placing_;
  bkm_invoice_sequence bkm_invoice_;
  bkm_payment_optional bkm_payment_;
  ava_unit_optional ava_unit_;
  bkm_project_sequence bkm_project_;
  name_optional name_;
  mandant_optional mandant_;
  exchangeid_optional exchangeid_;
  ::xsd::cxx::tree::one< external_type > external_;
  static const external_type external_default_value_;
  ::xsd::cxx::tree::one< version_type > version_;
  static const version_type version_default_value_;
  response_optional response_;
  winuser_optional winuser_;
  winuserkey_optional winuserkey_;
  infodate_optional infodate_;
  info_optional info_;
  infouser_optional infouser_;
};

class bkm_response: public ::xml_schema::type
{
  public:
  // id
  //
  typedef ::xml_schema::int_ id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  // status
  //
  typedef ::text8_type status_type;
  typedef ::xsd::cxx::tree::traits< status_type, wchar_t > status_traits;

  const status_type&
  status () const;

  status_type&
  status ();

  void
  status (const status_type& x);

  void
  status (::std::unique_ptr< status_type > p);

  // externalkey
  //
  typedef ::externalkey_type externalkey_type;
  typedef ::xsd::cxx::tree::traits< externalkey_type, wchar_t > externalkey_traits;

  const externalkey_type&
  externalkey () const;

  externalkey_type&
  externalkey ();

  void
  externalkey (const externalkey_type& x);

  void
  externalkey (::std::unique_ptr< externalkey_type > p);

  // matchfield
  //
  typedef ::matchfieldresponse_type matchfield_type;
  typedef ::xsd::cxx::tree::optional< matchfield_type > matchfield_optional;
  typedef ::xsd::cxx::tree::traits< matchfield_type, wchar_t > matchfield_traits;

  const matchfield_optional&
  matchfield () const;

  matchfield_optional&
  matchfield ();

  void
  matchfield (const matchfield_type& x);

  void
  matchfield (const matchfield_optional& x);

  void
  matchfield (::std::unique_ptr< matchfield_type > p);

  // scope
  //
  typedef ::scope_type scope_type;
  typedef ::xsd::cxx::tree::optional< scope_type > scope_optional;
  typedef ::xsd::cxx::tree::traits< scope_type, wchar_t > scope_traits;

  const scope_optional&
  scope () const;

  scope_optional&
  scope ();

  void
  scope (const scope_type& x);

  void
  scope (const scope_optional& x);

  void
  scope (::std::unique_ptr< scope_type > p);

  // name
  //
  typedef ::text64_type name_type;
  typedef ::xsd::cxx::tree::optional< name_type > name_optional;
  typedef ::xsd::cxx::tree::traits< name_type, wchar_t > name_traits;

  const name_optional&
  name () const;

  name_optional&
  name ();

  void
  name (const name_type& x);

  void
  name (const name_optional& x);

  void
  name (::std::unique_ptr< name_type > p);

  // code
  //
  typedef ::text16_type code_type;
  typedef ::xsd::cxx::tree::optional< code_type > code_optional;
  typedef ::xsd::cxx::tree::traits< code_type, wchar_t > code_traits;

  const code_optional&
  code () const;

  code_optional&
  code ();

  void
  code (const code_type& x);

  void
  code (const code_optional& x);

  void
  code (::std::unique_ptr< code_type > p);

  // detail
  //
  typedef ::text64_type detail_type;
  typedef ::xsd::cxx::tree::optional< detail_type > detail_optional;
  typedef ::xsd::cxx::tree::traits< detail_type, wchar_t > detail_traits;

  const detail_optional&
  detail () const;

  detail_optional&
  detail ();

  void
  detail (const detail_type& x);

  void
  detail (const detail_optional& x);

  void
  detail (::std::unique_ptr< detail_type > p);

  // message
  //
  typedef ::xml_schema::string message_type;
  typedef ::xsd::cxx::tree::optional< message_type > message_optional;
  typedef ::xsd::cxx::tree::traits< message_type, wchar_t > message_traits;

  const message_optional&
  message () const;

  message_optional&
  message ();

  void
  message (const message_type& x);

  void
  message (const message_optional& x);

  void
  message (::std::unique_ptr< message_type > p);

  // extern3
  //
  typedef ::text128_type extern3_type;
  typedef ::xsd::cxx::tree::optional< extern3_type > extern3_optional;
  typedef ::xsd::cxx::tree::traits< extern3_type, wchar_t > extern3_traits;

  const extern3_optional&
  extern3 () const;

  extern3_optional&
  extern3 ();

  void
  extern3 (const extern3_type& x);

  void
  extern3 (const extern3_optional& x);

  void
  extern3 (::std::unique_ptr< extern3_type > p);

  // Constructors.
  //
  bkm_response (const status_type&,
                const externalkey_type&);

  bkm_response (const bkm_response& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual bkm_response*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  bkm_response&
  operator= (const bkm_response& x);

  virtual 
  ~bkm_response ();

  // Implementation.
  //
  protected:
  id_optional id_;
  ::xsd::cxx::tree::one< status_type > status_;
  ::xsd::cxx::tree::one< externalkey_type > externalkey_;
  matchfield_optional matchfield_;
  scope_optional scope_;
  name_optional name_;
  code_optional code_;
  detail_optional detail_;
  message_optional message_;
  extern3_optional extern3_;
};

class bkm_user: public ::xml_schema::type
{
  public:
  // id
  //
  typedef ::xml_schema::int_ id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  // code
  //
  typedef ::text128_type code_type;
  typedef ::xsd::cxx::tree::optional< code_type > code_optional;
  typedef ::xsd::cxx::tree::traits< code_type, wchar_t > code_traits;

  const code_optional&
  code () const;

  code_optional&
  code ();

  void
  code (const code_type& x);

  void
  code (const code_optional& x);

  void
  code (::std::unique_ptr< code_type > p);

  // login
  //
  typedef ::text128_type login_type;
  typedef ::xsd::cxx::tree::optional< login_type > login_optional;
  typedef ::xsd::cxx::tree::traits< login_type, wchar_t > login_traits;

  const login_optional&
  login () const;

  login_optional&
  login ();

  void
  login (const login_type& x);

  void
  login (const login_optional& x);

  void
  login (::std::unique_ptr< login_type > p);

  // firstname
  //
  typedef ::text64_type firstname_type;
  typedef ::xsd::cxx::tree::optional< firstname_type > firstname_optional;
  typedef ::xsd::cxx::tree::traits< firstname_type, wchar_t > firstname_traits;

  const firstname_optional&
  firstname () const;

  firstname_optional&
  firstname ();

  void
  firstname (const firstname_type& x);

  void
  firstname (const firstname_optional& x);

  void
  firstname (::std::unique_ptr< firstname_type > p);

  // lastname
  //
  typedef ::text64_type lastname_type;
  typedef ::xsd::cxx::tree::optional< lastname_type > lastname_optional;
  typedef ::xsd::cxx::tree::traits< lastname_type, wchar_t > lastname_traits;

  const lastname_optional&
  lastname () const;

  lastname_optional&
  lastname ();

  void
  lastname (const lastname_type& x);

  void
  lastname (const lastname_optional& x);

  void
  lastname (::std::unique_ptr< lastname_type > p);

  // externalkey
  //
  typedef ::externalkey_type externalkey_type;
  typedef ::xsd::cxx::tree::traits< externalkey_type, wchar_t > externalkey_traits;

  const externalkey_type&
  externalkey () const;

  externalkey_type&
  externalkey ();

  void
  externalkey (const externalkey_type& x);

  void
  externalkey (::std::unique_ptr< externalkey_type > p);

  // matchfield
  //
  typedef ::matchfielduser_type matchfield_type;
  typedef ::xsd::cxx::tree::optional< matchfield_type > matchfield_optional;
  typedef ::xsd::cxx::tree::traits< matchfield_type, wchar_t > matchfield_traits;

  const matchfield_optional&
  matchfield () const;

  matchfield_optional&
  matchfield ();

  void
  matchfield (const matchfield_type& x);

  void
  matchfield (const matchfield_optional& x);

  void
  matchfield (::std::unique_ptr< matchfield_type > p);

  // controlcode
  //
  typedef ::text256_type controlcode_type;
  typedef ::xsd::cxx::tree::optional< controlcode_type > controlcode_optional;
  typedef ::xsd::cxx::tree::traits< controlcode_type, wchar_t > controlcode_traits;

  const controlcode_optional&
  controlcode () const;

  controlcode_optional&
  controlcode ();

  void
  controlcode (const controlcode_type& x);

  void
  controlcode (const controlcode_optional& x);

  void
  controlcode (::std::unique_ptr< controlcode_type > p);

  // statuscode
  //
  typedef ::text8_type statuscode_type;
  typedef ::xsd::cxx::tree::optional< statuscode_type > statuscode_optional;
  typedef ::xsd::cxx::tree::traits< statuscode_type, wchar_t > statuscode_traits;

  const statuscode_optional&
  statuscode () const;

  statuscode_optional&
  statuscode ();

  void
  statuscode (const statuscode_type& x);

  void
  statuscode (const statuscode_optional& x);

  void
  statuscode (::std::unique_ptr< statuscode_type > p);

  // extern1
  //
  typedef ::text128_type extern1_type;
  typedef ::xsd::cxx::tree::optional< extern1_type > extern1_optional;
  typedef ::xsd::cxx::tree::traits< extern1_type, wchar_t > extern1_traits;

  const extern1_optional&
  extern1 () const;

  extern1_optional&
  extern1 ();

  void
  extern1 (const extern1_type& x);

  void
  extern1 (const extern1_optional& x);

  void
  extern1 (::std::unique_ptr< extern1_type > p);

  // extern2
  //
  typedef ::text128_type extern2_type;
  typedef ::xsd::cxx::tree::optional< extern2_type > extern2_optional;
  typedef ::xsd::cxx::tree::traits< extern2_type, wchar_t > extern2_traits;

  const extern2_optional&
  extern2 () const;

  extern2_optional&
  extern2 ();

  void
  extern2 (const extern2_type& x);

  void
  extern2 (const extern2_optional& x);

  void
  extern2 (::std::unique_ptr< extern2_type > p);

  // extern3
  //
  typedef ::text128_type extern3_type;
  typedef ::xsd::cxx::tree::optional< extern3_type > extern3_optional;
  typedef ::xsd::cxx::tree::traits< extern3_type, wchar_t > extern3_traits;

  const extern3_optional&
  extern3 () const;

  extern3_optional&
  extern3 ();

  void
  extern3 (const extern3_type& x);

  void
  extern3 (const extern3_optional& x);

  void
  extern3 (::std::unique_ptr< extern3_type > p);

  // phone
  //
  typedef ::text32_type phone_type;
  typedef ::xsd::cxx::tree::optional< phone_type > phone_optional;
  typedef ::xsd::cxx::tree::traits< phone_type, wchar_t > phone_traits;

  const phone_optional&
  phone () const;

  phone_optional&
  phone ();

  void
  phone (const phone_type& x);

  void
  phone (const phone_optional& x);

  void
  phone (::std::unique_ptr< phone_type > p);

  // direct
  //
  typedef ::text32_type direct_type;
  typedef ::xsd::cxx::tree::optional< direct_type > direct_optional;
  typedef ::xsd::cxx::tree::traits< direct_type, wchar_t > direct_traits;

  const direct_optional&
  direct () const;

  direct_optional&
  direct ();

  void
  direct (const direct_type& x);

  void
  direct (const direct_optional& x);

  void
  direct (::std::unique_ptr< direct_type > p);

  // fax
  //
  typedef ::text32_type fax_type;
  typedef ::xsd::cxx::tree::optional< fax_type > fax_optional;
  typedef ::xsd::cxx::tree::traits< fax_type, wchar_t > fax_traits;

  const fax_optional&
  fax () const;

  fax_optional&
  fax ();

  void
  fax (const fax_type& x);

  void
  fax (const fax_optional& x);

  void
  fax (::std::unique_ptr< fax_type > p);

  // mobile
  //
  typedef ::text32_type mobile_type;
  typedef ::xsd::cxx::tree::optional< mobile_type > mobile_optional;
  typedef ::xsd::cxx::tree::traits< mobile_type, wchar_t > mobile_traits;

  const mobile_optional&
  mobile () const;

  mobile_optional&
  mobile ();

  void
  mobile (const mobile_type& x);

  void
  mobile (const mobile_optional& x);

  void
  mobile (::std::unique_ptr< mobile_type > p);

  // email
  //
  typedef ::text64_type email_type;
  typedef ::xsd::cxx::tree::optional< email_type > email_optional;
  typedef ::xsd::cxx::tree::traits< email_type, wchar_t > email_traits;

  const email_optional&
  email () const;

  email_optional&
  email ();

  void
  email (const email_type& x);

  void
  email (const email_optional& x);

  void
  email (::std::unique_ptr< email_type > p);

  // packages
  //
  typedef ::xml_schema::string packages_type;
  typedef ::xsd::cxx::tree::optional< packages_type > packages_optional;
  typedef ::xsd::cxx::tree::traits< packages_type, wchar_t > packages_traits;

  const packages_optional&
  packages () const;

  packages_optional&
  packages ();

  void
  packages (const packages_type& x);

  void
  packages (const packages_optional& x);

  void
  packages (::std::unique_ptr< packages_type > p);

  // workplace
  //
  typedef ::text64_type workplace_type;
  typedef ::xsd::cxx::tree::optional< workplace_type > workplace_optional;
  typedef ::xsd::cxx::tree::traits< workplace_type, wchar_t > workplace_traits;

  const workplace_optional&
  workplace () const;

  workplace_optional&
  workplace ();

  void
  workplace (const workplace_type& x);

  void
  workplace (const workplace_optional& x);

  void
  workplace (::std::unique_ptr< workplace_type > p);

  // workroles
  //
  typedef ::xml_schema::string workroles_type;
  typedef ::xsd::cxx::tree::optional< workroles_type > workroles_optional;
  typedef ::xsd::cxx::tree::traits< workroles_type, wchar_t > workroles_traits;

  const workroles_optional&
  workroles () const;

  workroles_optional&
  workroles ();

  void
  workroles (const workroles_type& x);

  void
  workroles (const workroles_optional& x);

  void
  workroles (::std::unique_ptr< workroles_type > p);

  // access
  //
  typedef ::text256_type access_type;
  typedef ::xsd::cxx::tree::optional< access_type > access_optional;
  typedef ::xsd::cxx::tree::traits< access_type, wchar_t > access_traits;

  const access_optional&
  access () const;

  access_optional&
  access ();

  void
  access (const access_type& x);

  void
  access (const access_optional& x);

  void
  access (::std::unique_ptr< access_type > p);

  // allowpassword
  //
  typedef ::bool_type allowpassword_type;
  typedef ::xsd::cxx::tree::optional< allowpassword_type > allowpassword_optional;
  typedef ::xsd::cxx::tree::traits< allowpassword_type, wchar_t > allowpassword_traits;

  const allowpassword_optional&
  allowpassword () const;

  allowpassword_optional&
  allowpassword ();

  void
  allowpassword (const allowpassword_type& x);

  void
  allowpassword (const allowpassword_optional& x);

  void
  allowpassword (::std::unique_ptr< allowpassword_type > p);

  // desc
  //
  typedef ::xml_schema::string desc_type;
  typedef ::xsd::cxx::tree::optional< desc_type > desc_optional;
  typedef ::xsd::cxx::tree::traits< desc_type, wchar_t > desc_traits;

  const desc_optional&
  desc () const;

  desc_optional&
  desc ();

  void
  desc (const desc_type& x);

  void
  desc (const desc_optional& x);

  void
  desc (::std::unique_ptr< desc_type > p);

  // remark
  //
  typedef ::xml_schema::string remark_type;
  typedef ::xsd::cxx::tree::optional< remark_type > remark_optional;
  typedef ::xsd::cxx::tree::traits< remark_type, wchar_t > remark_traits;

  const remark_optional&
  remark () const;

  remark_optional&
  remark ();

  void
  remark (const remark_type& x);

  void
  remark (const remark_optional& x);

  void
  remark (::std::unique_ptr< remark_type > p);

  // note
  //
  typedef ::xml_schema::string note_type;
  typedef ::xsd::cxx::tree::optional< note_type > note_optional;
  typedef ::xsd::cxx::tree::traits< note_type, wchar_t > note_traits;

  const note_optional&
  note () const;

  note_optional&
  note ();

  void
  note (const note_type& x);

  void
  note (const note_optional& x);

  void
  note (::std::unique_ptr< note_type > p);

  // Constructors.
  //
  bkm_user (const externalkey_type&);

  bkm_user (const bkm_user& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual bkm_user*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  bkm_user&
  operator= (const bkm_user& x);

  virtual 
  ~bkm_user ();

  // Implementation.
  //
  protected:
  id_optional id_;
  code_optional code_;
  login_optional login_;
  firstname_optional firstname_;
  lastname_optional lastname_;
  ::xsd::cxx::tree::one< externalkey_type > externalkey_;
  matchfield_optional matchfield_;
  controlcode_optional controlcode_;
  statuscode_optional statuscode_;
  extern1_optional extern1_;
  extern2_optional extern2_;
  extern3_optional extern3_;
  phone_optional phone_;
  direct_optional direct_;
  fax_optional fax_;
  mobile_optional mobile_;
  email_optional email_;
  packages_optional packages_;
  workplace_optional workplace_;
  workroles_optional workroles_;
  access_optional access_;
  allowpassword_optional allowpassword_;
  desc_optional desc_;
  remark_optional remark_;
  note_optional note_;
};

class bkm_range: public ::xml_schema::type
{
  public:
  // id
  //
  typedef ::xml_schema::int_ id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  // rangecode
  //
  typedef ::text32_type rangecode_type;
  typedef ::xsd::cxx::tree::traits< rangecode_type, wchar_t > rangecode_traits;

  const rangecode_type&
  rangecode () const;

  rangecode_type&
  rangecode ();

  void
  rangecode (const rangecode_type& x);

  void
  rangecode (::std::unique_ptr< rangecode_type > p);

  // externalkey
  //
  typedef ::externalkey_type externalkey_type;
  typedef ::xsd::cxx::tree::traits< externalkey_type, wchar_t > externalkey_traits;

  const externalkey_type&
  externalkey () const;

  externalkey_type&
  externalkey ();

  void
  externalkey (const externalkey_type& x);

  void
  externalkey (::std::unique_ptr< externalkey_type > p);

  // matchfield
  //
  typedef ::matchfieldrange_type matchfield_type;
  typedef ::xsd::cxx::tree::optional< matchfield_type > matchfield_optional;
  typedef ::xsd::cxx::tree::traits< matchfield_type, wchar_t > matchfield_traits;

  const matchfield_optional&
  matchfield () const;

  matchfield_optional&
  matchfield ();

  void
  matchfield (const matchfield_type& x);

  void
  matchfield (const matchfield_optional& x);

  void
  matchfield (::std::unique_ptr< matchfield_type > p);

  // controlcode
  //
  typedef ::text256_type controlcode_type;
  typedef ::xsd::cxx::tree::optional< controlcode_type > controlcode_optional;
  typedef ::xsd::cxx::tree::traits< controlcode_type, wchar_t > controlcode_traits;

  const controlcode_optional&
  controlcode () const;

  controlcode_optional&
  controlcode ();

  void
  controlcode (const controlcode_type& x);

  void
  controlcode (const controlcode_optional& x);

  void
  controlcode (::std::unique_ptr< controlcode_type > p);

  // keyid
  //
  typedef ::text16_type keyid_type;
  typedef ::xsd::cxx::tree::optional< keyid_type > keyid_optional;
  typedef ::xsd::cxx::tree::traits< keyid_type, wchar_t > keyid_traits;

  const keyid_optional&
  keyid () const;

  keyid_optional&
  keyid ();

  void
  keyid (const keyid_type& x);

  void
  keyid (const keyid_optional& x);

  void
  keyid (::std::unique_ptr< keyid_type > p);

  // item
  //
  typedef ::text64_type item_type;
  typedef ::xsd::cxx::tree::optional< item_type > item_optional;
  typedef ::xsd::cxx::tree::traits< item_type, wchar_t > item_traits;

  const item_optional&
  item () const;

  item_optional&
  item ();

  void
  item (const item_type& x);

  void
  item (const item_optional& x);

  void
  item (::std::unique_ptr< item_type > p);

  // code
  //
  typedef ::text16_type code_type;
  typedef ::xsd::cxx::tree::optional< code_type > code_optional;
  typedef ::xsd::cxx::tree::traits< code_type, wchar_t > code_traits;

  const code_optional&
  code () const;

  code_optional&
  code ();

  void
  code (const code_type& x);

  void
  code (const code_optional& x);

  void
  code (::std::unique_ptr< code_type > p);

  // note
  //
  typedef ::xml_schema::string note_type;
  typedef ::xsd::cxx::tree::optional< note_type > note_optional;
  typedef ::xsd::cxx::tree::traits< note_type, wchar_t > note_traits;

  const note_optional&
  note () const;

  note_optional&
  note ();

  void
  note (const note_type& x);

  void
  note (const note_optional& x);

  void
  note (::std::unique_ptr< note_type > p);

  // remark
  //
  typedef ::xml_schema::string remark_type;
  typedef ::xsd::cxx::tree::optional< remark_type > remark_optional;
  typedef ::xsd::cxx::tree::traits< remark_type, wchar_t > remark_traits;

  const remark_optional&
  remark () const;

  remark_optional&
  remark ();

  void
  remark (const remark_type& x);

  void
  remark (const remark_optional& x);

  void
  remark (::std::unique_ptr< remark_type > p);

  // Constructors.
  //
  bkm_range (const rangecode_type&,
             const externalkey_type&);

  bkm_range (const bkm_range& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  virtual bkm_range*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  bkm_range&
  operator= (const bkm_range& x);

  virtual 
  ~bkm_range ();

  // Implementation.
  //
  protected:
  id_optional id_;
  ::xsd::cxx::tree::one< rangecode_type > rangecode_;
  ::xsd::cxx::tree::one< externalkey_type > externalkey_;
  matchfield_optional matchfield_;
  controlcode_optional controlcode_;
  keyid_optional keyid_;
  item_optional item_;
  code_optional code_;
  note_optional note_;
  remark_optional remark_;
};

class bkm_city: public ::xml_schema::type
{
  public:
  // id
  //
  typedef ::xml_schema::int_ id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  // externalkey
  //
  typedef ::externalkey_type externalkey_type;
  typedef ::xsd::cxx::tree::traits< externalkey_type, wchar_t > externalkey_traits;

  const externalkey_type&
  externalkey () const;

  externalkey_type&
  externalkey ();

  void
  externalkey (const externalkey_type& x);

  void
  externalkey (::std::unique_ptr< externalkey_type > p);

  // matchfield
  //
  typedef ::matchfieldcity_type matchfield_type;
  typedef ::xsd::cxx::tree::optional< matchfield_type > matchfield_optional;
  typedef ::xsd::cxx::tree::traits< matchfield_type, wchar_t > matchfield_traits;

  const matchfield_optional&
  matchfield () const;

  matchfield_optional&
  matchfield ();

  void
  matchfield (const matchfield_type& x);

  void
  matchfield (const matchfield_optional& x);

  void
  matchfield (::std::unique_ptr< matchfield_type > p);

  // controlcode
  //
  typedef ::text256_type controlcode_type;
  typedef ::xsd::cxx::tree::optional< controlcode_type > controlcode_optional;
  typedef ::xsd::cxx::tree::traits< controlcode_type, wchar_t > controlcode_traits;

  const controlcode_optional&
  controlcode () const;

  controlcode_optional&
  controlcode ();

  void
  controlcode (const controlcode_type& x);

  void
  controlcode (const controlcode_optional& x);

  void
  controlcode (::std::unique_ptr< controlcode_type > p);

  // city
  //
  typedef ::text64_type city_type;
  typedef ::xsd::cxx::tree::optional< city_type > city_optional;
  typedef ::xsd::cxx::tree::traits< city_type, wchar_t > city_traits;

  const city_optional&
  city () const;

  city_optional&
  city ();

  void
  city (const city_type& x);

  void
  city (const city_optional& x);

  void
  city (::std::unique_ptr< city_type > p);

  // zipcode
  //
  typedef ::text16_type zipcode_type;
  typedef ::xsd::cxx::tree::optional< zipcode_type > zipcode_optional;
  typedef ::xsd::cxx::tree::traits< zipcode_type, wchar_t > zipcode_traits;

  const zipcode_optional&
  zipcode () const;

  zipcode_optional&
  zipcode ();

  void
  zipcode (const zipcode_type& x);

  void
  zipcode (const zipcode_optional& x);

  void
  zipcode (::std::unique_ptr< zipcode_type > p);

  // statecode
  //
  typedef ::text8_type statecode_type;
  typedef ::xsd::cxx::tree::optional< statecode_type > statecode_optional;
  typedef ::xsd::cxx::tree::traits< statecode_type, wchar_t > statecode_traits;

  const statecode_optional&
  statecode () const;

  statecode_optional&
  statecode ();

  void
  statecode (const statecode_type& x);

  void
  statecode (const statecode_optional& x);

  void
  statecode (::std::unique_ptr< statecode_type > p);

  // areacode
  //
  typedef ::text8_type areacode_type;
  typedef ::xsd::cxx::tree::optional< areacode_type > areacode_optional;
  typedef ::xsd::cxx::tree::traits< areacode_type, wchar_t > areacode_traits;

  const areacode_optional&
  areacode () const;

  areacode_optional&
  areacode ();

  void
  areacode (const areacode_type& x);

  void
  areacode (const areacode_optional& x);

  void
  areacode (::std::unique_ptr< areacode_type > p);

  // desc
  //
  typedef ::xml_schema::string desc_type;
  typedef ::xsd::cxx::tree::optional< desc_type > desc_optional;
  typedef ::xsd::cxx::tree::traits< desc_type, wchar_t > desc_traits;

  const desc_optional&
  desc () const;

  desc_optional&
  desc ();

  void
  desc (const desc_type& x);

  void
  desc (const desc_optional& x);

  void
  desc (::std::unique_ptr< desc_type > p);

  // note
  //
  typedef ::xml_schema::string note_type;
  typedef ::xsd::cxx::tree::optional< note_type > note_optional;
  typedef ::xsd::cxx::tree::traits< note_type, wchar_t > note_traits;

  const note_optional&
  note () const;

  note_optional&
  note ();

  void
  note (const note_type& x);

  void
  note (const note_optional& x);

  void
  note (::std::unique_ptr< note_type > p);

  // remark
  //
  typedef ::xml_schema::string remark_type;
  typedef ::xsd::cxx::tree::optional< remark_type > remark_optional;
  typedef ::xsd::cxx::tree::traits< remark_type, wchar_t > remark_traits;

  const remark_optional&
  remark () const;

  remark_optional&
  remark ();

  void
  remark (const remark_type& x);

  void
  remark (const remark_optional& x);

  void
  remark (::std::unique_ptr< remark_type > p);

  // Constructors.
  //
  bkm_city (const externalkey_type&);

  bkm_city (const bkm_city& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual bkm_city*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  bkm_city&
  operator= (const bkm_city& x);

  virtual 
  ~bkm_city ();

  // Implementation.
  //
  protected:
  id_optional id_;
  ::xsd::cxx::tree::one< externalkey_type > externalkey_;
  matchfield_optional matchfield_;
  controlcode_optional controlcode_;
  city_optional city_;
  zipcode_optional zipcode_;
  statecode_optional statecode_;
  areacode_optional areacode_;
  desc_optional desc_;
  note_optional note_;
  remark_optional remark_;
};

class bkm_bank: public ::xml_schema::type
{
  public:
  // id
  //
  typedef ::xml_schema::int_ id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  // externalkey
  //
  typedef ::externalkey_type externalkey_type;
  typedef ::xsd::cxx::tree::traits< externalkey_type, wchar_t > externalkey_traits;

  const externalkey_type&
  externalkey () const;

  externalkey_type&
  externalkey ();

  void
  externalkey (const externalkey_type& x);

  void
  externalkey (::std::unique_ptr< externalkey_type > p);

  // matchfield
  //
  typedef ::matchfieldbank_type matchfield_type;
  typedef ::xsd::cxx::tree::optional< matchfield_type > matchfield_optional;
  typedef ::xsd::cxx::tree::traits< matchfield_type, wchar_t > matchfield_traits;

  const matchfield_optional&
  matchfield () const;

  matchfield_optional&
  matchfield ();

  void
  matchfield (const matchfield_type& x);

  void
  matchfield (const matchfield_optional& x);

  void
  matchfield (::std::unique_ptr< matchfield_type > p);

  // controlcode
  //
  typedef ::text256_type controlcode_type;
  typedef ::xsd::cxx::tree::optional< controlcode_type > controlcode_optional;
  typedef ::xsd::cxx::tree::traits< controlcode_type, wchar_t > controlcode_traits;

  const controlcode_optional&
  controlcode () const;

  controlcode_optional&
  controlcode ();

  void
  controlcode (const controlcode_type& x);

  void
  controlcode (const controlcode_optional& x);

  void
  controlcode (::std::unique_ptr< controlcode_type > p);

  // blz
  //
  typedef ::text16_type blz_type;
  typedef ::xsd::cxx::tree::optional< blz_type > blz_optional;
  typedef ::xsd::cxx::tree::traits< blz_type, wchar_t > blz_traits;

  const blz_optional&
  blz () const;

  blz_optional&
  blz ();

  void
  blz (const blz_type& x);

  void
  blz (const blz_optional& x);

  void
  blz (::std::unique_ptr< blz_type > p);

  // swift
  //
  typedef ::text16_type swift_type;
  typedef ::xsd::cxx::tree::optional< swift_type > swift_optional;
  typedef ::xsd::cxx::tree::traits< swift_type, wchar_t > swift_traits;

  const swift_optional&
  swift () const;

  swift_optional&
  swift ();

  void
  swift (const swift_type& x);

  void
  swift (const swift_optional& x);

  void
  swift (::std::unique_ptr< swift_type > p);

  // bin
  //
  typedef ::text32_type bin_type;
  typedef ::xsd::cxx::tree::optional< bin_type > bin_optional;
  typedef ::xsd::cxx::tree::traits< bin_type, wchar_t > bin_traits;

  const bin_optional&
  bin () const;

  bin_optional&
  bin ();

  void
  bin (const bin_type& x);

  void
  bin (const bin_optional& x);

  void
  bin (::std::unique_ptr< bin_type > p);

  // bank
  //
  typedef ::text64_type bank_type;
  typedef ::xsd::cxx::tree::optional< bank_type > bank_optional;
  typedef ::xsd::cxx::tree::traits< bank_type, wchar_t > bank_traits;

  const bank_optional&
  bank () const;

  bank_optional&
  bank ();

  void
  bank (const bank_type& x);

  void
  bank (const bank_optional& x);

  void
  bank (::std::unique_ptr< bank_type > p);

  // city
  //
  typedef ::text64_type city_type;
  typedef ::xsd::cxx::tree::optional< city_type > city_optional;
  typedef ::xsd::cxx::tree::traits< city_type, wchar_t > city_traits;

  const city_optional&
  city () const;

  city_optional&
  city ();

  void
  city (const city_type& x);

  void
  city (const city_optional& x);

  void
  city (::std::unique_ptr< city_type > p);

  // zipcode
  //
  typedef ::text16_type zipcode_type;
  typedef ::xsd::cxx::tree::optional< zipcode_type > zipcode_optional;
  typedef ::xsd::cxx::tree::traits< zipcode_type, wchar_t > zipcode_traits;

  const zipcode_optional&
  zipcode () const;

  zipcode_optional&
  zipcode ();

  void
  zipcode (const zipcode_type& x);

  void
  zipcode (const zipcode_optional& x);

  void
  zipcode (::std::unique_ptr< zipcode_type > p);

  // street
  //
  typedef ::text64_type street_type;
  typedef ::xsd::cxx::tree::optional< street_type > street_optional;
  typedef ::xsd::cxx::tree::traits< street_type, wchar_t > street_traits;

  const street_optional&
  street () const;

  street_optional&
  street ();

  void
  street (const street_type& x);

  void
  street (const street_optional& x);

  void
  street (::std::unique_ptr< street_type > p);

  // phone
  //
  typedef ::text32_type phone_type;
  typedef ::xsd::cxx::tree::optional< phone_type > phone_optional;
  typedef ::xsd::cxx::tree::traits< phone_type, wchar_t > phone_traits;

  const phone_optional&
  phone () const;

  phone_optional&
  phone ();

  void
  phone (const phone_type& x);

  void
  phone (const phone_optional& x);

  void
  phone (::std::unique_ptr< phone_type > p);

  // fax
  //
  typedef ::text32_type fax_type;
  typedef ::xsd::cxx::tree::optional< fax_type > fax_optional;
  typedef ::xsd::cxx::tree::traits< fax_type, wchar_t > fax_traits;

  const fax_optional&
  fax () const;

  fax_optional&
  fax ();

  void
  fax (const fax_type& x);

  void
  fax (const fax_optional& x);

  void
  fax (::std::unique_ptr< fax_type > p);

  // email
  //
  typedef ::text64_type email_type;
  typedef ::xsd::cxx::tree::optional< email_type > email_optional;
  typedef ::xsd::cxx::tree::traits< email_type, wchar_t > email_traits;

  const email_optional&
  email () const;

  email_optional&
  email ();

  void
  email (const email_type& x);

  void
  email (const email_optional& x);

  void
  email (::std::unique_ptr< email_type > p);

  // homepage
  //
  typedef ::text64_type homepage_type;
  typedef ::xsd::cxx::tree::optional< homepage_type > homepage_optional;
  typedef ::xsd::cxx::tree::traits< homepage_type, wchar_t > homepage_traits;

  const homepage_optional&
  homepage () const;

  homepage_optional&
  homepage ();

  void
  homepage (const homepage_type& x);

  void
  homepage (const homepage_optional& x);

  void
  homepage (::std::unique_ptr< homepage_type > p);

  // statecode
  //
  typedef ::text8_type statecode_type;
  typedef ::xsd::cxx::tree::optional< statecode_type > statecode_optional;
  typedef ::xsd::cxx::tree::traits< statecode_type, wchar_t > statecode_traits;

  const statecode_optional&
  statecode () const;

  statecode_optional&
  statecode ();

  void
  statecode (const statecode_type& x);

  void
  statecode (const statecode_optional& x);

  void
  statecode (::std::unique_ptr< statecode_type > p);

  // desc
  //
  typedef ::xml_schema::string desc_type;
  typedef ::xsd::cxx::tree::optional< desc_type > desc_optional;
  typedef ::xsd::cxx::tree::traits< desc_type, wchar_t > desc_traits;

  const desc_optional&
  desc () const;

  desc_optional&
  desc ();

  void
  desc (const desc_type& x);

  void
  desc (const desc_optional& x);

  void
  desc (::std::unique_ptr< desc_type > p);

  // note
  //
  typedef ::xml_schema::string note_type;
  typedef ::xsd::cxx::tree::optional< note_type > note_optional;
  typedef ::xsd::cxx::tree::traits< note_type, wchar_t > note_traits;

  const note_optional&
  note () const;

  note_optional&
  note ();

  void
  note (const note_type& x);

  void
  note (const note_optional& x);

  void
  note (::std::unique_ptr< note_type > p);

  // remark
  //
  typedef ::xml_schema::string remark_type;
  typedef ::xsd::cxx::tree::optional< remark_type > remark_optional;
  typedef ::xsd::cxx::tree::traits< remark_type, wchar_t > remark_traits;

  const remark_optional&
  remark () const;

  remark_optional&
  remark ();

  void
  remark (const remark_type& x);

  void
  remark (const remark_optional& x);

  void
  remark (::std::unique_ptr< remark_type > p);

  // Constructors.
  //
  bkm_bank (const externalkey_type&);

  bkm_bank (const bkm_bank& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual bkm_bank*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  bkm_bank&
  operator= (const bkm_bank& x);

  virtual 
  ~bkm_bank ();

  // Implementation.
  //
  protected:
  id_optional id_;
  ::xsd::cxx::tree::one< externalkey_type > externalkey_;
  matchfield_optional matchfield_;
  controlcode_optional controlcode_;
  blz_optional blz_;
  swift_optional swift_;
  bin_optional bin_;
  bank_optional bank_;
  city_optional city_;
  zipcode_optional zipcode_;
  street_optional street_;
  phone_optional phone_;
  fax_optional fax_;
  email_optional email_;
  homepage_optional homepage_;
  statecode_optional statecode_;
  desc_optional desc_;
  note_optional note_;
  remark_optional remark_;
};

class bkm_parish: public ::xml_schema::type
{
  public:
  // id
  //
  typedef ::xml_schema::int_ id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  // externalkey
  //
  typedef ::externalkey_type externalkey_type;
  typedef ::xsd::cxx::tree::traits< externalkey_type, wchar_t > externalkey_traits;

  const externalkey_type&
  externalkey () const;

  externalkey_type&
  externalkey ();

  void
  externalkey (const externalkey_type& x);

  void
  externalkey (::std::unique_ptr< externalkey_type > p);

  // managerkey
  //
  typedef ::externalkey_type managerkey_type;
  typedef ::xsd::cxx::tree::optional< managerkey_type > managerkey_optional;
  typedef ::xsd::cxx::tree::traits< managerkey_type, wchar_t > managerkey_traits;

  const managerkey_optional&
  managerkey () const;

  managerkey_optional&
  managerkey ();

  void
  managerkey (const managerkey_type& x);

  void
  managerkey (const managerkey_optional& x);

  void
  managerkey (::std::unique_ptr< managerkey_type > p);

  // parentkey
  //
  typedef ::externalkey_type parentkey_type;
  typedef ::xsd::cxx::tree::optional< parentkey_type > parentkey_optional;
  typedef ::xsd::cxx::tree::traits< parentkey_type, wchar_t > parentkey_traits;

  const parentkey_optional&
  parentkey () const;

  parentkey_optional&
  parentkey ();

  void
  parentkey (const parentkey_type& x);

  void
  parentkey (const parentkey_optional& x);

  void
  parentkey (::std::unique_ptr< parentkey_type > p);

  // matchfield
  //
  typedef ::matchfieldparish_type matchfield_type;
  typedef ::xsd::cxx::tree::optional< matchfield_type > matchfield_optional;
  typedef ::xsd::cxx::tree::traits< matchfield_type, wchar_t > matchfield_traits;

  const matchfield_optional&
  matchfield () const;

  matchfield_optional&
  matchfield ();

  void
  matchfield (const matchfield_type& x);

  void
  matchfield (const matchfield_optional& x);

  void
  matchfield (::std::unique_ptr< matchfield_type > p);

  // controlcode
  //
  typedef ::text256_type controlcode_type;
  typedef ::xsd::cxx::tree::optional< controlcode_type > controlcode_optional;
  typedef ::xsd::cxx::tree::traits< controlcode_type, wchar_t > controlcode_traits;

  const controlcode_optional&
  controlcode () const;

  controlcode_optional&
  controlcode ();

  void
  controlcode (const controlcode_type& x);

  void
  controlcode (const controlcode_optional& x);

  void
  controlcode (::std::unique_ptr< controlcode_type > p);

  // name
  //
  typedef ::text64_type name_type;
  typedef ::xsd::cxx::tree::optional< name_type > name_optional;
  typedef ::xsd::cxx::tree::traits< name_type, wchar_t > name_traits;

  const name_optional&
  name () const;

  name_optional&
  name ();

  void
  name (const name_type& x);

  void
  name (const name_optional& x);

  void
  name (::std::unique_ptr< name_type > p);

  // parish
  //
  typedef ::text256_type parish_type;
  typedef ::xsd::cxx::tree::optional< parish_type > parish_optional;
  typedef ::xsd::cxx::tree::traits< parish_type, wchar_t > parish_traits;

  const parish_optional&
  parish () const;

  parish_optional&
  parish ();

  void
  parish (const parish_type& x);

  void
  parish (const parish_optional& x);

  void
  parish (::std::unique_ptr< parish_type > p);

  // code
  //
  typedef ::text32_type code_type;
  typedef ::xsd::cxx::tree::optional< code_type > code_optional;
  typedef ::xsd::cxx::tree::traits< code_type, wchar_t > code_traits;

  const code_optional&
  code () const;

  code_optional&
  code ();

  void
  code (const code_type& x);

  void
  code (const code_optional& x);

  void
  code (::std::unique_ptr< code_type > p);

  // levelcode
  //
  typedef ::text256_type levelcode_type;
  typedef ::xsd::cxx::tree::optional< levelcode_type > levelcode_optional;
  typedef ::xsd::cxx::tree::traits< levelcode_type, wchar_t > levelcode_traits;

  const levelcode_optional&
  levelcode () const;

  levelcode_optional&
  levelcode ();

  void
  levelcode (const levelcode_type& x);

  void
  levelcode (const levelcode_optional& x);

  void
  levelcode (::std::unique_ptr< levelcode_type > p);

  // city
  //
  typedef ::text64_type city_type;
  typedef ::xsd::cxx::tree::optional< city_type > city_optional;
  typedef ::xsd::cxx::tree::traits< city_type, wchar_t > city_traits;

  const city_optional&
  city () const;

  city_optional&
  city ();

  void
  city (const city_type& x);

  void
  city (const city_optional& x);

  void
  city (::std::unique_ptr< city_type > p);

  // zipcode
  //
  typedef ::text16_type zipcode_type;
  typedef ::xsd::cxx::tree::optional< zipcode_type > zipcode_optional;
  typedef ::xsd::cxx::tree::traits< zipcode_type, wchar_t > zipcode_traits;

  const zipcode_optional&
  zipcode () const;

  zipcode_optional&
  zipcode ();

  void
  zipcode (const zipcode_type& x);

  void
  zipcode (const zipcode_optional& x);

  void
  zipcode (::std::unique_ptr< zipcode_type > p);

  // street
  //
  typedef ::text64_type street_type;
  typedef ::xsd::cxx::tree::optional< street_type > street_optional;
  typedef ::xsd::cxx::tree::traits< street_type, wchar_t > street_traits;

  const street_optional&
  street () const;

  street_optional&
  street ();

  void
  street (const street_type& x);

  void
  street (const street_optional& x);

  void
  street (::std::unique_ptr< street_type > p);

  // phone
  //
  typedef ::text32_type phone_type;
  typedef ::xsd::cxx::tree::optional< phone_type > phone_optional;
  typedef ::xsd::cxx::tree::traits< phone_type, wchar_t > phone_traits;

  const phone_optional&
  phone () const;

  phone_optional&
  phone ();

  void
  phone (const phone_type& x);

  void
  phone (const phone_optional& x);

  void
  phone (::std::unique_ptr< phone_type > p);

  // fax
  //
  typedef ::text32_type fax_type;
  typedef ::xsd::cxx::tree::optional< fax_type > fax_optional;
  typedef ::xsd::cxx::tree::traits< fax_type, wchar_t > fax_traits;

  const fax_optional&
  fax () const;

  fax_optional&
  fax ();

  void
  fax (const fax_type& x);

  void
  fax (const fax_optional& x);

  void
  fax (::std::unique_ptr< fax_type > p);

  // email
  //
  typedef ::text64_type email_type;
  typedef ::xsd::cxx::tree::optional< email_type > email_optional;
  typedef ::xsd::cxx::tree::traits< email_type, wchar_t > email_traits;

  const email_optional&
  email () const;

  email_optional&
  email ();

  void
  email (const email_type& x);

  void
  email (const email_optional& x);

  void
  email (::std::unique_ptr< email_type > p);

  // homepage
  //
  typedef ::text64_type homepage_type;
  typedef ::xsd::cxx::tree::optional< homepage_type > homepage_optional;
  typedef ::xsd::cxx::tree::traits< homepage_type, wchar_t > homepage_traits;

  const homepage_optional&
  homepage () const;

  homepage_optional&
  homepage ();

  void
  homepage (const homepage_type& x);

  void
  homepage (const homepage_optional& x);

  void
  homepage (::std::unique_ptr< homepage_type > p);

  // statecode
  //
  typedef ::text8_type statecode_type;
  typedef ::xsd::cxx::tree::optional< statecode_type > statecode_optional;
  typedef ::xsd::cxx::tree::traits< statecode_type, wchar_t > statecode_traits;

  const statecode_optional&
  statecode () const;

  statecode_optional&
  statecode ();

  void
  statecode (const statecode_type& x);

  void
  statecode (const statecode_optional& x);

  void
  statecode (::std::unique_ptr< statecode_type > p);

  // garage
  //
  typedef ::text16_type garage_type;
  typedef ::xsd::cxx::tree::optional< garage_type > garage_optional;
  typedef ::xsd::cxx::tree::traits< garage_type, wchar_t > garage_traits;

  const garage_optional&
  garage () const;

  garage_optional&
  garage ();

  void
  garage (const garage_type& x);

  void
  garage (const garage_optional& x);

  void
  garage (::std::unique_ptr< garage_type > p);

  // parking
  //
  typedef ::text16_type parking_type;
  typedef ::xsd::cxx::tree::optional< parking_type > parking_optional;
  typedef ::xsd::cxx::tree::traits< parking_type, wchar_t > parking_traits;

  const parking_optional&
  parking () const;

  parking_optional&
  parking ();

  void
  parking (const parking_type& x);

  void
  parking (const parking_optional& x);

  void
  parking (::std::unique_ptr< parking_type > p);

  // commercial
  //
  typedef ::text16_type commercial_type;
  typedef ::xsd::cxx::tree::optional< commercial_type > commercial_optional;
  typedef ::xsd::cxx::tree::traits< commercial_type, wchar_t > commercial_traits;

  const commercial_optional&
  commercial () const;

  commercial_optional&
  commercial ();

  void
  commercial (const commercial_type& x);

  void
  commercial (const commercial_optional& x);

  void
  commercial (::std::unique_ptr< commercial_type > p);

  // object
  //
  typedef ::text16_type object_type;
  typedef ::xsd::cxx::tree::optional< object_type > object_optional;
  typedef ::xsd::cxx::tree::traits< object_type, wchar_t > object_traits;

  const object_optional&
  object () const;

  object_optional&
  object ();

  void
  object (const object_type& x);

  void
  object (const object_optional& x);

  void
  object (::std::unique_ptr< object_type > p);

  // area
  //
  typedef ::text16_type area_type;
  typedef ::xsd::cxx::tree::optional< area_type > area_optional;
  typedef ::xsd::cxx::tree::traits< area_type, wchar_t > area_traits;

  const area_optional&
  area () const;

  area_optional&
  area ();

  void
  area (const area_type& x);

  void
  area (const area_optional& x);

  void
  area (::std::unique_ptr< area_type > p);

  // duplex
  //
  typedef ::text16_type duplex_type;
  typedef ::xsd::cxx::tree::optional< duplex_type > duplex_optional;
  typedef ::xsd::cxx::tree::traits< duplex_type, wchar_t > duplex_traits;

  const duplex_optional&
  duplex () const;

  duplex_optional&
  duplex ();

  void
  duplex (const duplex_type& x);

  void
  duplex (const duplex_optional& x);

  void
  duplex (::std::unique_ptr< duplex_type > p);

  // underground
  //
  typedef ::text16_type underground_type;
  typedef ::xsd::cxx::tree::optional< underground_type > underground_optional;
  typedef ::xsd::cxx::tree::traits< underground_type, wchar_t > underground_traits;

  const underground_optional&
  underground () const;

  underground_optional&
  underground ();

  void
  underground (const underground_type& x);

  void
  underground (const underground_optional& x);

  void
  underground (::std::unique_ptr< underground_type > p);

  // statuscode
  //
  typedef ::text8_type statuscode_type;
  typedef ::xsd::cxx::tree::optional< statuscode_type > statuscode_optional;
  typedef ::xsd::cxx::tree::traits< statuscode_type, wchar_t > statuscode_traits;

  const statuscode_optional&
  statuscode () const;

  statuscode_optional&
  statuscode ();

  void
  statuscode (const statuscode_type& x);

  void
  statuscode (const statuscode_optional& x);

  void
  statuscode (::std::unique_ptr< statuscode_type > p);

  // groupcode
  //
  typedef ::text8_type groupcode_type;
  typedef ::xsd::cxx::tree::optional< groupcode_type > groupcode_optional;
  typedef ::xsd::cxx::tree::traits< groupcode_type, wchar_t > groupcode_traits;

  const groupcode_optional&
  groupcode () const;

  groupcode_optional&
  groupcode ();

  void
  groupcode (const groupcode_type& x);

  void
  groupcode (const groupcode_optional& x);

  void
  groupcode (::std::unique_ptr< groupcode_type > p);

  // desc
  //
  typedef ::xml_schema::string desc_type;
  typedef ::xsd::cxx::tree::optional< desc_type > desc_optional;
  typedef ::xsd::cxx::tree::traits< desc_type, wchar_t > desc_traits;

  const desc_optional&
  desc () const;

  desc_optional&
  desc ();

  void
  desc (const desc_type& x);

  void
  desc (const desc_optional& x);

  void
  desc (::std::unique_ptr< desc_type > p);

  // note
  //
  typedef ::xml_schema::string note_type;
  typedef ::xsd::cxx::tree::optional< note_type > note_optional;
  typedef ::xsd::cxx::tree::traits< note_type, wchar_t > note_traits;

  const note_optional&
  note () const;

  note_optional&
  note ();

  void
  note (const note_type& x);

  void
  note (const note_optional& x);

  void
  note (::std::unique_ptr< note_type > p);

  // remark
  //
  typedef ::xml_schema::string remark_type;
  typedef ::xsd::cxx::tree::optional< remark_type > remark_optional;
  typedef ::xsd::cxx::tree::traits< remark_type, wchar_t > remark_traits;

  const remark_optional&
  remark () const;

  remark_optional&
  remark ();

  void
  remark (const remark_type& x);

  void
  remark (const remark_optional& x);

  void
  remark (::std::unique_ptr< remark_type > p);

  // Constructors.
  //
  bkm_parish (const externalkey_type&);

  bkm_parish (const bkm_parish& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual bkm_parish*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  bkm_parish&
  operator= (const bkm_parish& x);

  virtual 
  ~bkm_parish ();

  // Implementation.
  //
  protected:
  id_optional id_;
  ::xsd::cxx::tree::one< externalkey_type > externalkey_;
  managerkey_optional managerkey_;
  parentkey_optional parentkey_;
  matchfield_optional matchfield_;
  controlcode_optional controlcode_;
  name_optional name_;
  parish_optional parish_;
  code_optional code_;
  levelcode_optional levelcode_;
  city_optional city_;
  zipcode_optional zipcode_;
  street_optional street_;
  phone_optional phone_;
  fax_optional fax_;
  email_optional email_;
  homepage_optional homepage_;
  statecode_optional statecode_;
  garage_optional garage_;
  parking_optional parking_;
  commercial_optional commercial_;
  object_optional object_;
  area_optional area_;
  duplex_optional duplex_;
  underground_optional underground_;
  statuscode_optional statuscode_;
  groupcode_optional groupcode_;
  desc_optional desc_;
  note_optional note_;
  remark_optional remark_;
};

class bkm_contact: public ::xml_schema::type
{
  public:
  // id
  //
  typedef ::xml_schema::int_ id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  // externalkey
  //
  typedef ::externalkey_type externalkey_type;
  typedef ::xsd::cxx::tree::traits< externalkey_type, wchar_t > externalkey_traits;

  const externalkey_type&
  externalkey () const;

  externalkey_type&
  externalkey ();

  void
  externalkey (const externalkey_type& x);

  void
  externalkey (::std::unique_ptr< externalkey_type > p);

  // matchfield
  //
  typedef ::matchfieldcontact_type matchfield_type;
  typedef ::xsd::cxx::tree::optional< matchfield_type > matchfield_optional;
  typedef ::xsd::cxx::tree::traits< matchfield_type, wchar_t > matchfield_traits;

  const matchfield_optional&
  matchfield () const;

  matchfield_optional&
  matchfield ();

  void
  matchfield (const matchfield_type& x);

  void
  matchfield (const matchfield_optional& x);

  void
  matchfield (::std::unique_ptr< matchfield_type > p);

  // controlcode
  //
  typedef ::text256_type controlcode_type;
  typedef ::xsd::cxx::tree::optional< controlcode_type > controlcode_optional;
  typedef ::xsd::cxx::tree::traits< controlcode_type, wchar_t > controlcode_traits;

  const controlcode_optional&
  controlcode () const;

  controlcode_optional&
  controlcode ();

  void
  controlcode (const controlcode_type& x);

  void
  controlcode (const controlcode_optional& x);

  void
  controlcode (::std::unique_ptr< controlcode_type > p);

  // keyid
  //
  typedef ::text16_type keyid_type;
  typedef ::xsd::cxx::tree::optional< keyid_type > keyid_optional;
  typedef ::xsd::cxx::tree::traits< keyid_type, wchar_t > keyid_traits;

  const keyid_optional&
  keyid () const;

  keyid_optional&
  keyid ();

  void
  keyid (const keyid_type& x);

  void
  keyid (const keyid_optional& x);

  void
  keyid (::std::unique_ptr< keyid_type > p);

  // taxid
  //
  typedef ::text32_type taxid_type;
  typedef ::xsd::cxx::tree::optional< taxid_type > taxid_optional;
  typedef ::xsd::cxx::tree::traits< taxid_type, wchar_t > taxid_traits;

  const taxid_optional&
  taxid () const;

  taxid_optional&
  taxid ();

  void
  taxid (const taxid_type& x);

  void
  taxid (const taxid_optional& x);

  void
  taxid (::std::unique_ptr< taxid_type > p);

  // synonym
  //
  typedef ::text64_type synonym_type;
  typedef ::xsd::cxx::tree::optional< synonym_type > synonym_optional;
  typedef ::xsd::cxx::tree::traits< synonym_type, wchar_t > synonym_traits;

  const synonym_optional&
  synonym () const;

  synonym_optional&
  synonym ();

  void
  synonym (const synonym_type& x);

  void
  synonym (const synonym_optional& x);

  void
  synonym (::std::unique_ptr< synonym_type > p);

  // name1
  //
  typedef ::text64_type name1_type;
  typedef ::xsd::cxx::tree::optional< name1_type > name1_optional;
  typedef ::xsd::cxx::tree::traits< name1_type, wchar_t > name1_traits;

  const name1_optional&
  name1 () const;

  name1_optional&
  name1 ();

  void
  name1 (const name1_type& x);

  void
  name1 (const name1_optional& x);

  void
  name1 (::std::unique_ptr< name1_type > p);

  // name2
  //
  typedef ::text64_type name2_type;
  typedef ::xsd::cxx::tree::optional< name2_type > name2_optional;
  typedef ::xsd::cxx::tree::traits< name2_type, wchar_t > name2_traits;

  const name2_optional&
  name2 () const;

  name2_optional&
  name2 ();

  void
  name2 (const name2_type& x);

  void
  name2 (const name2_optional& x);

  void
  name2 (::std::unique_ptr< name2_type > p);

  // name3
  //
  typedef ::text64_type name3_type;
  typedef ::xsd::cxx::tree::optional< name3_type > name3_optional;
  typedef ::xsd::cxx::tree::traits< name3_type, wchar_t > name3_traits;

  const name3_optional&
  name3 () const;

  name3_optional&
  name3 ();

  void
  name3 (const name3_type& x);

  void
  name3 (const name3_optional& x);

  void
  name3 (::std::unique_ptr< name3_type > p);

  // city
  //
  typedef ::text64_type city_type;
  typedef ::xsd::cxx::tree::optional< city_type > city_optional;
  typedef ::xsd::cxx::tree::traits< city_type, wchar_t > city_traits;

  const city_optional&
  city () const;

  city_optional&
  city ();

  void
  city (const city_type& x);

  void
  city (const city_optional& x);

  void
  city (::std::unique_ptr< city_type > p);

  // zipcode
  //
  typedef ::text16_type zipcode_type;
  typedef ::xsd::cxx::tree::optional< zipcode_type > zipcode_optional;
  typedef ::xsd::cxx::tree::traits< zipcode_type, wchar_t > zipcode_traits;

  const zipcode_optional&
  zipcode () const;

  zipcode_optional&
  zipcode ();

  void
  zipcode (const zipcode_type& x);

  void
  zipcode (const zipcode_optional& x);

  void
  zipcode (::std::unique_ptr< zipcode_type > p);

  // street
  //
  typedef ::text64_type street_type;
  typedef ::xsd::cxx::tree::optional< street_type > street_optional;
  typedef ::xsd::cxx::tree::traits< street_type, wchar_t > street_traits;

  const street_optional&
  street () const;

  street_optional&
  street ();

  void
  street (const street_type& x);

  void
  street (const street_optional& x);

  void
  street (::std::unique_ptr< street_type > p);

  // extern1
  //
  typedef ::text128_type extern1_type;
  typedef ::xsd::cxx::tree::optional< extern1_type > extern1_optional;
  typedef ::xsd::cxx::tree::traits< extern1_type, wchar_t > extern1_traits;

  const extern1_optional&
  extern1 () const;

  extern1_optional&
  extern1 ();

  void
  extern1 (const extern1_type& x);

  void
  extern1 (const extern1_optional& x);

  void
  extern1 (::std::unique_ptr< extern1_type > p);

  // extern2
  //
  typedef ::text128_type extern2_type;
  typedef ::xsd::cxx::tree::optional< extern2_type > extern2_optional;
  typedef ::xsd::cxx::tree::traits< extern2_type, wchar_t > extern2_traits;

  const extern2_optional&
  extern2 () const;

  extern2_optional&
  extern2 ();

  void
  extern2 (const extern2_type& x);

  void
  extern2 (const extern2_optional& x);

  void
  extern2 (::std::unique_ptr< extern2_type > p);

  // extern3
  //
  typedef ::text128_type extern3_type;
  typedef ::xsd::cxx::tree::optional< extern3_type > extern3_optional;
  typedef ::xsd::cxx::tree::traits< extern3_type, wchar_t > extern3_traits;

  const extern3_optional&
  extern3 () const;

  extern3_optional&
  extern3 ();

  void
  extern3 (const extern3_type& x);

  void
  extern3 (const extern3_optional& x);

  void
  extern3 (::std::unique_ptr< extern3_type > p);

  // phone
  //
  typedef ::text32_type phone_type;
  typedef ::xsd::cxx::tree::optional< phone_type > phone_optional;
  typedef ::xsd::cxx::tree::traits< phone_type, wchar_t > phone_traits;

  const phone_optional&
  phone () const;

  phone_optional&
  phone ();

  void
  phone (const phone_type& x);

  void
  phone (const phone_optional& x);

  void
  phone (::std::unique_ptr< phone_type > p);

  // phone2
  //
  typedef ::text32_type phone2_type;
  typedef ::xsd::cxx::tree::optional< phone2_type > phone2_optional;
  typedef ::xsd::cxx::tree::traits< phone2_type, wchar_t > phone2_traits;

  const phone2_optional&
  phone2 () const;

  phone2_optional&
  phone2 ();

  void
  phone2 (const phone2_type& x);

  void
  phone2 (const phone2_optional& x);

  void
  phone2 (::std::unique_ptr< phone2_type > p);

  // phone3
  //
  typedef ::text32_type phone3_type;
  typedef ::xsd::cxx::tree::optional< phone3_type > phone3_optional;
  typedef ::xsd::cxx::tree::traits< phone3_type, wchar_t > phone3_traits;

  const phone3_optional&
  phone3 () const;

  phone3_optional&
  phone3 ();

  void
  phone3 (const phone3_type& x);

  void
  phone3 (const phone3_optional& x);

  void
  phone3 (::std::unique_ptr< phone3_type > p);

  // fax
  //
  typedef ::text32_type fax_type;
  typedef ::xsd::cxx::tree::optional< fax_type > fax_optional;
  typedef ::xsd::cxx::tree::traits< fax_type, wchar_t > fax_traits;

  const fax_optional&
  fax () const;

  fax_optional&
  fax ();

  void
  fax (const fax_type& x);

  void
  fax (const fax_optional& x);

  void
  fax (::std::unique_ptr< fax_type > p);

  // email
  //
  typedef ::text64_type email_type;
  typedef ::xsd::cxx::tree::optional< email_type > email_optional;
  typedef ::xsd::cxx::tree::traits< email_type, wchar_t > email_traits;

  const email_optional&
  email () const;

  email_optional&
  email ();

  void
  email (const email_type& x);

  void
  email (const email_optional& x);

  void
  email (::std::unique_ptr< email_type > p);

  // homepage
  //
  typedef ::text64_type homepage_type;
  typedef ::xsd::cxx::tree::optional< homepage_type > homepage_optional;
  typedef ::xsd::cxx::tree::traits< homepage_type, wchar_t > homepage_traits;

  const homepage_optional&
  homepage () const;

  homepage_optional&
  homepage ();

  void
  homepage (const homepage_type& x);

  void
  homepage (const homepage_optional& x);

  void
  homepage (::std::unique_ptr< homepage_type > p);

  // vatid
  //
  typedef ::text16_type vatid_type;
  typedef ::xsd::cxx::tree::optional< vatid_type > vatid_optional;
  typedef ::xsd::cxx::tree::traits< vatid_type, wchar_t > vatid_traits;

  const vatid_optional&
  vatid () const;

  vatid_optional&
  vatid ();

  void
  vatid (const vatid_type& x);

  void
  vatid (const vatid_optional& x);

  void
  vatid (::std::unique_ptr< vatid_type > p);

  // vatexemption
  //
  typedef ::xml_schema::date vatexemption_type;
  typedef ::xsd::cxx::tree::optional< vatexemption_type > vatexemption_optional;
  typedef ::xsd::cxx::tree::traits< vatexemption_type, wchar_t > vatexemption_traits;

  const vatexemption_optional&
  vatexemption () const;

  vatexemption_optional&
  vatexemption ();

  void
  vatexemption (const vatexemption_type& x);

  void
  vatexemption (const vatexemption_optional& x);

  void
  vatexemption (::std::unique_ptr< vatexemption_type > p);

  // statecode
  //
  typedef ::text8_type statecode_type;
  typedef ::xsd::cxx::tree::optional< statecode_type > statecode_optional;
  typedef ::xsd::cxx::tree::traits< statecode_type, wchar_t > statecode_traits;

  const statecode_optional&
  statecode () const;

  statecode_optional&
  statecode ();

  void
  statecode (const statecode_type& x);

  void
  statecode (const statecode_optional& x);

  void
  statecode (::std::unique_ptr< statecode_type > p);

  // statuscode
  //
  typedef ::text8_type statuscode_type;
  typedef ::xsd::cxx::tree::optional< statuscode_type > statuscode_optional;
  typedef ::xsd::cxx::tree::traits< statuscode_type, wchar_t > statuscode_traits;

  const statuscode_optional&
  statuscode () const;

  statuscode_optional&
  statuscode ();

  void
  statuscode (const statuscode_type& x);

  void
  statuscode (const statuscode_optional& x);

  void
  statuscode (::std::unique_ptr< statuscode_type > p);

  // groupcode
  //
  typedef ::text8_type groupcode_type;
  typedef ::xsd::cxx::tree::optional< groupcode_type > groupcode_optional;
  typedef ::xsd::cxx::tree::traits< groupcode_type, wchar_t > groupcode_traits;

  const groupcode_optional&
  groupcode () const;

  groupcode_optional&
  groupcode ();

  void
  groupcode (const groupcode_type& x);

  void
  groupcode (const groupcode_optional& x);

  void
  groupcode (::std::unique_ptr< groupcode_type > p);

  // business
  //
  typedef ::xml_schema::string business_type;
  typedef ::xsd::cxx::tree::optional< business_type > business_optional;
  typedef ::xsd::cxx::tree::traits< business_type, wchar_t > business_traits;

  const business_optional&
  business () const;

  business_optional&
  business ();

  void
  business (const business_type& x);

  void
  business (const business_optional& x);

  void
  business (::std::unique_ptr< business_type > p);

  // desc
  //
  typedef ::xml_schema::string desc_type;
  typedef ::xsd::cxx::tree::optional< desc_type > desc_optional;
  typedef ::xsd::cxx::tree::traits< desc_type, wchar_t > desc_traits;

  const desc_optional&
  desc () const;

  desc_optional&
  desc ();

  void
  desc (const desc_type& x);

  void
  desc (const desc_optional& x);

  void
  desc (::std::unique_ptr< desc_type > p);

  // note
  //
  typedef ::xml_schema::string note_type;
  typedef ::xsd::cxx::tree::optional< note_type > note_optional;
  typedef ::xsd::cxx::tree::traits< note_type, wchar_t > note_traits;

  const note_optional&
  note () const;

  note_optional&
  note ();

  void
  note (const note_type& x);

  void
  note (const note_optional& x);

  void
  note (::std::unique_ptr< note_type > p);

  // remark
  //
  typedef ::xml_schema::string remark_type;
  typedef ::xsd::cxx::tree::optional< remark_type > remark_optional;
  typedef ::xsd::cxx::tree::traits< remark_type, wchar_t > remark_traits;

  const remark_optional&
  remark () const;

  remark_optional&
  remark ();

  void
  remark (const remark_type& x);

  void
  remark (const remark_optional& x);

  void
  remark (::std::unique_ptr< remark_type > p);

  // Constructors.
  //
  bkm_contact (const externalkey_type&);

  bkm_contact (const bkm_contact& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  virtual bkm_contact*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  bkm_contact&
  operator= (const bkm_contact& x);

  virtual 
  ~bkm_contact ();

  // Implementation.
  //
  protected:
  id_optional id_;
  ::xsd::cxx::tree::one< externalkey_type > externalkey_;
  matchfield_optional matchfield_;
  controlcode_optional controlcode_;
  keyid_optional keyid_;
  taxid_optional taxid_;
  synonym_optional synonym_;
  name1_optional name1_;
  name2_optional name2_;
  name3_optional name3_;
  city_optional city_;
  zipcode_optional zipcode_;
  street_optional street_;
  extern1_optional extern1_;
  extern2_optional extern2_;
  extern3_optional extern3_;
  phone_optional phone_;
  phone2_optional phone2_;
  phone3_optional phone3_;
  fax_optional fax_;
  email_optional email_;
  homepage_optional homepage_;
  vatid_optional vatid_;
  vatexemption_optional vatexemption_;
  statecode_optional statecode_;
  statuscode_optional statuscode_;
  groupcode_optional groupcode_;
  business_optional business_;
  desc_optional desc_;
  note_optional note_;
  remark_optional remark_;
};

class bkm_counterpart: public ::xml_schema::type
{
  public:
  // id
  //
  typedef ::xml_schema::int_ id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  // externalkey
  //
  typedef ::externalkey_type externalkey_type;
  typedef ::xsd::cxx::tree::traits< externalkey_type, wchar_t > externalkey_traits;

  const externalkey_type&
  externalkey () const;

  externalkey_type&
  externalkey ();

  void
  externalkey (const externalkey_type& x);

  void
  externalkey (::std::unique_ptr< externalkey_type > p);

  // contactkey
  //
  typedef ::externalkey_type contactkey_type;
  typedef ::xsd::cxx::tree::traits< contactkey_type, wchar_t > contactkey_traits;

  const contactkey_type&
  contactkey () const;

  contactkey_type&
  contactkey ();

  void
  contactkey (const contactkey_type& x);

  void
  contactkey (::std::unique_ptr< contactkey_type > p);

  // matchfield
  //
  typedef ::matchfieldcounterpart_type matchfield_type;
  typedef ::xsd::cxx::tree::optional< matchfield_type > matchfield_optional;
  typedef ::xsd::cxx::tree::traits< matchfield_type, wchar_t > matchfield_traits;

  const matchfield_optional&
  matchfield () const;

  matchfield_optional&
  matchfield ();

  void
  matchfield (const matchfield_type& x);

  void
  matchfield (const matchfield_optional& x);

  void
  matchfield (::std::unique_ptr< matchfield_type > p);

  // controlcode
  //
  typedef ::text256_type controlcode_type;
  typedef ::xsd::cxx::tree::optional< controlcode_type > controlcode_optional;
  typedef ::xsd::cxx::tree::traits< controlcode_type, wchar_t > controlcode_traits;

  const controlcode_optional&
  controlcode () const;

  controlcode_optional&
  controlcode ();

  void
  controlcode (const controlcode_type& x);

  void
  controlcode (const controlcode_optional& x);

  void
  controlcode (::std::unique_ptr< controlcode_type > p);

  // lastname
  //
  typedef ::text64_type lastname_type;
  typedef ::xsd::cxx::tree::traits< lastname_type, wchar_t > lastname_traits;

  const lastname_type&
  lastname () const;

  lastname_type&
  lastname ();

  void
  lastname (const lastname_type& x);

  void
  lastname (::std::unique_ptr< lastname_type > p);

  // firstname
  //
  typedef ::text64_type firstname_type;
  typedef ::xsd::cxx::tree::optional< firstname_type > firstname_optional;
  typedef ::xsd::cxx::tree::traits< firstname_type, wchar_t > firstname_traits;

  const firstname_optional&
  firstname () const;

  firstname_optional&
  firstname ();

  void
  firstname (const firstname_type& x);

  void
  firstname (const firstname_optional& x);

  void
  firstname (::std::unique_ptr< firstname_type > p);

  // code
  //
  typedef ::text32_type code_type;
  typedef ::xsd::cxx::tree::optional< code_type > code_optional;
  typedef ::xsd::cxx::tree::traits< code_type, wchar_t > code_traits;

  const code_optional&
  code () const;

  code_optional&
  code ();

  void
  code (const code_type& x);

  void
  code (const code_optional& x);

  void
  code (::std::unique_ptr< code_type > p);

  // role
  //
  typedef ::text32_type role_type;
  typedef ::xsd::cxx::tree::optional< role_type > role_optional;
  typedef ::xsd::cxx::tree::traits< role_type, wchar_t > role_traits;

  const role_optional&
  role () const;

  role_optional&
  role ();

  void
  role (const role_type& x);

  void
  role (const role_optional& x);

  void
  role (::std::unique_ptr< role_type > p);

  // department
  //
  typedef ::text128_type department_type;
  typedef ::xsd::cxx::tree::optional< department_type > department_optional;
  typedef ::xsd::cxx::tree::traits< department_type, wchar_t > department_traits;

  const department_optional&
  department () const;

  department_optional&
  department ();

  void
  department (const department_type& x);

  void
  department (const department_optional& x);

  void
  department (::std::unique_ptr< department_type > p);

  // phone1
  //
  typedef ::text32_type phone1_type;
  typedef ::xsd::cxx::tree::optional< phone1_type > phone1_optional;
  typedef ::xsd::cxx::tree::traits< phone1_type, wchar_t > phone1_traits;

  const phone1_optional&
  phone1 () const;

  phone1_optional&
  phone1 ();

  void
  phone1 (const phone1_type& x);

  void
  phone1 (const phone1_optional& x);

  void
  phone1 (::std::unique_ptr< phone1_type > p);

  // phone2
  //
  typedef ::text32_type phone2_type;
  typedef ::xsd::cxx::tree::optional< phone2_type > phone2_optional;
  typedef ::xsd::cxx::tree::traits< phone2_type, wchar_t > phone2_traits;

  const phone2_optional&
  phone2 () const;

  phone2_optional&
  phone2 ();

  void
  phone2 (const phone2_type& x);

  void
  phone2 (const phone2_optional& x);

  void
  phone2 (::std::unique_ptr< phone2_type > p);

  // mobile
  //
  typedef ::text32_type mobile_type;
  typedef ::xsd::cxx::tree::optional< mobile_type > mobile_optional;
  typedef ::xsd::cxx::tree::traits< mobile_type, wchar_t > mobile_traits;

  const mobile_optional&
  mobile () const;

  mobile_optional&
  mobile ();

  void
  mobile (const mobile_type& x);

  void
  mobile (const mobile_optional& x);

  void
  mobile (::std::unique_ptr< mobile_type > p);

  // fax
  //
  typedef ::text32_type fax_type;
  typedef ::xsd::cxx::tree::optional< fax_type > fax_optional;
  typedef ::xsd::cxx::tree::traits< fax_type, wchar_t > fax_traits;

  const fax_optional&
  fax () const;

  fax_optional&
  fax ();

  void
  fax (const fax_type& x);

  void
  fax (const fax_optional& x);

  void
  fax (::std::unique_ptr< fax_type > p);

  // mail
  //
  typedef ::text64_type mail_type;
  typedef ::xsd::cxx::tree::optional< mail_type > mail_optional;
  typedef ::xsd::cxx::tree::traits< mail_type, wchar_t > mail_traits;

  const mail_optional&
  mail () const;

  mail_optional&
  mail ();

  void
  mail (const mail_type& x);

  void
  mail (const mail_optional& x);

  void
  mail (::std::unique_ptr< mail_type > p);

  // titlecode
  //
  typedef ::text16_type titlecode_type;
  typedef ::xsd::cxx::tree::optional< titlecode_type > titlecode_optional;
  typedef ::xsd::cxx::tree::traits< titlecode_type, wchar_t > titlecode_traits;

  const titlecode_optional&
  titlecode () const;

  titlecode_optional&
  titlecode ();

  void
  titlecode (const titlecode_type& x);

  void
  titlecode (const titlecode_optional& x);

  void
  titlecode (::std::unique_ptr< titlecode_type > p);

  // salutecode
  //
  typedef ::text16_type salutecode_type;
  typedef ::xsd::cxx::tree::optional< salutecode_type > salutecode_optional;
  typedef ::xsd::cxx::tree::traits< salutecode_type, wchar_t > salutecode_traits;

  const salutecode_optional&
  salutecode () const;

  salutecode_optional&
  salutecode ();

  void
  salutecode (const salutecode_type& x);

  void
  salutecode (const salutecode_optional& x);

  void
  salutecode (::std::unique_ptr< salutecode_type > p);

  // statuscode
  //
  typedef ::text8_type statuscode_type;
  typedef ::xsd::cxx::tree::optional< statuscode_type > statuscode_optional;
  typedef ::xsd::cxx::tree::traits< statuscode_type, wchar_t > statuscode_traits;

  const statuscode_optional&
  statuscode () const;

  statuscode_optional&
  statuscode ();

  void
  statuscode (const statuscode_type& x);

  void
  statuscode (const statuscode_optional& x);

  void
  statuscode (::std::unique_ptr< statuscode_type > p);

  // desc
  //
  typedef ::xml_schema::string desc_type;
  typedef ::xsd::cxx::tree::optional< desc_type > desc_optional;
  typedef ::xsd::cxx::tree::traits< desc_type, wchar_t > desc_traits;

  const desc_optional&
  desc () const;

  desc_optional&
  desc ();

  void
  desc (const desc_type& x);

  void
  desc (const desc_optional& x);

  void
  desc (::std::unique_ptr< desc_type > p);

  // note
  //
  typedef ::xml_schema::string note_type;
  typedef ::xsd::cxx::tree::optional< note_type > note_optional;
  typedef ::xsd::cxx::tree::traits< note_type, wchar_t > note_traits;

  const note_optional&
  note () const;

  note_optional&
  note ();

  void
  note (const note_type& x);

  void
  note (const note_optional& x);

  void
  note (::std::unique_ptr< note_type > p);

  // remark
  //
  typedef ::xml_schema::string remark_type;
  typedef ::xsd::cxx::tree::optional< remark_type > remark_optional;
  typedef ::xsd::cxx::tree::traits< remark_type, wchar_t > remark_traits;

  const remark_optional&
  remark () const;

  remark_optional&
  remark ();

  void
  remark (const remark_type& x);

  void
  remark (const remark_optional& x);

  void
  remark (::std::unique_ptr< remark_type > p);

  // Constructors.
  //
  bkm_counterpart (const externalkey_type&,
                   const contactkey_type&,
                   const lastname_type&);

  bkm_counterpart (const bkm_counterpart& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  virtual bkm_counterpart*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  bkm_counterpart&
  operator= (const bkm_counterpart& x);

  virtual 
  ~bkm_counterpart ();

  // Implementation.
  //
  protected:
  id_optional id_;
  ::xsd::cxx::tree::one< externalkey_type > externalkey_;
  ::xsd::cxx::tree::one< contactkey_type > contactkey_;
  matchfield_optional matchfield_;
  controlcode_optional controlcode_;
  ::xsd::cxx::tree::one< lastname_type > lastname_;
  firstname_optional firstname_;
  code_optional code_;
  role_optional role_;
  department_optional department_;
  phone1_optional phone1_;
  phone2_optional phone2_;
  mobile_optional mobile_;
  fax_optional fax_;
  mail_optional mail_;
  titlecode_optional titlecode_;
  salutecode_optional salutecode_;
  statuscode_optional statuscode_;
  desc_optional desc_;
  note_optional note_;
  remark_optional remark_;
};

class bkm_project: public ::xml_schema::type
{
  public:
  // bkm.part
  //
  typedef ::bkm_part bkm_part_type;
  typedef ::xsd::cxx::tree::sequence< bkm_part_type > bkm_part_sequence;
  typedef bkm_part_sequence::iterator bkm_part_iterator;
  typedef bkm_part_sequence::const_iterator bkm_part_const_iterator;
  typedef ::xsd::cxx::tree::traits< bkm_part_type, wchar_t > bkm_part_traits;

  const bkm_part_sequence&
  bkm_part () const;

  bkm_part_sequence&
  bkm_part ();

  void
  bkm_part (const bkm_part_sequence& s);

  // bkm.splititem
  //
  typedef ::bkm_splititem bkm_splititem_type;
  typedef ::xsd::cxx::tree::sequence< bkm_splititem_type > bkm_splititem_sequence;
  typedef bkm_splititem_sequence::iterator bkm_splititem_iterator;
  typedef bkm_splititem_sequence::const_iterator bkm_splititem_const_iterator;
  typedef ::xsd::cxx::tree::traits< bkm_splititem_type, wchar_t > bkm_splititem_traits;

  const bkm_splititem_sequence&
  bkm_splititem () const;

  bkm_splititem_sequence&
  bkm_splititem ();

  void
  bkm_splititem (const bkm_splititem_sequence& s);

  // bkm.placing
  //
  typedef ::bkm_placing bkm_placing_type;
  typedef ::xsd::cxx::tree::sequence< bkm_placing_type > bkm_placing_sequence;
  typedef bkm_placing_sequence::iterator bkm_placing_iterator;
  typedef bkm_placing_sequence::const_iterator bkm_placing_const_iterator;
  typedef ::xsd::cxx::tree::traits< bkm_placing_type, wchar_t > bkm_placing_traits;

  const bkm_placing_sequence&
  bkm_placing () const;

  bkm_placing_sequence&
  bkm_placing ();

  void
  bkm_placing (const bkm_placing_sequence& s);

  // bkm.revision
  //
  typedef ::bkm_revision bkm_revision_type;
  typedef ::xsd::cxx::tree::sequence< bkm_revision_type > bkm_revision_sequence;
  typedef bkm_revision_sequence::iterator bkm_revision_iterator;
  typedef bkm_revision_sequence::const_iterator bkm_revision_const_iterator;
  typedef ::xsd::cxx::tree::traits< bkm_revision_type, wchar_t > bkm_revision_traits;

  const bkm_revision_sequence&
  bkm_revision () const;

  bkm_revision_sequence&
  bkm_revision ();

  void
  bkm_revision (const bkm_revision_sequence& s);

  // bkm.order
  //
  typedef ::bkm_order bkm_order_type;
  typedef ::xsd::cxx::tree::sequence< bkm_order_type > bkm_order_sequence;
  typedef bkm_order_sequence::iterator bkm_order_iterator;
  typedef bkm_order_sequence::const_iterator bkm_order_const_iterator;
  typedef ::xsd::cxx::tree::traits< bkm_order_type, wchar_t > bkm_order_traits;

  const bkm_order_sequence&
  bkm_order () const;

  bkm_order_sequence&
  bkm_order ();

  void
  bkm_order (const bkm_order_sequence& s);

  // bkm.addition
  //
  typedef ::bkm_addition bkm_addition_type;
  typedef ::xsd::cxx::tree::sequence< bkm_addition_type > bkm_addition_sequence;
  typedef bkm_addition_sequence::iterator bkm_addition_iterator;
  typedef bkm_addition_sequence::const_iterator bkm_addition_const_iterator;
  typedef ::xsd::cxx::tree::traits< bkm_addition_type, wchar_t > bkm_addition_traits;

  const bkm_addition_sequence&
  bkm_addition () const;

  bkm_addition_sequence&
  bkm_addition ();

  void
  bkm_addition (const bkm_addition_sequence& s);

  // bkm.evident
  //
  typedef ::bkm_evident bkm_evident_type;
  typedef ::xsd::cxx::tree::sequence< bkm_evident_type > bkm_evident_sequence;
  typedef bkm_evident_sequence::iterator bkm_evident_iterator;
  typedef bkm_evident_sequence::const_iterator bkm_evident_const_iterator;
  typedef ::xsd::cxx::tree::traits< bkm_evident_type, wchar_t > bkm_evident_traits;

  const bkm_evident_sequence&
  bkm_evident () const;

  bkm_evident_sequence&
  bkm_evident ();

  void
  bkm_evident (const bkm_evident_sequence& s);

  // bkm.invoice
  //
  typedef ::bkm_invoice bkm_invoice_type;
  typedef ::xsd::cxx::tree::sequence< bkm_invoice_type > bkm_invoice_sequence;
  typedef bkm_invoice_sequence::iterator bkm_invoice_iterator;
  typedef bkm_invoice_sequence::const_iterator bkm_invoice_const_iterator;
  typedef ::xsd::cxx::tree::traits< bkm_invoice_type, wchar_t > bkm_invoice_traits;

  const bkm_invoice_sequence&
  bkm_invoice () const;

  bkm_invoice_sequence&
  bkm_invoice ();

  void
  bkm_invoice (const bkm_invoice_sequence& s);

  // bkm.payment
  //
  typedef ::bkm_payment bkm_payment_type;
  typedef ::xsd::cxx::tree::sequence< bkm_payment_type > bkm_payment_sequence;
  typedef bkm_payment_sequence::iterator bkm_payment_iterator;
  typedef bkm_payment_sequence::const_iterator bkm_payment_const_iterator;
  typedef ::xsd::cxx::tree::traits< bkm_payment_type, wchar_t > bkm_payment_traits;

  const bkm_payment_sequence&
  bkm_payment () const;

  bkm_payment_sequence&
  bkm_payment ();

  void
  bkm_payment (const bkm_payment_sequence& s);

  // bkm.backup
  //
  typedef ::bkm_backup bkm_backup_type;
  typedef ::xsd::cxx::tree::sequence< bkm_backup_type > bkm_backup_sequence;
  typedef bkm_backup_sequence::iterator bkm_backup_iterator;
  typedef bkm_backup_sequence::const_iterator bkm_backup_const_iterator;
  typedef ::xsd::cxx::tree::traits< bkm_backup_type, wchar_t > bkm_backup_traits;

  const bkm_backup_sequence&
  bkm_backup () const;

  bkm_backup_sequence&
  bkm_backup ();

  void
  bkm_backup (const bkm_backup_sequence& s);

  // ava.order
  //
  typedef ::ava_order ava_order_type;
  typedef ::xsd::cxx::tree::sequence< ava_order_type > ava_order_sequence;
  typedef ava_order_sequence::iterator ava_order_iterator;
  typedef ava_order_sequence::const_iterator ava_order_const_iterator;
  typedef ::xsd::cxx::tree::traits< ava_order_type, wchar_t > ava_order_traits;

  const ava_order_sequence&
  ava_order () const;

  ava_order_sequence&
  ava_order ();

  void
  ava_order (const ava_order_sequence& s);

  // ret.order
  //
  typedef ::ret_order ret_order_type;
  typedef ::xsd::cxx::tree::sequence< ret_order_type > ret_order_sequence;
  typedef ret_order_sequence::iterator ret_order_iterator;
  typedef ret_order_sequence::const_iterator ret_order_const_iterator;
  typedef ::xsd::cxx::tree::traits< ret_order_type, wchar_t > ret_order_traits;

  const ret_order_sequence&
  ret_order () const;

  ret_order_sequence&
  ret_order ();

  void
  ret_order (const ret_order_sequence& s);

  // ret.invoice
  //
  typedef ::ret_invoice ret_invoice_type;
  typedef ::xsd::cxx::tree::sequence< ret_invoice_type > ret_invoice_sequence;
  typedef ret_invoice_sequence::iterator ret_invoice_iterator;
  typedef ret_invoice_sequence::const_iterator ret_invoice_const_iterator;
  typedef ::xsd::cxx::tree::traits< ret_invoice_type, wchar_t > ret_invoice_traits;

  const ret_invoice_sequence&
  ret_invoice () const;

  ret_invoice_sequence&
  ret_invoice ();

  void
  ret_invoice (const ret_invoice_sequence& s);

  // ret.payment
  //
  typedef ::ret_payment ret_payment_type;
  typedef ::xsd::cxx::tree::sequence< ret_payment_type > ret_payment_sequence;
  typedef ret_payment_sequence::iterator ret_payment_iterator;
  typedef ret_payment_sequence::const_iterator ret_payment_const_iterator;
  typedef ::xsd::cxx::tree::traits< ret_payment_type, wchar_t > ret_payment_traits;

  const ret_payment_sequence&
  ret_payment () const;

  ret_payment_sequence&
  ret_payment ();

  void
  ret_payment (const ret_payment_sequence& s);

  // bkm.document
  //
  typedef ::bkm_document bkm_document_type;
  typedef ::xsd::cxx::tree::sequence< bkm_document_type > bkm_document_sequence;
  typedef bkm_document_sequence::iterator bkm_document_iterator;
  typedef bkm_document_sequence::const_iterator bkm_document_const_iterator;
  typedef ::xsd::cxx::tree::traits< bkm_document_type, wchar_t > bkm_document_traits;

  const bkm_document_sequence&
  bkm_document () const;

  bkm_document_sequence&
  bkm_document ();

  void
  bkm_document (const bkm_document_sequence& s);

  // bkm.keyvalue
  //
  typedef ::bkm_keyvalue bkm_keyvalue_type;
  typedef ::xsd::cxx::tree::sequence< bkm_keyvalue_type > bkm_keyvalue_sequence;
  typedef bkm_keyvalue_sequence::iterator bkm_keyvalue_iterator;
  typedef bkm_keyvalue_sequence::const_iterator bkm_keyvalue_const_iterator;
  typedef ::xsd::cxx::tree::traits< bkm_keyvalue_type, wchar_t > bkm_keyvalue_traits;

  const bkm_keyvalue_sequence&
  bkm_keyvalue () const;

  bkm_keyvalue_sequence&
  bkm_keyvalue ();

  void
  bkm_keyvalue (const bkm_keyvalue_sequence& s);

  // id
  //
  typedef ::xml_schema::int_ id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  // external
  //
  typedef ::text256_type external_type;
  typedef ::xsd::cxx::tree::optional< external_type > external_optional;
  typedef ::xsd::cxx::tree::traits< external_type, wchar_t > external_traits;

  const external_optional&
  external () const;

  external_optional&
  external ();

  void
  external (const external_type& x);

  void
  external (const external_optional& x);

  void
  external (::std::unique_ptr< external_type > p);

  // externalkey
  //
  typedef ::externalkey_type externalkey_type;
  typedef ::xsd::cxx::tree::traits< externalkey_type, wchar_t > externalkey_traits;

  const externalkey_type&
  externalkey () const;

  externalkey_type&
  externalkey ();

  void
  externalkey (const externalkey_type& x);

  void
  externalkey (::std::unique_ptr< externalkey_type > p);

  // matchfield
  //
  typedef ::matchfieldproject_type matchfield_type;
  typedef ::xsd::cxx::tree::optional< matchfield_type > matchfield_optional;
  typedef ::xsd::cxx::tree::traits< matchfield_type, wchar_t > matchfield_traits;

  const matchfield_optional&
  matchfield () const;

  matchfield_optional&
  matchfield ();

  void
  matchfield (const matchfield_type& x);

  void
  matchfield (const matchfield_optional& x);

  void
  matchfield (::std::unique_ptr< matchfield_type > p);

  // controlcode
  //
  typedef ::text256_type controlcode_type;
  typedef ::xsd::cxx::tree::optional< controlcode_type > controlcode_optional;
  typedef ::xsd::cxx::tree::traits< controlcode_type, wchar_t > controlcode_traits;

  const controlcode_optional&
  controlcode () const;

  controlcode_optional&
  controlcode ();

  void
  controlcode (const controlcode_type& x);

  void
  controlcode (const controlcode_optional& x);

  void
  controlcode (::std::unique_ptr< controlcode_type > p);

  // managerkey
  //
  typedef ::externalkey_type managerkey_type;
  typedef ::xsd::cxx::tree::optional< managerkey_type > managerkey_optional;
  typedef ::xsd::cxx::tree::traits< managerkey_type, wchar_t > managerkey_traits;

  const managerkey_optional&
  managerkey () const;

  managerkey_optional&
  managerkey ();

  void
  managerkey (const managerkey_type& x);

  void
  managerkey (const managerkey_optional& x);

  void
  managerkey (::std::unique_ptr< managerkey_type > p);

  // code
  //
  typedef ::text16_type code_type;
  typedef ::xsd::cxx::tree::optional< code_type > code_optional;
  typedef ::xsd::cxx::tree::traits< code_type, wchar_t > code_traits;

  const code_optional&
  code () const;

  code_optional&
  code ();

  void
  code (const code_type& x);

  void
  code (const code_optional& x);

  void
  code (::std::unique_ptr< code_type > p);

  // part
  //
  typedef ::text64_type part_type;
  typedef ::xsd::cxx::tree::optional< part_type > part_optional;
  typedef ::xsd::cxx::tree::traits< part_type, wchar_t > part_traits;

  const part_optional&
  part () const;

  part_optional&
  part ();

  void
  part (const part_type& x);

  void
  part (const part_optional& x);

  void
  part (::std::unique_ptr< part_type > p);

  // number
  //
  typedef ::text32_type number_type;
  typedef ::xsd::cxx::tree::optional< number_type > number_optional;
  typedef ::xsd::cxx::tree::traits< number_type, wchar_t > number_traits;

  const number_optional&
  number () const;

  number_optional&
  number ();

  void
  number (const number_type& x);

  void
  number (const number_optional& x);

  void
  number (::std::unique_ptr< number_type > p);

  // projectstart
  //
  typedef ::xml_schema::date projectstart_type;
  typedef ::xsd::cxx::tree::optional< projectstart_type > projectstart_optional;
  typedef ::xsd::cxx::tree::traits< projectstart_type, wchar_t > projectstart_traits;

  const projectstart_optional&
  projectstart () const;

  projectstart_optional&
  projectstart ();

  void
  projectstart (const projectstart_type& x);

  void
  projectstart (const projectstart_optional& x);

  void
  projectstart (::std::unique_ptr< projectstart_type > p);

  // projectend
  //
  typedef ::xml_schema::date projectend_type;
  typedef ::xsd::cxx::tree::optional< projectend_type > projectend_optional;
  typedef ::xsd::cxx::tree::traits< projectend_type, wchar_t > projectend_traits;

  const projectend_optional&
  projectend () const;

  projectend_optional&
  projectend ();

  void
  projectend (const projectend_type& x);

  void
  projectend (const projectend_optional& x);

  void
  projectend (::std::unique_ptr< projectend_type > p);

  // currency
  //
  typedef ::text16_type currency_type;
  typedef ::xsd::cxx::tree::optional< currency_type > currency_optional;
  typedef ::xsd::cxx::tree::traits< currency_type, wchar_t > currency_traits;

  const currency_optional&
  currency () const;

  currency_optional&
  currency ();

  void
  currency (const currency_type& x);

  void
  currency (const currency_optional& x);

  void
  currency (::std::unique_ptr< currency_type > p);

  // currencykey
  //
  typedef ::externalkey_type currencykey_type;
  typedef ::xsd::cxx::tree::optional< currencykey_type > currencykey_optional;
  typedef ::xsd::cxx::tree::traits< currencykey_type, wchar_t > currencykey_traits;

  const currencykey_optional&
  currencykey () const;

  currencykey_optional&
  currencykey ();

  void
  currencykey (const currencykey_type& x);

  void
  currencykey (const currencykey_optional& x);

  void
  currencykey (::std::unique_ptr< currencykey_type > p);

  // orderercode
  //
  typedef ::text64_type orderercode_type;
  typedef ::xsd::cxx::tree::optional< orderercode_type > orderercode_optional;
  typedef ::xsd::cxx::tree::traits< orderercode_type, wchar_t > orderercode_traits;

  const orderercode_optional&
  orderercode () const;

  orderercode_optional&
  orderercode ();

  void
  orderercode (const orderercode_type& x);

  void
  orderercode (const orderercode_optional& x);

  void
  orderercode (::std::unique_ptr< orderercode_type > p);

  // ordererkey
  //
  typedef ::externalkey_type ordererkey_type;
  typedef ::xsd::cxx::tree::optional< ordererkey_type > ordererkey_optional;
  typedef ::xsd::cxx::tree::traits< ordererkey_type, wchar_t > ordererkey_traits;

  const ordererkey_optional&
  ordererkey () const;

  ordererkey_optional&
  ordererkey ();

  void
  ordererkey (const ordererkey_type& x);

  void
  ordererkey (const ordererkey_optional& x);

  void
  ordererkey (::std::unique_ptr< ordererkey_type > p);

  // ordererkeyid
  //
  typedef ::text16_type ordererkeyid_type;
  typedef ::xsd::cxx::tree::optional< ordererkeyid_type > ordererkeyid_optional;
  typedef ::xsd::cxx::tree::traits< ordererkeyid_type, wchar_t > ordererkeyid_traits;

  const ordererkeyid_optional&
  ordererkeyid () const;

  ordererkeyid_optional&
  ordererkeyid ();

  void
  ordererkeyid (const ordererkeyid_type& x);

  void
  ordererkeyid (const ordererkeyid_optional& x);

  void
  ordererkeyid (::std::unique_ptr< ordererkeyid_type > p);

  // city
  //
  typedef ::text64_type city_type;
  typedef ::xsd::cxx::tree::optional< city_type > city_optional;
  typedef ::xsd::cxx::tree::traits< city_type, wchar_t > city_traits;

  const city_optional&
  city () const;

  city_optional&
  city ();

  void
  city (const city_type& x);

  void
  city (const city_optional& x);

  void
  city (::std::unique_ptr< city_type > p);

  // zipcode
  //
  typedef ::text16_type zipcode_type;
  typedef ::xsd::cxx::tree::optional< zipcode_type > zipcode_optional;
  typedef ::xsd::cxx::tree::traits< zipcode_type, wchar_t > zipcode_traits;

  const zipcode_optional&
  zipcode () const;

  zipcode_optional&
  zipcode ();

  void
  zipcode (const zipcode_type& x);

  void
  zipcode (const zipcode_optional& x);

  void
  zipcode (::std::unique_ptr< zipcode_type > p);

  // street
  //
  typedef ::text64_type street_type;
  typedef ::xsd::cxx::tree::optional< street_type > street_optional;
  typedef ::xsd::cxx::tree::traits< street_type, wchar_t > street_traits;

  const street_optional&
  street () const;

  street_optional&
  street ();

  void
  street (const street_type& x);

  void
  street (const street_optional& x);

  void
  street (::std::unique_ptr< street_type > p);

  // statecode
  //
  typedef ::text8_type statecode_type;
  typedef ::xsd::cxx::tree::optional< statecode_type > statecode_optional;
  typedef ::xsd::cxx::tree::traits< statecode_type, wchar_t > statecode_traits;

  const statecode_optional&
  statecode () const;

  statecode_optional&
  statecode ();

  void
  statecode (const statecode_type& x);

  void
  statecode (const statecode_optional& x);

  void
  statecode (::std::unique_ptr< statecode_type > p);

  // statuscode
  //
  typedef ::text8_type statuscode_type;
  typedef ::xsd::cxx::tree::optional< statuscode_type > statuscode_optional;
  typedef ::xsd::cxx::tree::traits< statuscode_type, wchar_t > statuscode_traits;

  const statuscode_optional&
  statuscode () const;

  statuscode_optional&
  statuscode ();

  void
  statuscode (const statuscode_type& x);

  void
  statuscode (const statuscode_optional& x);

  void
  statuscode (::std::unique_ptr< statuscode_type > p);

  // groupcode
  //
  typedef ::text8_type groupcode_type;
  typedef ::xsd::cxx::tree::optional< groupcode_type > groupcode_optional;
  typedef ::xsd::cxx::tree::traits< groupcode_type, wchar_t > groupcode_traits;

  const groupcode_optional&
  groupcode () const;

  groupcode_optional&
  groupcode ();

  void
  groupcode (const groupcode_type& x);

  void
  groupcode (const groupcode_optional& x);

  void
  groupcode (::std::unique_ptr< groupcode_type > p);

  // parishcode
  //
  typedef ::text8_type parishcode_type;
  typedef ::xsd::cxx::tree::optional< parishcode_type > parishcode_optional;
  typedef ::xsd::cxx::tree::traits< parishcode_type, wchar_t > parishcode_traits;

  const parishcode_optional&
  parishcode () const;

  parishcode_optional&
  parishcode ();

  void
  parishcode (const parishcode_type& x);

  void
  parishcode (const parishcode_optional& x);

  void
  parishcode (::std::unique_ptr< parishcode_type > p);

  // parishcode1
  //
  typedef ::text8_type parishcode1_type;
  typedef ::xsd::cxx::tree::optional< parishcode1_type > parishcode1_optional;
  typedef ::xsd::cxx::tree::traits< parishcode1_type, wchar_t > parishcode1_traits;

  const parishcode1_optional&
  parishcode1 () const;

  parishcode1_optional&
  parishcode1 ();

  void
  parishcode1 (const parishcode1_type& x);

  void
  parishcode1 (const parishcode1_optional& x);

  void
  parishcode1 (::std::unique_ptr< parishcode1_type > p);

  // parishcode2
  //
  typedef ::text8_type parishcode2_type;
  typedef ::xsd::cxx::tree::optional< parishcode2_type > parishcode2_optional;
  typedef ::xsd::cxx::tree::traits< parishcode2_type, wchar_t > parishcode2_traits;

  const parishcode2_optional&
  parishcode2 () const;

  parishcode2_optional&
  parishcode2 ();

  void
  parishcode2 (const parishcode2_type& x);

  void
  parishcode2 (const parishcode2_optional& x);

  void
  parishcode2 (::std::unique_ptr< parishcode2_type > p);

  // parishcode3
  //
  typedef ::text8_type parishcode3_type;
  typedef ::xsd::cxx::tree::optional< parishcode3_type > parishcode3_optional;
  typedef ::xsd::cxx::tree::traits< parishcode3_type, wchar_t > parishcode3_traits;

  const parishcode3_optional&
  parishcode3 () const;

  parishcode3_optional&
  parishcode3 ();

  void
  parishcode3 (const parishcode3_type& x);

  void
  parishcode3 (const parishcode3_optional& x);

  void
  parishcode3 (::std::unique_ptr< parishcode3_type > p);

  // parishcode4
  //
  typedef ::text8_type parishcode4_type;
  typedef ::xsd::cxx::tree::optional< parishcode4_type > parishcode4_optional;
  typedef ::xsd::cxx::tree::traits< parishcode4_type, wchar_t > parishcode4_traits;

  const parishcode4_optional&
  parishcode4 () const;

  parishcode4_optional&
  parishcode4 ();

  void
  parishcode4 (const parishcode4_type& x);

  void
  parishcode4 (const parishcode4_optional& x);

  void
  parishcode4 (::std::unique_ptr< parishcode4_type > p);

  // returnreal
  //
  typedef ::decimal_type returnreal_type;
  typedef ::xsd::cxx::tree::optional< returnreal_type > returnreal_optional;
  typedef ::xsd::cxx::tree::traits< returnreal_type, wchar_t > returnreal_traits;

  const returnreal_optional&
  returnreal () const;

  returnreal_optional&
  returnreal ();

  void
  returnreal (const returnreal_type& x);

  void
  returnreal (const returnreal_optional& x);

  void
  returnreal (::std::unique_ptr< returnreal_type > p);

  // returnsold
  //
  typedef ::decimal_type returnsold_type;
  typedef ::xsd::cxx::tree::optional< returnsold_type > returnsold_optional;
  typedef ::xsd::cxx::tree::traits< returnsold_type, wchar_t > returnsold_traits;

  const returnsold_optional&
  returnsold () const;

  returnsold_optional&
  returnsold ();

  void
  returnsold (const returnsold_type& x);

  void
  returnsold (const returnsold_optional& x);

  void
  returnsold (::std::unique_ptr< returnsold_type > p);

  // vatprz
  //
  typedef ::percent_type vatprz_type;
  typedef ::xsd::cxx::tree::optional< vatprz_type > vatprz_optional;
  typedef ::xsd::cxx::tree::traits< vatprz_type, wchar_t > vatprz_traits;

  const vatprz_optional&
  vatprz () const;

  vatprz_optional&
  vatprz ();

  void
  vatprz (const vatprz_type& x);

  void
  vatprz (const vatprz_optional& x);

  void
  vatprz (::std::unique_ptr< vatprz_type > p);

  // extern1
  //
  typedef ::text128_type extern1_type;
  typedef ::xsd::cxx::tree::optional< extern1_type > extern1_optional;
  typedef ::xsd::cxx::tree::traits< extern1_type, wchar_t > extern1_traits;

  const extern1_optional&
  extern1 () const;

  extern1_optional&
  extern1 ();

  void
  extern1 (const extern1_type& x);

  void
  extern1 (const extern1_optional& x);

  void
  extern1 (::std::unique_ptr< extern1_type > p);

  // extern2
  //
  typedef ::text128_type extern2_type;
  typedef ::xsd::cxx::tree::optional< extern2_type > extern2_optional;
  typedef ::xsd::cxx::tree::traits< extern2_type, wchar_t > extern2_traits;

  const extern2_optional&
  extern2 () const;

  extern2_optional&
  extern2 ();

  void
  extern2 (const extern2_type& x);

  void
  extern2 (const extern2_optional& x);

  void
  extern2 (::std::unique_ptr< extern2_type > p);

  // extern3
  //
  typedef ::text128_type extern3_type;
  typedef ::xsd::cxx::tree::optional< extern3_type > extern3_optional;
  typedef ::xsd::cxx::tree::traits< extern3_type, wchar_t > extern3_traits;

  const extern3_optional&
  extern3 () const;

  extern3_optional&
  extern3 ();

  void
  extern3 (const extern3_type& x);

  void
  extern3 (const extern3_optional& x);

  void
  extern3 (::std::unique_ptr< extern3_type > p);

  // userfield1
  //
  typedef ::text256_type userfield1_type;
  typedef ::xsd::cxx::tree::optional< userfield1_type > userfield1_optional;
  typedef ::xsd::cxx::tree::traits< userfield1_type, wchar_t > userfield1_traits;

  const userfield1_optional&
  userfield1 () const;

  userfield1_optional&
  userfield1 ();

  void
  userfield1 (const userfield1_type& x);

  void
  userfield1 (const userfield1_optional& x);

  void
  userfield1 (::std::unique_ptr< userfield1_type > p);

  // userfield2
  //
  typedef ::text256_type userfield2_type;
  typedef ::xsd::cxx::tree::optional< userfield2_type > userfield2_optional;
  typedef ::xsd::cxx::tree::traits< userfield2_type, wchar_t > userfield2_traits;

  const userfield2_optional&
  userfield2 () const;

  userfield2_optional&
  userfield2 ();

  void
  userfield2 (const userfield2_type& x);

  void
  userfield2 (const userfield2_optional& x);

  void
  userfield2 (::std::unique_ptr< userfield2_type > p);

  // userfield3
  //
  typedef ::text256_type userfield3_type;
  typedef ::xsd::cxx::tree::optional< userfield3_type > userfield3_optional;
  typedef ::xsd::cxx::tree::traits< userfield3_type, wchar_t > userfield3_traits;

  const userfield3_optional&
  userfield3 () const;

  userfield3_optional&
  userfield3 ();

  void
  userfield3 (const userfield3_type& x);

  void
  userfield3 (const userfield3_optional& x);

  void
  userfield3 (::std::unique_ptr< userfield3_type > p);

  // user
  //
  typedef ::text128_type user_type;
  typedef ::xsd::cxx::tree::optional< user_type > user_optional;
  typedef ::xsd::cxx::tree::traits< user_type, wchar_t > user_traits;

  const user_optional&
  user () const;

  user_optional&
  user ();

  void
  user (const user_type& x);

  void
  user (const user_optional& x);

  void
  user (::std::unique_ptr< user_type > p);

  // desc
  //
  typedef ::xml_schema::string desc_type;
  typedef ::xsd::cxx::tree::optional< desc_type > desc_optional;
  typedef ::xsd::cxx::tree::traits< desc_type, wchar_t > desc_traits;

  const desc_optional&
  desc () const;

  desc_optional&
  desc ();

  void
  desc (const desc_type& x);

  void
  desc (const desc_optional& x);

  void
  desc (::std::unique_ptr< desc_type > p);

  // note
  //
  typedef ::xml_schema::string note_type;
  typedef ::xsd::cxx::tree::optional< note_type > note_optional;
  typedef ::xsd::cxx::tree::traits< note_type, wchar_t > note_traits;

  const note_optional&
  note () const;

  note_optional&
  note ();

  void
  note (const note_type& x);

  void
  note (const note_optional& x);

  void
  note (::std::unique_ptr< note_type > p);

  // remark
  //
  typedef ::xml_schema::string remark_type;
  typedef ::xsd::cxx::tree::optional< remark_type > remark_optional;
  typedef ::xsd::cxx::tree::traits< remark_type, wchar_t > remark_traits;

  const remark_optional&
  remark () const;

  remark_optional&
  remark ();

  void
  remark (const remark_type& x);

  void
  remark (const remark_optional& x);

  void
  remark (::std::unique_ptr< remark_type > p);

  // Constructors.
  //
  bkm_project (const externalkey_type&);

  bkm_project (const bkm_project& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  virtual bkm_project*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  bkm_project&
  operator= (const bkm_project& x);

  virtual 
  ~bkm_project ();

  // Implementation.
  //
  protected:
  bkm_part_sequence bkm_part_;
  bkm_splititem_sequence bkm_splititem_;
  bkm_placing_sequence bkm_placing_;
  bkm_revision_sequence bkm_revision_;
  bkm_order_sequence bkm_order_;
  bkm_addition_sequence bkm_addition_;
  bkm_evident_sequence bkm_evident_;
  bkm_invoice_sequence bkm_invoice_;
  bkm_payment_sequence bkm_payment_;
  bkm_backup_sequence bkm_backup_;
  ava_order_sequence ava_order_;
  ret_order_sequence ret_order_;
  ret_invoice_sequence ret_invoice_;
  ret_payment_sequence ret_payment_;
  bkm_document_sequence bkm_document_;
  bkm_keyvalue_sequence bkm_keyvalue_;
  id_optional id_;
  external_optional external_;
  ::xsd::cxx::tree::one< externalkey_type > externalkey_;
  matchfield_optional matchfield_;
  controlcode_optional controlcode_;
  managerkey_optional managerkey_;
  code_optional code_;
  part_optional part_;
  number_optional number_;
  projectstart_optional projectstart_;
  projectend_optional projectend_;
  currency_optional currency_;
  currencykey_optional currencykey_;
  orderercode_optional orderercode_;
  ordererkey_optional ordererkey_;
  ordererkeyid_optional ordererkeyid_;
  city_optional city_;
  zipcode_optional zipcode_;
  street_optional street_;
  statecode_optional statecode_;
  statuscode_optional statuscode_;
  groupcode_optional groupcode_;
  parishcode_optional parishcode_;
  parishcode1_optional parishcode1_;
  parishcode2_optional parishcode2_;
  parishcode3_optional parishcode3_;
  parishcode4_optional parishcode4_;
  returnreal_optional returnreal_;
  returnsold_optional returnsold_;
  vatprz_optional vatprz_;
  extern1_optional extern1_;
  extern2_optional extern2_;
  extern3_optional extern3_;
  userfield1_optional userfield1_;
  userfield2_optional userfield2_;
  userfield3_optional userfield3_;
  user_optional user_;
  desc_optional desc_;
  note_optional note_;
  remark_optional remark_;
};

class bkm_part: public ::xml_schema::type
{
  public:
  // id
  //
  typedef ::xml_schema::int_ id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  // externalkey
  //
  typedef ::externalkey_type externalkey_type;
  typedef ::xsd::cxx::tree::traits< externalkey_type, wchar_t > externalkey_traits;

  const externalkey_type&
  externalkey () const;

  externalkey_type&
  externalkey ();

  void
  externalkey (const externalkey_type& x);

  void
  externalkey (::std::unique_ptr< externalkey_type > p);

  // projectkey
  //
  typedef ::externalkey_type projectkey_type;
  typedef ::xsd::cxx::tree::optional< projectkey_type > projectkey_optional;
  typedef ::xsd::cxx::tree::traits< projectkey_type, wchar_t > projectkey_traits;

  const projectkey_optional&
  projectkey () const;

  projectkey_optional&
  projectkey ();

  void
  projectkey (const projectkey_type& x);

  void
  projectkey (const projectkey_optional& x);

  void
  projectkey (::std::unique_ptr< projectkey_type > p);

  // parishkey1
  //
  typedef ::externalkey_type parishkey1_type;
  typedef ::xsd::cxx::tree::optional< parishkey1_type > parishkey1_optional;
  typedef ::xsd::cxx::tree::traits< parishkey1_type, wchar_t > parishkey1_traits;

  const parishkey1_optional&
  parishkey1 () const;

  parishkey1_optional&
  parishkey1 ();

  void
  parishkey1 (const parishkey1_type& x);

  void
  parishkey1 (const parishkey1_optional& x);

  void
  parishkey1 (::std::unique_ptr< parishkey1_type > p);

  // parishkey2
  //
  typedef ::externalkey_type parishkey2_type;
  typedef ::xsd::cxx::tree::optional< parishkey2_type > parishkey2_optional;
  typedef ::xsd::cxx::tree::traits< parishkey2_type, wchar_t > parishkey2_traits;

  const parishkey2_optional&
  parishkey2 () const;

  parishkey2_optional&
  parishkey2 ();

  void
  parishkey2 (const parishkey2_type& x);

  void
  parishkey2 (const parishkey2_optional& x);

  void
  parishkey2 (::std::unique_ptr< parishkey2_type > p);

  // returnreal
  //
  typedef ::decimal_type returnreal_type;
  typedef ::xsd::cxx::tree::optional< returnreal_type > returnreal_optional;
  typedef ::xsd::cxx::tree::traits< returnreal_type, wchar_t > returnreal_traits;

  const returnreal_optional&
  returnreal () const;

  returnreal_optional&
  returnreal ();

  void
  returnreal (const returnreal_type& x);

  void
  returnreal (const returnreal_optional& x);

  void
  returnreal (::std::unique_ptr< returnreal_type > p);

  // returnsold
  //
  typedef ::decimal_type returnsold_type;
  typedef ::xsd::cxx::tree::optional< returnsold_type > returnsold_optional;
  typedef ::xsd::cxx::tree::traits< returnsold_type, wchar_t > returnsold_traits;

  const returnsold_optional&
  returnsold () const;

  returnsold_optional&
  returnsold ();

  void
  returnsold (const returnsold_type& x);

  void
  returnsold (const returnsold_optional& x);

  void
  returnsold (::std::unique_ptr< returnsold_type > p);

  // matchfield
  //
  typedef ::matchfieldpart_type matchfield_type;
  typedef ::xsd::cxx::tree::optional< matchfield_type > matchfield_optional;
  typedef ::xsd::cxx::tree::traits< matchfield_type, wchar_t > matchfield_traits;

  const matchfield_optional&
  matchfield () const;

  matchfield_optional&
  matchfield ();

  void
  matchfield (const matchfield_type& x);

  void
  matchfield (const matchfield_optional& x);

  void
  matchfield (::std::unique_ptr< matchfield_type > p);

  // controlcode
  //
  typedef ::text256_type controlcode_type;
  typedef ::xsd::cxx::tree::optional< controlcode_type > controlcode_optional;
  typedef ::xsd::cxx::tree::traits< controlcode_type, wchar_t > controlcode_traits;

  const controlcode_optional&
  controlcode () const;

  controlcode_optional&
  controlcode ();

  void
  controlcode (const controlcode_type& x);

  void
  controlcode (const controlcode_optional& x);

  void
  controlcode (::std::unique_ptr< controlcode_type > p);

  // code
  //
  typedef ::text16_type code_type;
  typedef ::xsd::cxx::tree::optional< code_type > code_optional;
  typedef ::xsd::cxx::tree::traits< code_type, wchar_t > code_traits;

  const code_optional&
  code () const;

  code_optional&
  code ();

  void
  code (const code_type& x);

  void
  code (const code_optional& x);

  void
  code (::std::unique_ptr< code_type > p);

  // part
  //
  typedef ::text64_type part_type;
  typedef ::xsd::cxx::tree::optional< part_type > part_optional;
  typedef ::xsd::cxx::tree::traits< part_type, wchar_t > part_traits;

  const part_optional&
  part () const;

  part_optional&
  part ();

  void
  part (const part_type& x);

  void
  part (const part_optional& x);

  void
  part (::std::unique_ptr< part_type > p);

  // partstart
  //
  typedef ::xml_schema::date partstart_type;
  typedef ::xsd::cxx::tree::optional< partstart_type > partstart_optional;
  typedef ::xsd::cxx::tree::traits< partstart_type, wchar_t > partstart_traits;

  const partstart_optional&
  partstart () const;

  partstart_optional&
  partstart ();

  void
  partstart (const partstart_type& x);

  void
  partstart (const partstart_optional& x);

  void
  partstart (::std::unique_ptr< partstart_type > p);

  // partend
  //
  typedef ::xml_schema::date partend_type;
  typedef ::xsd::cxx::tree::optional< partend_type > partend_optional;
  typedef ::xsd::cxx::tree::traits< partend_type, wchar_t > partend_traits;

  const partend_optional&
  partend () const;

  partend_optional&
  partend ();

  void
  partend (const partend_type& x);

  void
  partend (const partend_optional& x);

  void
  partend (::std::unique_ptr< partend_type > p);

  // currency
  //
  typedef ::text16_type currency_type;
  typedef ::xsd::cxx::tree::optional< currency_type > currency_optional;
  typedef ::xsd::cxx::tree::traits< currency_type, wchar_t > currency_traits;

  const currency_optional&
  currency () const;

  currency_optional&
  currency ();

  void
  currency (const currency_type& x);

  void
  currency (const currency_optional& x);

  void
  currency (::std::unique_ptr< currency_type > p);

  // number
  //
  typedef ::text32_type number_type;
  typedef ::xsd::cxx::tree::optional< number_type > number_optional;
  typedef ::xsd::cxx::tree::traits< number_type, wchar_t > number_traits;

  const number_optional&
  number () const;

  number_optional&
  number ();

  void
  number (const number_type& x);

  void
  number (const number_optional& x);

  void
  number (::std::unique_ptr< number_type > p);

  // city
  //
  typedef ::text64_type city_type;
  typedef ::xsd::cxx::tree::optional< city_type > city_optional;
  typedef ::xsd::cxx::tree::traits< city_type, wchar_t > city_traits;

  const city_optional&
  city () const;

  city_optional&
  city ();

  void
  city (const city_type& x);

  void
  city (const city_optional& x);

  void
  city (::std::unique_ptr< city_type > p);

  // zipcode
  //
  typedef ::text16_type zipcode_type;
  typedef ::xsd::cxx::tree::optional< zipcode_type > zipcode_optional;
  typedef ::xsd::cxx::tree::traits< zipcode_type, wchar_t > zipcode_traits;

  const zipcode_optional&
  zipcode () const;

  zipcode_optional&
  zipcode ();

  void
  zipcode (const zipcode_type& x);

  void
  zipcode (const zipcode_optional& x);

  void
  zipcode (::std::unique_ptr< zipcode_type > p);

  // street
  //
  typedef ::text64_type street_type;
  typedef ::xsd::cxx::tree::optional< street_type > street_optional;
  typedef ::xsd::cxx::tree::traits< street_type, wchar_t > street_traits;

  const street_optional&
  street () const;

  street_optional&
  street ();

  void
  street (const street_type& x);

  void
  street (const street_optional& x);

  void
  street (::std::unique_ptr< street_type > p);

  // statecode
  //
  typedef ::text8_type statecode_type;
  typedef ::xsd::cxx::tree::optional< statecode_type > statecode_optional;
  typedef ::xsd::cxx::tree::traits< statecode_type, wchar_t > statecode_traits;

  const statecode_optional&
  statecode () const;

  statecode_optional&
  statecode ();

  void
  statecode (const statecode_type& x);

  void
  statecode (const statecode_optional& x);

  void
  statecode (::std::unique_ptr< statecode_type > p);

  // deliverycode
  //
  typedef ::text8_type deliverycode_type;
  typedef ::xsd::cxx::tree::optional< deliverycode_type > deliverycode_optional;
  typedef ::xsd::cxx::tree::traits< deliverycode_type, wchar_t > deliverycode_traits;

  const deliverycode_optional&
  deliverycode () const;

  deliverycode_optional&
  deliverycode ();

  void
  deliverycode (const deliverycode_type& x);

  void
  deliverycode (const deliverycode_optional& x);

  void
  deliverycode (::std::unique_ptr< deliverycode_type > p);

  // typecode
  //
  typedef ::text8_type typecode_type;
  typedef ::xsd::cxx::tree::optional< typecode_type > typecode_optional;
  typedef ::xsd::cxx::tree::traits< typecode_type, wchar_t > typecode_traits;

  const typecode_optional&
  typecode () const;

  typecode_optional&
  typecode ();

  void
  typecode (const typecode_type& x);

  void
  typecode (const typecode_optional& x);

  void
  typecode (::std::unique_ptr< typecode_type > p);

  // statuscode
  //
  typedef ::text8_type statuscode_type;
  typedef ::xsd::cxx::tree::optional< statuscode_type > statuscode_optional;
  typedef ::xsd::cxx::tree::traits< statuscode_type, wchar_t > statuscode_traits;

  const statuscode_optional&
  statuscode () const;

  statuscode_optional&
  statuscode ();

  void
  statuscode (const statuscode_type& x);

  void
  statuscode (const statuscode_optional& x);

  void
  statuscode (::std::unique_ptr< statuscode_type > p);

  // groupcode
  //
  typedef ::text8_type groupcode_type;
  typedef ::xsd::cxx::tree::optional< groupcode_type > groupcode_optional;
  typedef ::xsd::cxx::tree::traits< groupcode_type, wchar_t > groupcode_traits;

  const groupcode_optional&
  groupcode () const;

  groupcode_optional&
  groupcode ();

  void
  groupcode (const groupcode_type& x);

  void
  groupcode (const groupcode_optional& x);

  void
  groupcode (::std::unique_ptr< groupcode_type > p);

  // vatprz
  //
  typedef ::percent_type vatprz_type;
  typedef ::xsd::cxx::tree::optional< vatprz_type > vatprz_optional;
  typedef ::xsd::cxx::tree::traits< vatprz_type, wchar_t > vatprz_traits;

  const vatprz_optional&
  vatprz () const;

  vatprz_optional&
  vatprz ();

  void
  vatprz (const vatprz_type& x);

  void
  vatprz (const vatprz_optional& x);

  void
  vatprz (::std::unique_ptr< vatprz_type > p);

  // extern1
  //
  typedef ::text128_type extern1_type;
  typedef ::xsd::cxx::tree::optional< extern1_type > extern1_optional;
  typedef ::xsd::cxx::tree::traits< extern1_type, wchar_t > extern1_traits;

  const extern1_optional&
  extern1 () const;

  extern1_optional&
  extern1 ();

  void
  extern1 (const extern1_type& x);

  void
  extern1 (const extern1_optional& x);

  void
  extern1 (::std::unique_ptr< extern1_type > p);

  // extern2
  //
  typedef ::text128_type extern2_type;
  typedef ::xsd::cxx::tree::optional< extern2_type > extern2_optional;
  typedef ::xsd::cxx::tree::traits< extern2_type, wchar_t > extern2_traits;

  const extern2_optional&
  extern2 () const;

  extern2_optional&
  extern2 ();

  void
  extern2 (const extern2_type& x);

  void
  extern2 (const extern2_optional& x);

  void
  extern2 (::std::unique_ptr< extern2_type > p);

  // extern3
  //
  typedef ::text128_type extern3_type;
  typedef ::xsd::cxx::tree::optional< extern3_type > extern3_optional;
  typedef ::xsd::cxx::tree::traits< extern3_type, wchar_t > extern3_traits;

  const extern3_optional&
  extern3 () const;

  extern3_optional&
  extern3 ();

  void
  extern3 (const extern3_type& x);

  void
  extern3 (const extern3_optional& x);

  void
  extern3 (::std::unique_ptr< extern3_type > p);

  // userfield1
  //
  typedef ::text256_type userfield1_type;
  typedef ::xsd::cxx::tree::optional< userfield1_type > userfield1_optional;
  typedef ::xsd::cxx::tree::traits< userfield1_type, wchar_t > userfield1_traits;

  const userfield1_optional&
  userfield1 () const;

  userfield1_optional&
  userfield1 ();

  void
  userfield1 (const userfield1_type& x);

  void
  userfield1 (const userfield1_optional& x);

  void
  userfield1 (::std::unique_ptr< userfield1_type > p);

  // userfield2
  //
  typedef ::text256_type userfield2_type;
  typedef ::xsd::cxx::tree::optional< userfield2_type > userfield2_optional;
  typedef ::xsd::cxx::tree::traits< userfield2_type, wchar_t > userfield2_traits;

  const userfield2_optional&
  userfield2 () const;

  userfield2_optional&
  userfield2 ();

  void
  userfield2 (const userfield2_type& x);

  void
  userfield2 (const userfield2_optional& x);

  void
  userfield2 (::std::unique_ptr< userfield2_type > p);

  // userfield3
  //
  typedef ::text256_type userfield3_type;
  typedef ::xsd::cxx::tree::optional< userfield3_type > userfield3_optional;
  typedef ::xsd::cxx::tree::traits< userfield3_type, wchar_t > userfield3_traits;

  const userfield3_optional&
  userfield3 () const;

  userfield3_optional&
  userfield3 ();

  void
  userfield3 (const userfield3_type& x);

  void
  userfield3 (const userfield3_optional& x);

  void
  userfield3 (::std::unique_ptr< userfield3_type > p);

  // user
  //
  typedef ::text128_type user_type;
  typedef ::xsd::cxx::tree::optional< user_type > user_optional;
  typedef ::xsd::cxx::tree::traits< user_type, wchar_t > user_traits;

  const user_optional&
  user () const;

  user_optional&
  user ();

  void
  user (const user_type& x);

  void
  user (const user_optional& x);

  void
  user (::std::unique_ptr< user_type > p);

  // desc
  //
  typedef ::xml_schema::string desc_type;
  typedef ::xsd::cxx::tree::optional< desc_type > desc_optional;
  typedef ::xsd::cxx::tree::traits< desc_type, wchar_t > desc_traits;

  const desc_optional&
  desc () const;

  desc_optional&
  desc ();

  void
  desc (const desc_type& x);

  void
  desc (const desc_optional& x);

  void
  desc (::std::unique_ptr< desc_type > p);

  // note
  //
  typedef ::xml_schema::string note_type;
  typedef ::xsd::cxx::tree::optional< note_type > note_optional;
  typedef ::xsd::cxx::tree::traits< note_type, wchar_t > note_traits;

  const note_optional&
  note () const;

  note_optional&
  note ();

  void
  note (const note_type& x);

  void
  note (const note_optional& x);

  void
  note (::std::unique_ptr< note_type > p);

  // remark
  //
  typedef ::xml_schema::string remark_type;
  typedef ::xsd::cxx::tree::optional< remark_type > remark_optional;
  typedef ::xsd::cxx::tree::traits< remark_type, wchar_t > remark_traits;

  const remark_optional&
  remark () const;

  remark_optional&
  remark ();

  void
  remark (const remark_type& x);

  void
  remark (const remark_optional& x);

  void
  remark (::std::unique_ptr< remark_type > p);

  // Constructors.
  //
  bkm_part (const externalkey_type&);

  bkm_part (const bkm_part& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual bkm_part*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  bkm_part&
  operator= (const bkm_part& x);

  virtual 
  ~bkm_part ();

  // Implementation.
  //
  protected:
  id_optional id_;
  ::xsd::cxx::tree::one< externalkey_type > externalkey_;
  projectkey_optional projectkey_;
  parishkey1_optional parishkey1_;
  parishkey2_optional parishkey2_;
  returnreal_optional returnreal_;
  returnsold_optional returnsold_;
  matchfield_optional matchfield_;
  controlcode_optional controlcode_;
  code_optional code_;
  part_optional part_;
  partstart_optional partstart_;
  partend_optional partend_;
  currency_optional currency_;
  number_optional number_;
  city_optional city_;
  zipcode_optional zipcode_;
  street_optional street_;
  statecode_optional statecode_;
  deliverycode_optional deliverycode_;
  typecode_optional typecode_;
  statuscode_optional statuscode_;
  groupcode_optional groupcode_;
  vatprz_optional vatprz_;
  extern1_optional extern1_;
  extern2_optional extern2_;
  extern3_optional extern3_;
  userfield1_optional userfield1_;
  userfield2_optional userfield2_;
  userfield3_optional userfield3_;
  user_optional user_;
  desc_optional desc_;
  note_optional note_;
  remark_optional remark_;
};

class bkm_splititem: public ::xml_schema::type
{
  public:
  // id
  //
  typedef ::xml_schema::int_ id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  // code
  //
  typedef ::text16_type code_type;
  typedef ::xsd::cxx::tree::optional< code_type > code_optional;
  typedef ::xsd::cxx::tree::traits< code_type, wchar_t > code_traits;

  const code_optional&
  code () const;

  code_optional&
  code ();

  void
  code (const code_type& x);

  void
  code (const code_optional& x);

  void
  code (::std::unique_ptr< code_type > p);

  // name
  //
  typedef ::text64_type name_type;
  typedef ::xsd::cxx::tree::optional< name_type > name_optional;
  typedef ::xsd::cxx::tree::traits< name_type, wchar_t > name_traits;

  const name_optional&
  name () const;

  name_optional&
  name ();

  void
  name (const name_type& x);

  void
  name (const name_optional& x);

  void
  name (::std::unique_ptr< name_type > p);

  // splitcode
  //
  typedef ::text16_type splitcode_type;
  typedef ::xsd::cxx::tree::optional< splitcode_type > splitcode_optional;
  typedef ::xsd::cxx::tree::traits< splitcode_type, wchar_t > splitcode_traits;

  const splitcode_optional&
  splitcode () const;

  splitcode_optional&
  splitcode ();

  void
  splitcode (const splitcode_type& x);

  void
  splitcode (const splitcode_optional& x);

  void
  splitcode (::std::unique_ptr< splitcode_type > p);

  // Constructors.
  //
  bkm_splititem ();

  bkm_splititem (const bkm_splititem& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  virtual bkm_splititem*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  bkm_splititem&
  operator= (const bkm_splititem& x);

  virtual 
  ~bkm_splititem ();

  // Implementation.
  //
  protected:
  id_optional id_;
  code_optional code_;
  name_optional name_;
  splitcode_optional splitcode_;
};

class bkm_placing: public ::xml_schema::type
{
  public:
  // id
  //
  typedef ::xml_schema::int_ id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  // externalkey
  //
  typedef ::externalkey_type externalkey_type;
  typedef ::xsd::cxx::tree::traits< externalkey_type, wchar_t > externalkey_traits;

  const externalkey_type&
  externalkey () const;

  externalkey_type&
  externalkey ();

  void
  externalkey (const externalkey_type& x);

  void
  externalkey (::std::unique_ptr< externalkey_type > p);

  // projectkey
  //
  typedef ::externalkey_type projectkey_type;
  typedef ::xsd::cxx::tree::optional< projectkey_type > projectkey_optional;
  typedef ::xsd::cxx::tree::traits< projectkey_type, wchar_t > projectkey_traits;

  const projectkey_optional&
  projectkey () const;

  projectkey_optional&
  projectkey ();

  void
  projectkey (const projectkey_type& x);

  void
  projectkey (const projectkey_optional& x);

  void
  projectkey (::std::unique_ptr< projectkey_type > p);

  // partcode
  //
  typedef ::text32_type partcode_type;
  typedef ::xsd::cxx::tree::optional< partcode_type > partcode_optional;
  typedef ::xsd::cxx::tree::traits< partcode_type, wchar_t > partcode_traits;

  const partcode_optional&
  partcode () const;

  partcode_optional&
  partcode ();

  void
  partcode (const partcode_type& x);

  void
  partcode (const partcode_optional& x);

  void
  partcode (::std::unique_ptr< partcode_type > p);

  // partcode1
  //
  typedef ::text32_type partcode1_type;
  typedef ::xsd::cxx::tree::optional< partcode1_type > partcode1_optional;
  typedef ::xsd::cxx::tree::traits< partcode1_type, wchar_t > partcode1_traits;

  const partcode1_optional&
  partcode1 () const;

  partcode1_optional&
  partcode1 ();

  void
  partcode1 (const partcode1_type& x);

  void
  partcode1 (const partcode1_optional& x);

  void
  partcode1 (::std::unique_ptr< partcode1_type > p);

  // matchfield
  //
  typedef ::matchfieldplacing_type matchfield_type;
  typedef ::xsd::cxx::tree::optional< matchfield_type > matchfield_optional;
  typedef ::xsd::cxx::tree::traits< matchfield_type, wchar_t > matchfield_traits;

  const matchfield_optional&
  matchfield () const;

  matchfield_optional&
  matchfield ();

  void
  matchfield (const matchfield_type& x);

  void
  matchfield (const matchfield_optional& x);

  void
  matchfield (::std::unique_ptr< matchfield_type > p);

  // controlcode
  //
  typedef ::text256_type controlcode_type;
  typedef ::xsd::cxx::tree::optional< controlcode_type > controlcode_optional;
  typedef ::xsd::cxx::tree::traits< controlcode_type, wchar_t > controlcode_traits;

  const controlcode_optional&
  controlcode () const;

  controlcode_optional&
  controlcode ();

  void
  controlcode (const controlcode_type& x);

  void
  controlcode (const controlcode_optional& x);

  void
  controlcode (::std::unique_ptr< controlcode_type > p);

  // code
  //
  typedef ::text16_type code_type;
  typedef ::xsd::cxx::tree::optional< code_type > code_optional;
  typedef ::xsd::cxx::tree::traits< code_type, wchar_t > code_traits;

  const code_optional&
  code () const;

  code_optional&
  code ();

  void
  code (const code_type& x);

  void
  code (const code_optional& x);

  void
  code (::std::unique_ptr< code_type > p);

  // placing
  //
  typedef ::text64_type placing_type;
  typedef ::xsd::cxx::tree::optional< placing_type > placing_optional;
  typedef ::xsd::cxx::tree::traits< placing_type, wchar_t > placing_traits;

  const placing_optional&
  placing () const;

  placing_optional&
  placing ();

  void
  placing (const placing_type& x);

  void
  placing (const placing_optional& x);

  void
  placing (::std::unique_ptr< placing_type > p);

  // extern1
  //
  typedef ::text128_type extern1_type;
  typedef ::xsd::cxx::tree::optional< extern1_type > extern1_optional;
  typedef ::xsd::cxx::tree::traits< extern1_type, wchar_t > extern1_traits;

  const extern1_optional&
  extern1 () const;

  extern1_optional&
  extern1 ();

  void
  extern1 (const extern1_type& x);

  void
  extern1 (const extern1_optional& x);

  void
  extern1 (::std::unique_ptr< extern1_type > p);

  // extern2
  //
  typedef ::text128_type extern2_type;
  typedef ::xsd::cxx::tree::optional< extern2_type > extern2_optional;
  typedef ::xsd::cxx::tree::traits< extern2_type, wchar_t > extern2_traits;

  const extern2_optional&
  extern2 () const;

  extern2_optional&
  extern2 ();

  void
  extern2 (const extern2_type& x);

  void
  extern2 (const extern2_optional& x);

  void
  extern2 (::std::unique_ptr< extern2_type > p);

  // extern3
  //
  typedef ::text128_type extern3_type;
  typedef ::xsd::cxx::tree::optional< extern3_type > extern3_optional;
  typedef ::xsd::cxx::tree::traits< extern3_type, wchar_t > extern3_traits;

  const extern3_optional&
  extern3 () const;

  extern3_optional&
  extern3 ();

  void
  extern3 (const extern3_type& x);

  void
  extern3 (const extern3_optional& x);

  void
  extern3 (::std::unique_ptr< extern3_type > p);

  // budget
  //
  typedef ::decimal_type budget_type;
  typedef ::xsd::cxx::tree::optional< budget_type > budget_optional;
  typedef ::xsd::cxx::tree::traits< budget_type, wchar_t > budget_traits;

  const budget_optional&
  budget () const;

  budget_optional&
  budget ();

  void
  budget (const budget_type& x);

  void
  budget (const budget_optional& x);

  void
  budget (::std::unique_ptr< budget_type > p);

  // budgetcustom
  //
  typedef ::decimal_type budgetcustom_type;
  typedef ::xsd::cxx::tree::optional< budgetcustom_type > budgetcustom_optional;
  typedef ::xsd::cxx::tree::traits< budgetcustom_type, wchar_t > budgetcustom_traits;

  const budgetcustom_optional&
  budgetcustom () const;

  budgetcustom_optional&
  budgetcustom ();

  void
  budgetcustom (const budgetcustom_type& x);

  void
  budgetcustom (const budgetcustom_optional& x);

  void
  budgetcustom (::std::unique_ptr< budgetcustom_type > p);

  // lstgstart
  //
  typedef ::xml_schema::date lstgstart_type;
  typedef ::xsd::cxx::tree::optional< lstgstart_type > lstgstart_optional;
  typedef ::xsd::cxx::tree::traits< lstgstart_type, wchar_t > lstgstart_traits;

  const lstgstart_optional&
  lstgstart () const;

  lstgstart_optional&
  lstgstart ();

  void
  lstgstart (const lstgstart_type& x);

  void
  lstgstart (const lstgstart_optional& x);

  void
  lstgstart (::std::unique_ptr< lstgstart_type > p);

  // lstgend
  //
  typedef ::xml_schema::date lstgend_type;
  typedef ::xsd::cxx::tree::optional< lstgend_type > lstgend_optional;
  typedef ::xsd::cxx::tree::traits< lstgend_type, wchar_t > lstgend_traits;

  const lstgend_optional&
  lstgend () const;

  lstgend_optional&
  lstgend ();

  void
  lstgend (const lstgend_type& x);

  void
  lstgend (const lstgend_optional& x);

  void
  lstgend (::std::unique_ptr< lstgend_type > p);

  // vatprz
  //
  typedef ::percent_type vatprz_type;
  typedef ::xsd::cxx::tree::optional< vatprz_type > vatprz_optional;
  typedef ::xsd::cxx::tree::traits< vatprz_type, wchar_t > vatprz_traits;

  const vatprz_optional&
  vatprz () const;

  vatprz_optional&
  vatprz ();

  void
  vatprz (const vatprz_type& x);

  void
  vatprz (const vatprz_optional& x);

  void
  vatprz (::std::unique_ptr< vatprz_type > p);

  // costobjectcode
  //
  typedef ::text16_type costobjectcode_type;
  typedef ::xsd::cxx::tree::optional< costobjectcode_type > costobjectcode_optional;
  typedef ::xsd::cxx::tree::traits< costobjectcode_type, wchar_t > costobjectcode_traits;

  const costobjectcode_optional&
  costobjectcode () const;

  costobjectcode_optional&
  costobjectcode ();

  void
  costobjectcode (const costobjectcode_type& x);

  void
  costobjectcode (const costobjectcode_optional& x);

  void
  costobjectcode (::std::unique_ptr< costobjectcode_type > p);

  // costobjectname
  //
  typedef ::text32_type costobjectname_type;
  typedef ::xsd::cxx::tree::optional< costobjectname_type > costobjectname_optional;
  typedef ::xsd::cxx::tree::traits< costobjectname_type, wchar_t > costobjectname_traits;

  const costobjectname_optional&
  costobjectname () const;

  costobjectname_optional&
  costobjectname ();

  void
  costobjectname (const costobjectname_type& x);

  void
  costobjectname (const costobjectname_optional& x);

  void
  costobjectname (::std::unique_ptr< costobjectname_type > p);

  // costunitcode1
  //
  typedef ::text16_type costunitcode1_type;
  typedef ::xsd::cxx::tree::optional< costunitcode1_type > costunitcode1_optional;
  typedef ::xsd::cxx::tree::traits< costunitcode1_type, wchar_t > costunitcode1_traits;

  const costunitcode1_optional&
  costunitcode1 () const;

  costunitcode1_optional&
  costunitcode1 ();

  void
  costunitcode1 (const costunitcode1_type& x);

  void
  costunitcode1 (const costunitcode1_optional& x);

  void
  costunitcode1 (::std::unique_ptr< costunitcode1_type > p);

  // costunitname1
  //
  typedef ::text32_type costunitname1_type;
  typedef ::xsd::cxx::tree::optional< costunitname1_type > costunitname1_optional;
  typedef ::xsd::cxx::tree::traits< costunitname1_type, wchar_t > costunitname1_traits;

  const costunitname1_optional&
  costunitname1 () const;

  costunitname1_optional&
  costunitname1 ();

  void
  costunitname1 (const costunitname1_type& x);

  void
  costunitname1 (const costunitname1_optional& x);

  void
  costunitname1 (::std::unique_ptr< costunitname1_type > p);

  // costunitcode2
  //
  typedef ::text16_type costunitcode2_type;
  typedef ::xsd::cxx::tree::optional< costunitcode2_type > costunitcode2_optional;
  typedef ::xsd::cxx::tree::traits< costunitcode2_type, wchar_t > costunitcode2_traits;

  const costunitcode2_optional&
  costunitcode2 () const;

  costunitcode2_optional&
  costunitcode2 ();

  void
  costunitcode2 (const costunitcode2_type& x);

  void
  costunitcode2 (const costunitcode2_optional& x);

  void
  costunitcode2 (::std::unique_ptr< costunitcode2_type > p);

  // costunitname2
  //
  typedef ::text32_type costunitname2_type;
  typedef ::xsd::cxx::tree::optional< costunitname2_type > costunitname2_optional;
  typedef ::xsd::cxx::tree::traits< costunitname2_type, wchar_t > costunitname2_traits;

  const costunitname2_optional&
  costunitname2 () const;

  costunitname2_optional&
  costunitname2 ();

  void
  costunitname2 (const costunitname2_type& x);

  void
  costunitname2 (const costunitname2_optional& x);

  void
  costunitname2 (::std::unique_ptr< costunitname2_type > p);

  // statuscode
  //
  typedef ::text8_type statuscode_type;
  typedef ::xsd::cxx::tree::optional< statuscode_type > statuscode_optional;
  typedef ::xsd::cxx::tree::traits< statuscode_type, wchar_t > statuscode_traits;

  const statuscode_optional&
  statuscode () const;

  statuscode_optional&
  statuscode ();

  void
  statuscode (const statuscode_type& x);

  void
  statuscode (const statuscode_optional& x);

  void
  statuscode (::std::unique_ptr< statuscode_type > p);

  // statusname
  //
  typedef ::text32_type statusname_type;
  typedef ::xsd::cxx::tree::optional< statusname_type > statusname_optional;
  typedef ::xsd::cxx::tree::traits< statusname_type, wchar_t > statusname_traits;

  const statusname_optional&
  statusname () const;

  statusname_optional&
  statusname ();

  void
  statusname (const statusname_type& x);

  void
  statusname (const statusname_optional& x);

  void
  statusname (::std::unique_ptr< statusname_type > p);

  // groupcode
  //
  typedef ::text8_type groupcode_type;
  typedef ::xsd::cxx::tree::optional< groupcode_type > groupcode_optional;
  typedef ::xsd::cxx::tree::traits< groupcode_type, wchar_t > groupcode_traits;

  const groupcode_optional&
  groupcode () const;

  groupcode_optional&
  groupcode ();

  void
  groupcode (const groupcode_type& x);

  void
  groupcode (const groupcode_optional& x);

  void
  groupcode (::std::unique_ptr< groupcode_type > p);

  // groupname
  //
  typedef ::text64_type groupname_type;
  typedef ::xsd::cxx::tree::optional< groupname_type > groupname_optional;
  typedef ::xsd::cxx::tree::traits< groupname_type, wchar_t > groupname_traits;

  const groupname_optional&
  groupname () const;

  groupname_optional&
  groupname ();

  void
  groupname (const groupname_type& x);

  void
  groupname (const groupname_optional& x);

  void
  groupname (::std::unique_ptr< groupname_type > p);

  // userfield1
  //
  typedef ::text256_type userfield1_type;
  typedef ::xsd::cxx::tree::optional< userfield1_type > userfield1_optional;
  typedef ::xsd::cxx::tree::traits< userfield1_type, wchar_t > userfield1_traits;

  const userfield1_optional&
  userfield1 () const;

  userfield1_optional&
  userfield1 ();

  void
  userfield1 (const userfield1_type& x);

  void
  userfield1 (const userfield1_optional& x);

  void
  userfield1 (::std::unique_ptr< userfield1_type > p);

  // userfield2
  //
  typedef ::text256_type userfield2_type;
  typedef ::xsd::cxx::tree::optional< userfield2_type > userfield2_optional;
  typedef ::xsd::cxx::tree::traits< userfield2_type, wchar_t > userfield2_traits;

  const userfield2_optional&
  userfield2 () const;

  userfield2_optional&
  userfield2 ();

  void
  userfield2 (const userfield2_type& x);

  void
  userfield2 (const userfield2_optional& x);

  void
  userfield2 (::std::unique_ptr< userfield2_type > p);

  // userfield3
  //
  typedef ::text256_type userfield3_type;
  typedef ::xsd::cxx::tree::optional< userfield3_type > userfield3_optional;
  typedef ::xsd::cxx::tree::traits< userfield3_type, wchar_t > userfield3_traits;

  const userfield3_optional&
  userfield3 () const;

  userfield3_optional&
  userfield3 ();

  void
  userfield3 (const userfield3_type& x);

  void
  userfield3 (const userfield3_optional& x);

  void
  userfield3 (::std::unique_ptr< userfield3_type > p);

  // desc
  //
  typedef ::xml_schema::string desc_type;
  typedef ::xsd::cxx::tree::optional< desc_type > desc_optional;
  typedef ::xsd::cxx::tree::traits< desc_type, wchar_t > desc_traits;

  const desc_optional&
  desc () const;

  desc_optional&
  desc ();

  void
  desc (const desc_type& x);

  void
  desc (const desc_optional& x);

  void
  desc (::std::unique_ptr< desc_type > p);

  // note
  //
  typedef ::xml_schema::string note_type;
  typedef ::xsd::cxx::tree::optional< note_type > note_optional;
  typedef ::xsd::cxx::tree::traits< note_type, wchar_t > note_traits;

  const note_optional&
  note () const;

  note_optional&
  note ();

  void
  note (const note_type& x);

  void
  note (const note_optional& x);

  void
  note (::std::unique_ptr< note_type > p);

  // remark
  //
  typedef ::xml_schema::string remark_type;
  typedef ::xsd::cxx::tree::optional< remark_type > remark_optional;
  typedef ::xsd::cxx::tree::traits< remark_type, wchar_t > remark_traits;

  const remark_optional&
  remark () const;

  remark_optional&
  remark ();

  void
  remark (const remark_type& x);

  void
  remark (const remark_optional& x);

  void
  remark (::std::unique_ptr< remark_type > p);

  // Constructors.
  //
  bkm_placing (const externalkey_type&);

  bkm_placing (const bkm_placing& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  virtual bkm_placing*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  bkm_placing&
  operator= (const bkm_placing& x);

  virtual 
  ~bkm_placing ();

  // Implementation.
  //
  protected:
  id_optional id_;
  ::xsd::cxx::tree::one< externalkey_type > externalkey_;
  projectkey_optional projectkey_;
  partcode_optional partcode_;
  partcode1_optional partcode1_;
  matchfield_optional matchfield_;
  controlcode_optional controlcode_;
  code_optional code_;
  placing_optional placing_;
  extern1_optional extern1_;
  extern2_optional extern2_;
  extern3_optional extern3_;
  budget_optional budget_;
  budgetcustom_optional budgetcustom_;
  lstgstart_optional lstgstart_;
  lstgend_optional lstgend_;
  vatprz_optional vatprz_;
  costobjectcode_optional costobjectcode_;
  costobjectname_optional costobjectname_;
  costunitcode1_optional costunitcode1_;
  costunitname1_optional costunitname1_;
  costunitcode2_optional costunitcode2_;
  costunitname2_optional costunitname2_;
  statuscode_optional statuscode_;
  statusname_optional statusname_;
  groupcode_optional groupcode_;
  groupname_optional groupname_;
  userfield1_optional userfield1_;
  userfield2_optional userfield2_;
  userfield3_optional userfield3_;
  desc_optional desc_;
  note_optional note_;
  remark_optional remark_;
};

class bkm_revision: public ::xml_schema::type
{
  public:
  // bkm.revisionitem
  //
  typedef ::bkm_revisionitem bkm_revisionitem_type;
  typedef ::xsd::cxx::tree::sequence< bkm_revisionitem_type > bkm_revisionitem_sequence;
  typedef bkm_revisionitem_sequence::iterator bkm_revisionitem_iterator;
  typedef bkm_revisionitem_sequence::const_iterator bkm_revisionitem_const_iterator;
  typedef ::xsd::cxx::tree::traits< bkm_revisionitem_type, wchar_t > bkm_revisionitem_traits;

  const bkm_revisionitem_sequence&
  bkm_revisionitem () const;

  bkm_revisionitem_sequence&
  bkm_revisionitem ();

  void
  bkm_revisionitem (const bkm_revisionitem_sequence& s);

  // ret.revisionitem
  //
  typedef ::ret_revisionitem ret_revisionitem_type;
  typedef ::xsd::cxx::tree::sequence< ret_revisionitem_type > ret_revisionitem_sequence;
  typedef ret_revisionitem_sequence::iterator ret_revisionitem_iterator;
  typedef ret_revisionitem_sequence::const_iterator ret_revisionitem_const_iterator;
  typedef ::xsd::cxx::tree::traits< ret_revisionitem_type, wchar_t > ret_revisionitem_traits;

  const ret_revisionitem_sequence&
  ret_revisionitem () const;

  ret_revisionitem_sequence&
  ret_revisionitem ();

  void
  ret_revisionitem (const ret_revisionitem_sequence& s);

  // id
  //
  typedef ::xml_schema::int_ id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  // externalkey
  //
  typedef ::externalkey_type externalkey_type;
  typedef ::xsd::cxx::tree::traits< externalkey_type, wchar_t > externalkey_traits;

  const externalkey_type&
  externalkey () const;

  externalkey_type&
  externalkey ();

  void
  externalkey (const externalkey_type& x);

  void
  externalkey (::std::unique_ptr< externalkey_type > p);

  // projectkey
  //
  typedef ::externalkey_type projectkey_type;
  typedef ::xsd::cxx::tree::optional< projectkey_type > projectkey_optional;
  typedef ::xsd::cxx::tree::traits< projectkey_type, wchar_t > projectkey_traits;

  const projectkey_optional&
  projectkey () const;

  projectkey_optional&
  projectkey ();

  void
  projectkey (const projectkey_type& x);

  void
  projectkey (const projectkey_optional& x);

  void
  projectkey (::std::unique_ptr< projectkey_type > p);

  // matchfield
  //
  typedef ::matchfieldrevision_type matchfield_type;
  typedef ::xsd::cxx::tree::optional< matchfield_type > matchfield_optional;
  typedef ::xsd::cxx::tree::traits< matchfield_type, wchar_t > matchfield_traits;

  const matchfield_optional&
  matchfield () const;

  matchfield_optional&
  matchfield ();

  void
  matchfield (const matchfield_type& x);

  void
  matchfield (const matchfield_optional& x);

  void
  matchfield (::std::unique_ptr< matchfield_type > p);

  // controlcode
  //
  typedef ::text256_type controlcode_type;
  typedef ::xsd::cxx::tree::optional< controlcode_type > controlcode_optional;
  typedef ::xsd::cxx::tree::traits< controlcode_type, wchar_t > controlcode_traits;

  const controlcode_optional&
  controlcode () const;

  controlcode_optional&
  controlcode ();

  void
  controlcode (const controlcode_type& x);

  void
  controlcode (const controlcode_optional& x);

  void
  controlcode (::std::unique_ptr< controlcode_type > p);

  // number
  //
  typedef ::text16_type number_type;
  typedef ::xsd::cxx::tree::optional< number_type > number_optional;
  typedef ::xsd::cxx::tree::traits< number_type, wchar_t > number_traits;

  const number_optional&
  number () const;

  number_optional&
  number ();

  void
  number (const number_type& x);

  void
  number (const number_optional& x);

  void
  number (::std::unique_ptr< number_type > p);

  // releasenumber
  //
  typedef ::text16_type releasenumber_type;
  typedef ::xsd::cxx::tree::optional< releasenumber_type > releasenumber_optional;
  typedef ::xsd::cxx::tree::traits< releasenumber_type, wchar_t > releasenumber_traits;

  const releasenumber_optional&
  releasenumber () const;

  releasenumber_optional&
  releasenumber ();

  void
  releasenumber (const releasenumber_type& x);

  void
  releasenumber (const releasenumber_optional& x);

  void
  releasenumber (::std::unique_ptr< releasenumber_type > p);

  // extern1
  //
  typedef ::text128_type extern1_type;
  typedef ::xsd::cxx::tree::optional< extern1_type > extern1_optional;
  typedef ::xsd::cxx::tree::traits< extern1_type, wchar_t > extern1_traits;

  const extern1_optional&
  extern1 () const;

  extern1_optional&
  extern1 ();

  void
  extern1 (const extern1_type& x);

  void
  extern1 (const extern1_optional& x);

  void
  extern1 (::std::unique_ptr< extern1_type > p);

  // extern2
  //
  typedef ::text128_type extern2_type;
  typedef ::xsd::cxx::tree::optional< extern2_type > extern2_optional;
  typedef ::xsd::cxx::tree::traits< extern2_type, wchar_t > extern2_traits;

  const extern2_optional&
  extern2 () const;

  extern2_optional&
  extern2 ();

  void
  extern2 (const extern2_type& x);

  void
  extern2 (const extern2_optional& x);

  void
  extern2 (::std::unique_ptr< extern2_type > p);

  // extern3
  //
  typedef ::text128_type extern3_type;
  typedef ::xsd::cxx::tree::optional< extern3_type > extern3_optional;
  typedef ::xsd::cxx::tree::traits< extern3_type, wchar_t > extern3_traits;

  const extern3_optional&
  extern3 () const;

  extern3_optional&
  extern3 ();

  void
  extern3 (const extern3_type& x);

  void
  extern3 (const extern3_optional& x);

  void
  extern3 (::std::unique_ptr< extern3_type > p);

  // revision
  //
  typedef ::text64_type revision_type;
  typedef ::xsd::cxx::tree::optional< revision_type > revision_optional;
  typedef ::xsd::cxx::tree::traits< revision_type, wchar_t > revision_traits;

  const revision_optional&
  revision () const;

  revision_optional&
  revision ();

  void
  revision (const revision_type& x);

  void
  revision (const revision_optional& x);

  void
  revision (::std::unique_ptr< revision_type > p);

  // dateeffect
  //
  typedef ::text64_type dateeffect_type;
  typedef ::xsd::cxx::tree::optional< dateeffect_type > dateeffect_optional;
  typedef ::xsd::cxx::tree::traits< dateeffect_type, wchar_t > dateeffect_traits;

  const dateeffect_optional&
  dateeffect () const;

  dateeffect_optional&
  dateeffect ();

  void
  dateeffect (const dateeffect_type& x);

  void
  dateeffect (const dateeffect_optional& x);

  void
  dateeffect (::std::unique_ptr< dateeffect_type > p);

  // releasedby
  //
  typedef ::text32_type releasedby_type;
  typedef ::xsd::cxx::tree::optional< releasedby_type > releasedby_optional;
  typedef ::xsd::cxx::tree::traits< releasedby_type, wchar_t > releasedby_traits;

  const releasedby_optional&
  releasedby () const;

  releasedby_optional&
  releasedby ();

  void
  releasedby (const releasedby_type& x);

  void
  releasedby (const releasedby_optional& x);

  void
  releasedby (::std::unique_ptr< releasedby_type > p);

  // revisionbtr
  //
  typedef ::decimal_type revisionbtr_type;
  typedef ::xsd::cxx::tree::optional< revisionbtr_type > revisionbtr_optional;
  typedef ::xsd::cxx::tree::traits< revisionbtr_type, wchar_t > revisionbtr_traits;

  const revisionbtr_optional&
  revisionbtr () const;

  revisionbtr_optional&
  revisionbtr ();

  void
  revisionbtr (const revisionbtr_type& x);

  void
  revisionbtr (const revisionbtr_optional& x);

  void
  revisionbtr (::std::unique_ptr< revisionbtr_type > p);

  // releasedbtr
  //
  typedef ::decimal_type releasedbtr_type;
  typedef ::xsd::cxx::tree::optional< releasedbtr_type > releasedbtr_optional;
  typedef ::xsd::cxx::tree::traits< releasedbtr_type, wchar_t > releasedbtr_traits;

  const releasedbtr_optional&
  releasedbtr () const;

  releasedbtr_optional&
  releasedbtr ();

  void
  releasedbtr (const releasedbtr_type& x);

  void
  releasedbtr (const releasedbtr_optional& x);

  void
  releasedbtr (::std::unique_ptr< releasedbtr_type > p);

  // requestdate
  //
  typedef ::xml_schema::date requestdate_type;
  typedef ::xsd::cxx::tree::optional< requestdate_type > requestdate_optional;
  typedef ::xsd::cxx::tree::traits< requestdate_type, wchar_t > requestdate_traits;

  const requestdate_optional&
  requestdate () const;

  requestdate_optional&
  requestdate ();

  void
  requestdate (const requestdate_type& x);

  void
  requestdate (const requestdate_optional& x);

  void
  requestdate (::std::unique_ptr< requestdate_type > p);

  // releasedate
  //
  typedef ::xml_schema::date releasedate_type;
  typedef ::xsd::cxx::tree::optional< releasedate_type > releasedate_optional;
  typedef ::xsd::cxx::tree::traits< releasedate_type, wchar_t > releasedate_traits;

  const releasedate_optional&
  releasedate () const;

  releasedate_optional&
  releasedate ();

  void
  releasedate (const releasedate_type& x);

  void
  releasedate (const releasedate_optional& x);

  void
  releasedate (::std::unique_ptr< releasedate_type > p);

  // vatprz
  //
  typedef ::percent_type vatprz_type;
  typedef ::xsd::cxx::tree::optional< vatprz_type > vatprz_optional;
  typedef ::xsd::cxx::tree::traits< vatprz_type, wchar_t > vatprz_traits;

  const vatprz_optional&
  vatprz () const;

  vatprz_optional&
  vatprz ();

  void
  vatprz (const vatprz_type& x);

  void
  vatprz (const vatprz_optional& x);

  void
  vatprz (::std::unique_ptr< vatprz_type > p);

  // statuscode
  //
  typedef ::text8_type statuscode_type;
  typedef ::xsd::cxx::tree::optional< statuscode_type > statuscode_optional;
  typedef ::xsd::cxx::tree::traits< statuscode_type, wchar_t > statuscode_traits;

  const statuscode_optional&
  statuscode () const;

  statuscode_optional&
  statuscode ();

  void
  statuscode (const statuscode_type& x);

  void
  statuscode (const statuscode_optional& x);

  void
  statuscode (::std::unique_ptr< statuscode_type > p);

  // statusname
  //
  typedef ::text32_type statusname_type;
  typedef ::xsd::cxx::tree::optional< statusname_type > statusname_optional;
  typedef ::xsd::cxx::tree::traits< statusname_type, wchar_t > statusname_traits;

  const statusname_optional&
  statusname () const;

  statusname_optional&
  statusname ();

  void
  statusname (const statusname_type& x);

  void
  statusname (const statusname_optional& x);

  void
  statusname (::std::unique_ptr< statusname_type > p);

  // statusinfo
  //
  typedef ::text256_type statusinfo_type;
  typedef ::xsd::cxx::tree::optional< statusinfo_type > statusinfo_optional;
  typedef ::xsd::cxx::tree::traits< statusinfo_type, wchar_t > statusinfo_traits;

  const statusinfo_optional&
  statusinfo () const;

  statusinfo_optional&
  statusinfo ();

  void
  statusinfo (const statusinfo_type& x);

  void
  statusinfo (const statusinfo_optional& x);

  void
  statusinfo (::std::unique_ptr< statusinfo_type > p);

  // statusinfodate
  //
  typedef ::xml_schema::date statusinfodate_type;
  typedef ::xsd::cxx::tree::optional< statusinfodate_type > statusinfodate_optional;
  typedef ::xsd::cxx::tree::traits< statusinfodate_type, wchar_t > statusinfodate_traits;

  const statusinfodate_optional&
  statusinfodate () const;

  statusinfodate_optional&
  statusinfodate ();

  void
  statusinfodate (const statusinfodate_type& x);

  void
  statusinfodate (const statusinfodate_optional& x);

  void
  statusinfodate (::std::unique_ptr< statusinfodate_type > p);

  // statusinfouser
  //
  typedef ::text128_type statusinfouser_type;
  typedef ::xsd::cxx::tree::optional< statusinfouser_type > statusinfouser_optional;
  typedef ::xsd::cxx::tree::traits< statusinfouser_type, wchar_t > statusinfouser_traits;

  const statusinfouser_optional&
  statusinfouser () const;

  statusinfouser_optional&
  statusinfouser ();

  void
  statusinfouser (const statusinfouser_type& x);

  void
  statusinfouser (const statusinfouser_optional& x);

  void
  statusinfouser (::std::unique_ptr< statusinfouser_type > p);

  // groupcode
  //
  typedef ::text8_type groupcode_type;
  typedef ::xsd::cxx::tree::optional< groupcode_type > groupcode_optional;
  typedef ::xsd::cxx::tree::traits< groupcode_type, wchar_t > groupcode_traits;

  const groupcode_optional&
  groupcode () const;

  groupcode_optional&
  groupcode ();

  void
  groupcode (const groupcode_type& x);

  void
  groupcode (const groupcode_optional& x);

  void
  groupcode (::std::unique_ptr< groupcode_type > p);

  // groupname
  //
  typedef ::text64_type groupname_type;
  typedef ::xsd::cxx::tree::optional< groupname_type > groupname_optional;
  typedef ::xsd::cxx::tree::traits< groupname_type, wchar_t > groupname_traits;

  const groupname_optional&
  groupname () const;

  groupname_optional&
  groupname ();

  void
  groupname (const groupname_type& x);

  void
  groupname (const groupname_optional& x);

  void
  groupname (::std::unique_ptr< groupname_type > p);

  // categorycode
  //
  typedef ::text8_type categorycode_type;
  typedef ::xsd::cxx::tree::optional< categorycode_type > categorycode_optional;
  typedef ::xsd::cxx::tree::traits< categorycode_type, wchar_t > categorycode_traits;

  const categorycode_optional&
  categorycode () const;

  categorycode_optional&
  categorycode ();

  void
  categorycode (const categorycode_type& x);

  void
  categorycode (const categorycode_optional& x);

  void
  categorycode (::std::unique_ptr< categorycode_type > p);

  // categoryname
  //
  typedef ::text64_type categoryname_type;
  typedef ::xsd::cxx::tree::optional< categoryname_type > categoryname_optional;
  typedef ::xsd::cxx::tree::traits< categoryname_type, wchar_t > categoryname_traits;

  const categoryname_optional&
  categoryname () const;

  categoryname_optional&
  categoryname ();

  void
  categoryname (const categoryname_type& x);

  void
  categoryname (const categoryname_optional& x);

  void
  categoryname (::std::unique_ptr< categoryname_type > p);

  // requestercode
  //
  typedef ::text64_type requestercode_type;
  typedef ::xsd::cxx::tree::optional< requestercode_type > requestercode_optional;
  typedef ::xsd::cxx::tree::traits< requestercode_type, wchar_t > requestercode_traits;

  const requestercode_optional&
  requestercode () const;

  requestercode_optional&
  requestercode ();

  void
  requestercode (const requestercode_type& x);

  void
  requestercode (const requestercode_optional& x);

  void
  requestercode (::std::unique_ptr< requestercode_type > p);

  // requesterkey
  //
  typedef ::externalkey_type requesterkey_type;
  typedef ::xsd::cxx::tree::optional< requesterkey_type > requesterkey_optional;
  typedef ::xsd::cxx::tree::traits< requesterkey_type, wchar_t > requesterkey_traits;

  const requesterkey_optional&
  requesterkey () const;

  requesterkey_optional&
  requesterkey ();

  void
  requesterkey (const requesterkey_type& x);

  void
  requesterkey (const requesterkey_optional& x);

  void
  requesterkey (::std::unique_ptr< requesterkey_type > p);

  // requesterkeyid
  //
  typedef ::text16_type requesterkeyid_type;
  typedef ::xsd::cxx::tree::optional< requesterkeyid_type > requesterkeyid_optional;
  typedef ::xsd::cxx::tree::traits< requesterkeyid_type, wchar_t > requesterkeyid_traits;

  const requesterkeyid_optional&
  requesterkeyid () const;

  requesterkeyid_optional&
  requesterkeyid ();

  void
  requesterkeyid (const requesterkeyid_type& x);

  void
  requesterkeyid (const requesterkeyid_optional& x);

  void
  requesterkeyid (::std::unique_ptr< requesterkeyid_type > p);

  // causercode
  //
  typedef ::text64_type causercode_type;
  typedef ::xsd::cxx::tree::optional< causercode_type > causercode_optional;
  typedef ::xsd::cxx::tree::traits< causercode_type, wchar_t > causercode_traits;

  const causercode_optional&
  causercode () const;

  causercode_optional&
  causercode ();

  void
  causercode (const causercode_type& x);

  void
  causercode (const causercode_optional& x);

  void
  causercode (::std::unique_ptr< causercode_type > p);

  // causerkey
  //
  typedef ::externalkey_type causerkey_type;
  typedef ::xsd::cxx::tree::optional< causerkey_type > causerkey_optional;
  typedef ::xsd::cxx::tree::traits< causerkey_type, wchar_t > causerkey_traits;

  const causerkey_optional&
  causerkey () const;

  causerkey_optional&
  causerkey ();

  void
  causerkey (const causerkey_type& x);

  void
  causerkey (const causerkey_optional& x);

  void
  causerkey (::std::unique_ptr< causerkey_type > p);

  // causerkeyid
  //
  typedef ::text16_type causerkeyid_type;
  typedef ::xsd::cxx::tree::optional< causerkeyid_type > causerkeyid_optional;
  typedef ::xsd::cxx::tree::traits< causerkeyid_type, wchar_t > causerkeyid_traits;

  const causerkeyid_optional&
  causerkeyid () const;

  causerkeyid_optional&
  causerkeyid ();

  void
  causerkeyid (const causerkeyid_type& x);

  void
  causerkeyid (const causerkeyid_optional& x);

  void
  causerkeyid (::std::unique_ptr< causerkeyid_type > p);

  // desc
  //
  typedef ::xml_schema::string desc_type;
  typedef ::xsd::cxx::tree::optional< desc_type > desc_optional;
  typedef ::xsd::cxx::tree::traits< desc_type, wchar_t > desc_traits;

  const desc_optional&
  desc () const;

  desc_optional&
  desc ();

  void
  desc (const desc_type& x);

  void
  desc (const desc_optional& x);

  void
  desc (::std::unique_ptr< desc_type > p);

  // note
  //
  typedef ::xml_schema::string note_type;
  typedef ::xsd::cxx::tree::optional< note_type > note_optional;
  typedef ::xsd::cxx::tree::traits< note_type, wchar_t > note_traits;

  const note_optional&
  note () const;

  note_optional&
  note ();

  void
  note (const note_type& x);

  void
  note (const note_optional& x);

  void
  note (::std::unique_ptr< note_type > p);

  // remark
  //
  typedef ::xml_schema::string remark_type;
  typedef ::xsd::cxx::tree::optional< remark_type > remark_optional;
  typedef ::xsd::cxx::tree::traits< remark_type, wchar_t > remark_traits;

  const remark_optional&
  remark () const;

  remark_optional&
  remark ();

  void
  remark (const remark_type& x);

  void
  remark (const remark_optional& x);

  void
  remark (::std::unique_ptr< remark_type > p);

  // Constructors.
  //
  bkm_revision (const externalkey_type&);

  bkm_revision (const bkm_revision& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual bkm_revision*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  bkm_revision&
  operator= (const bkm_revision& x);

  virtual 
  ~bkm_revision ();

  // Implementation.
  //
  protected:
  bkm_revisionitem_sequence bkm_revisionitem_;
  ret_revisionitem_sequence ret_revisionitem_;
  id_optional id_;
  ::xsd::cxx::tree::one< externalkey_type > externalkey_;
  projectkey_optional projectkey_;
  matchfield_optional matchfield_;
  controlcode_optional controlcode_;
  number_optional number_;
  releasenumber_optional releasenumber_;
  extern1_optional extern1_;
  extern2_optional extern2_;
  extern3_optional extern3_;
  revision_optional revision_;
  dateeffect_optional dateeffect_;
  releasedby_optional releasedby_;
  revisionbtr_optional revisionbtr_;
  releasedbtr_optional releasedbtr_;
  requestdate_optional requestdate_;
  releasedate_optional releasedate_;
  vatprz_optional vatprz_;
  statuscode_optional statuscode_;
  statusname_optional statusname_;
  statusinfo_optional statusinfo_;
  statusinfodate_optional statusinfodate_;
  statusinfouser_optional statusinfouser_;
  groupcode_optional groupcode_;
  groupname_optional groupname_;
  categorycode_optional categorycode_;
  categoryname_optional categoryname_;
  requestercode_optional requestercode_;
  requesterkey_optional requesterkey_;
  requesterkeyid_optional requesterkeyid_;
  causercode_optional causercode_;
  causerkey_optional causerkey_;
  causerkeyid_optional causerkeyid_;
  desc_optional desc_;
  note_optional note_;
  remark_optional remark_;
};

class bkm_revisionitem: public ::xml_schema::type
{
  public:
  // id
  //
  typedef ::xml_schema::int_ id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  // externalkey
  //
  typedef ::externalkey_type externalkey_type;
  typedef ::xsd::cxx::tree::traits< externalkey_type, wchar_t > externalkey_traits;

  const externalkey_type&
  externalkey () const;

  externalkey_type&
  externalkey ();

  void
  externalkey (const externalkey_type& x);

  void
  externalkey (::std::unique_ptr< externalkey_type > p);

  // placingkey
  //
  typedef ::externalkey_type placingkey_type;
  typedef ::xsd::cxx::tree::optional< placingkey_type > placingkey_optional;
  typedef ::xsd::cxx::tree::traits< placingkey_type, wchar_t > placingkey_traits;

  const placingkey_optional&
  placingkey () const;

  placingkey_optional&
  placingkey ();

  void
  placingkey (const placingkey_type& x);

  void
  placingkey (const placingkey_optional& x);

  void
  placingkey (::std::unique_ptr< placingkey_type > p);

  // placingcode
  //
  typedef ::text16_type placingcode_type;
  typedef ::xsd::cxx::tree::optional< placingcode_type > placingcode_optional;
  typedef ::xsd::cxx::tree::traits< placingcode_type, wchar_t > placingcode_traits;

  const placingcode_optional&
  placingcode () const;

  placingcode_optional&
  placingcode ();

  void
  placingcode (const placingcode_type& x);

  void
  placingcode (const placingcode_optional& x);

  void
  placingcode (::std::unique_ptr< placingcode_type > p);

  // placingname
  //
  typedef ::text64_type placingname_type;
  typedef ::xsd::cxx::tree::optional< placingname_type > placingname_optional;
  typedef ::xsd::cxx::tree::traits< placingname_type, wchar_t > placingname_traits;

  const placingname_optional&
  placingname () const;

  placingname_optional&
  placingname ();

  void
  placingname (const placingname_type& x);

  void
  placingname (const placingname_optional& x);

  void
  placingname (::std::unique_ptr< placingname_type > p);

  // code
  //
  typedef ::text16_type code_type;
  typedef ::xsd::cxx::tree::optional< code_type > code_optional;
  typedef ::xsd::cxx::tree::traits< code_type, wchar_t > code_traits;

  const code_optional&
  code () const;

  code_optional&
  code ();

  void
  code (const code_type& x);

  void
  code (const code_optional& x);

  void
  code (::std::unique_ptr< code_type > p);

  // revisionbtr
  //
  typedef ::decimal_type revisionbtr_type;
  typedef ::xsd::cxx::tree::optional< revisionbtr_type > revisionbtr_optional;
  typedef ::xsd::cxx::tree::traits< revisionbtr_type, wchar_t > revisionbtr_traits;

  const revisionbtr_optional&
  revisionbtr () const;

  revisionbtr_optional&
  revisionbtr ();

  void
  revisionbtr (const revisionbtr_type& x);

  void
  revisionbtr (const revisionbtr_optional& x);

  void
  revisionbtr (::std::unique_ptr< revisionbtr_type > p);

  // releasedbtr
  //
  typedef ::decimal_type releasedbtr_type;
  typedef ::xsd::cxx::tree::optional< releasedbtr_type > releasedbtr_optional;
  typedef ::xsd::cxx::tree::traits< releasedbtr_type, wchar_t > releasedbtr_traits;

  const releasedbtr_optional&
  releasedbtr () const;

  releasedbtr_optional&
  releasedbtr ();

  void
  releasedbtr (const releasedbtr_type& x);

  void
  releasedbtr (const releasedbtr_optional& x);

  void
  releasedbtr (::std::unique_ptr< releasedbtr_type > p);

  // vatprz
  //
  typedef ::percent_type vatprz_type;
  typedef ::xsd::cxx::tree::optional< vatprz_type > vatprz_optional;
  typedef ::xsd::cxx::tree::traits< vatprz_type, wchar_t > vatprz_traits;

  const vatprz_optional&
  vatprz () const;

  vatprz_optional&
  vatprz ();

  void
  vatprz (const vatprz_type& x);

  void
  vatprz (const vatprz_optional& x);

  void
  vatprz (::std::unique_ptr< vatprz_type > p);

  // ratingprz
  //
  typedef ::percent_type ratingprz_type;
  typedef ::xsd::cxx::tree::optional< ratingprz_type > ratingprz_optional;
  typedef ::xsd::cxx::tree::traits< ratingprz_type, wchar_t > ratingprz_traits;

  const ratingprz_optional&
  ratingprz () const;

  ratingprz_optional&
  ratingprz ();

  void
  ratingprz (const ratingprz_type& x);

  void
  ratingprz (const ratingprz_optional& x);

  void
  ratingprz (::std::unique_ptr< ratingprz_type > p);

  // desc
  //
  typedef ::xml_schema::string desc_type;
  typedef ::xsd::cxx::tree::optional< desc_type > desc_optional;
  typedef ::xsd::cxx::tree::traits< desc_type, wchar_t > desc_traits;

  const desc_optional&
  desc () const;

  desc_optional&
  desc ();

  void
  desc (const desc_type& x);

  void
  desc (const desc_optional& x);

  void
  desc (::std::unique_ptr< desc_type > p);

  // note
  //
  typedef ::xml_schema::string note_type;
  typedef ::xsd::cxx::tree::optional< note_type > note_optional;
  typedef ::xsd::cxx::tree::traits< note_type, wchar_t > note_traits;

  const note_optional&
  note () const;

  note_optional&
  note ();

  void
  note (const note_type& x);

  void
  note (const note_optional& x);

  void
  note (::std::unique_ptr< note_type > p);

  // remark
  //
  typedef ::xml_schema::string remark_type;
  typedef ::xsd::cxx::tree::optional< remark_type > remark_optional;
  typedef ::xsd::cxx::tree::traits< remark_type, wchar_t > remark_traits;

  const remark_optional&
  remark () const;

  remark_optional&
  remark ();

  void
  remark (const remark_type& x);

  void
  remark (const remark_optional& x);

  void
  remark (::std::unique_ptr< remark_type > p);

  // Constructors.
  //
  bkm_revisionitem (const externalkey_type&);

  bkm_revisionitem (const bkm_revisionitem& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  virtual bkm_revisionitem*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  bkm_revisionitem&
  operator= (const bkm_revisionitem& x);

  virtual 
  ~bkm_revisionitem ();

  // Implementation.
  //
  protected:
  id_optional id_;
  ::xsd::cxx::tree::one< externalkey_type > externalkey_;
  placingkey_optional placingkey_;
  placingcode_optional placingcode_;
  placingname_optional placingname_;
  code_optional code_;
  revisionbtr_optional revisionbtr_;
  releasedbtr_optional releasedbtr_;
  vatprz_optional vatprz_;
  ratingprz_optional ratingprz_;
  desc_optional desc_;
  note_optional note_;
  remark_optional remark_;
};

class ret_revisionitem: public ::xml_schema::type
{
  public:
  // id
  //
  typedef ::xml_schema::int_ id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  // orderkey
  //
  typedef ::externalkey_type orderkey_type;
  typedef ::xsd::cxx::tree::optional< orderkey_type > orderkey_optional;
  typedef ::xsd::cxx::tree::traits< orderkey_type, wchar_t > orderkey_traits;

  const orderkey_optional&
  orderkey () const;

  orderkey_optional&
  orderkey ();

  void
  orderkey (const orderkey_type& x);

  void
  orderkey (const orderkey_optional& x);

  void
  orderkey (::std::unique_ptr< orderkey_type > p);

  // ordercode
  //
  typedef ::text16_type ordercode_type;
  typedef ::xsd::cxx::tree::optional< ordercode_type > ordercode_optional;
  typedef ::xsd::cxx::tree::traits< ordercode_type, wchar_t > ordercode_traits;

  const ordercode_optional&
  ordercode () const;

  ordercode_optional&
  ordercode ();

  void
  ordercode (const ordercode_type& x);

  void
  ordercode (const ordercode_optional& x);

  void
  ordercode (::std::unique_ptr< ordercode_type > p);

  // ordername
  //
  typedef ::text64_type ordername_type;
  typedef ::xsd::cxx::tree::optional< ordername_type > ordername_optional;
  typedef ::xsd::cxx::tree::traits< ordername_type, wchar_t > ordername_traits;

  const ordername_optional&
  ordername () const;

  ordername_optional&
  ordername ();

  void
  ordername (const ordername_type& x);

  void
  ordername (const ordername_optional& x);

  void
  ordername (::std::unique_ptr< ordername_type > p);

  // code
  //
  typedef ::text16_type code_type;
  typedef ::xsd::cxx::tree::optional< code_type > code_optional;
  typedef ::xsd::cxx::tree::traits< code_type, wchar_t > code_traits;

  const code_optional&
  code () const;

  code_optional&
  code ();

  void
  code (const code_type& x);

  void
  code (const code_optional& x);

  void
  code (::std::unique_ptr< code_type > p);

  // budget
  //
  typedef ::decimal_type budget_type;
  typedef ::xsd::cxx::tree::optional< budget_type > budget_optional;
  typedef ::xsd::cxx::tree::traits< budget_type, wchar_t > budget_traits;

  const budget_optional&
  budget () const;

  budget_optional&
  budget ();

  void
  budget (const budget_type& x);

  void
  budget (const budget_optional& x);

  void
  budget (::std::unique_ptr< budget_type > p);

  // vatprz
  //
  typedef ::percent_type vatprz_type;
  typedef ::xsd::cxx::tree::optional< vatprz_type > vatprz_optional;
  typedef ::xsd::cxx::tree::traits< vatprz_type, wchar_t > vatprz_traits;

  const vatprz_optional&
  vatprz () const;

  vatprz_optional&
  vatprz ();

  void
  vatprz (const vatprz_type& x);

  void
  vatprz (const vatprz_optional& x);

  void
  vatprz (::std::unique_ptr< vatprz_type > p);

  // desc
  //
  typedef ::xml_schema::string desc_type;
  typedef ::xsd::cxx::tree::optional< desc_type > desc_optional;
  typedef ::xsd::cxx::tree::traits< desc_type, wchar_t > desc_traits;

  const desc_optional&
  desc () const;

  desc_optional&
  desc ();

  void
  desc (const desc_type& x);

  void
  desc (const desc_optional& x);

  void
  desc (::std::unique_ptr< desc_type > p);

  // note
  //
  typedef ::xml_schema::string note_type;
  typedef ::xsd::cxx::tree::optional< note_type > note_optional;
  typedef ::xsd::cxx::tree::traits< note_type, wchar_t > note_traits;

  const note_optional&
  note () const;

  note_optional&
  note ();

  void
  note (const note_type& x);

  void
  note (const note_optional& x);

  void
  note (::std::unique_ptr< note_type > p);

  // remark
  //
  typedef ::xml_schema::string remark_type;
  typedef ::xsd::cxx::tree::optional< remark_type > remark_optional;
  typedef ::xsd::cxx::tree::traits< remark_type, wchar_t > remark_traits;

  const remark_optional&
  remark () const;

  remark_optional&
  remark ();

  void
  remark (const remark_type& x);

  void
  remark (const remark_optional& x);

  void
  remark (::std::unique_ptr< remark_type > p);

  // Constructors.
  //
  ret_revisionitem ();

  ret_revisionitem (const ret_revisionitem& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  virtual ret_revisionitem*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ret_revisionitem&
  operator= (const ret_revisionitem& x);

  virtual 
  ~ret_revisionitem ();

  // Implementation.
  //
  protected:
  id_optional id_;
  orderkey_optional orderkey_;
  ordercode_optional ordercode_;
  ordername_optional ordername_;
  code_optional code_;
  budget_optional budget_;
  vatprz_optional vatprz_;
  desc_optional desc_;
  note_optional note_;
  remark_optional remark_;
};

class bkm_order: public ::xml_schema::type
{
  public:
  // bkm.invoicedef
  //
  typedef ::bkm_invoicedef bkm_invoicedef_type;
  typedef ::xsd::cxx::tree::sequence< bkm_invoicedef_type > bkm_invoicedef_sequence;
  typedef bkm_invoicedef_sequence::iterator bkm_invoicedef_iterator;
  typedef bkm_invoicedef_sequence::const_iterator bkm_invoicedef_const_iterator;
  typedef ::xsd::cxx::tree::traits< bkm_invoicedef_type, wchar_t > bkm_invoicedef_traits;

  const bkm_invoicedef_sequence&
  bkm_invoicedef () const;

  bkm_invoicedef_sequence&
  bkm_invoicedef ();

  void
  bkm_invoicedef (const bkm_invoicedef_sequence& s);

  // bkm.keyvalue
  //
  typedef ::bkm_keyvalue bkm_keyvalue_type;
  typedef ::xsd::cxx::tree::sequence< bkm_keyvalue_type > bkm_keyvalue_sequence;
  typedef bkm_keyvalue_sequence::iterator bkm_keyvalue_iterator;
  typedef bkm_keyvalue_sequence::const_iterator bkm_keyvalue_const_iterator;
  typedef ::xsd::cxx::tree::traits< bkm_keyvalue_type, wchar_t > bkm_keyvalue_traits;

  const bkm_keyvalue_sequence&
  bkm_keyvalue () const;

  bkm_keyvalue_sequence&
  bkm_keyvalue ();

  void
  bkm_keyvalue (const bkm_keyvalue_sequence& s);

  // id
  //
  typedef ::xml_schema::int_ id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  // external
  //
  typedef ::text256_type external_type;
  typedef ::xsd::cxx::tree::optional< external_type > external_optional;
  typedef ::xsd::cxx::tree::traits< external_type, wchar_t > external_traits;

  const external_optional&
  external () const;

  external_optional&
  external ();

  void
  external (const external_type& x);

  void
  external (const external_optional& x);

  void
  external (::std::unique_ptr< external_type > p);

  // externalkey
  //
  typedef ::externalkey_type externalkey_type;
  typedef ::xsd::cxx::tree::traits< externalkey_type, wchar_t > externalkey_traits;

  const externalkey_type&
  externalkey () const;

  externalkey_type&
  externalkey ();

  void
  externalkey (const externalkey_type& x);

  void
  externalkey (::std::unique_ptr< externalkey_type > p);

  // projectkey
  //
  typedef ::externalkey_type projectkey_type;
  typedef ::xsd::cxx::tree::optional< projectkey_type > projectkey_optional;
  typedef ::xsd::cxx::tree::traits< projectkey_type, wchar_t > projectkey_traits;

  const projectkey_optional&
  projectkey () const;

  projectkey_optional&
  projectkey ();

  void
  projectkey (const projectkey_type& x);

  void
  projectkey (const projectkey_optional& x);

  void
  projectkey (::std::unique_ptr< projectkey_type > p);

  // matchfield
  //
  typedef ::matchfieldorder_type matchfield_type;
  typedef ::xsd::cxx::tree::optional< matchfield_type > matchfield_optional;
  typedef ::xsd::cxx::tree::traits< matchfield_type, wchar_t > matchfield_traits;

  const matchfield_optional&
  matchfield () const;

  matchfield_optional&
  matchfield ();

  void
  matchfield (const matchfield_type& x);

  void
  matchfield (const matchfield_optional& x);

  void
  matchfield (::std::unique_ptr< matchfield_type > p);

  // partcode
  //
  typedef ::text32_type partcode_type;
  typedef ::xsd::cxx::tree::optional< partcode_type > partcode_optional;
  typedef ::xsd::cxx::tree::traits< partcode_type, wchar_t > partcode_traits;

  const partcode_optional&
  partcode () const;

  partcode_optional&
  partcode ();

  void
  partcode (const partcode_type& x);

  void
  partcode (const partcode_optional& x);

  void
  partcode (::std::unique_ptr< partcode_type > p);

  // controlcode
  //
  typedef ::text256_type controlcode_type;
  typedef ::xsd::cxx::tree::optional< controlcode_type > controlcode_optional;
  typedef ::xsd::cxx::tree::traits< controlcode_type, wchar_t > controlcode_traits;

  const controlcode_optional&
  controlcode () const;

  controlcode_optional&
  controlcode ();

  void
  controlcode (const controlcode_type& x);

  void
  controlcode (const controlcode_optional& x);

  void
  controlcode (::std::unique_ptr< controlcode_type > p);

  // vendorcode
  //
  typedef ::text64_type vendorcode_type;
  typedef ::xsd::cxx::tree::optional< vendorcode_type > vendorcode_optional;
  typedef ::xsd::cxx::tree::traits< vendorcode_type, wchar_t > vendorcode_traits;

  const vendorcode_optional&
  vendorcode () const;

  vendorcode_optional&
  vendorcode ();

  void
  vendorcode (const vendorcode_type& x);

  void
  vendorcode (const vendorcode_optional& x);

  void
  vendorcode (::std::unique_ptr< vendorcode_type > p);

  // vendorkey
  //
  typedef ::externalkey_type vendorkey_type;
  typedef ::xsd::cxx::tree::optional< vendorkey_type > vendorkey_optional;
  typedef ::xsd::cxx::tree::traits< vendorkey_type, wchar_t > vendorkey_traits;

  const vendorkey_optional&
  vendorkey () const;

  vendorkey_optional&
  vendorkey ();

  void
  vendorkey (const vendorkey_type& x);

  void
  vendorkey (const vendorkey_optional& x);

  void
  vendorkey (::std::unique_ptr< vendorkey_type > p);

  // vendorname
  //
  typedef ::text64_type vendorname_type;
  typedef ::xsd::cxx::tree::optional< vendorname_type > vendorname_optional;
  typedef ::xsd::cxx::tree::traits< vendorname_type, wchar_t > vendorname_traits;

  const vendorname_optional&
  vendorname () const;

  vendorname_optional&
  vendorname ();

  void
  vendorname (const vendorname_type& x);

  void
  vendorname (const vendorname_optional& x);

  void
  vendorname (::std::unique_ptr< vendorname_type > p);

  // vendorname2
  //
  typedef ::text64_type vendorname2_type;
  typedef ::xsd::cxx::tree::optional< vendorname2_type > vendorname2_optional;
  typedef ::xsd::cxx::tree::traits< vendorname2_type, wchar_t > vendorname2_traits;

  const vendorname2_optional&
  vendorname2 () const;

  vendorname2_optional&
  vendorname2 ();

  void
  vendorname2 (const vendorname2_type& x);

  void
  vendorname2 (const vendorname2_optional& x);

  void
  vendorname2 (::std::unique_ptr< vendorname2_type > p);

  // vendorname3
  //
  typedef ::text64_type vendorname3_type;
  typedef ::xsd::cxx::tree::optional< vendorname3_type > vendorname3_optional;
  typedef ::xsd::cxx::tree::traits< vendorname3_type, wchar_t > vendorname3_traits;

  const vendorname3_optional&
  vendorname3 () const;

  vendorname3_optional&
  vendorname3 ();

  void
  vendorname3 (const vendorname3_type& x);

  void
  vendorname3 (const vendorname3_optional& x);

  void
  vendorname3 (::std::unique_ptr< vendorname3_type > p);

  // vendorkeyid
  //
  typedef ::text16_type vendorkeyid_type;
  typedef ::xsd::cxx::tree::optional< vendorkeyid_type > vendorkeyid_optional;
  typedef ::xsd::cxx::tree::traits< vendorkeyid_type, wchar_t > vendorkeyid_traits;

  const vendorkeyid_optional&
  vendorkeyid () const;

  vendorkeyid_optional&
  vendorkeyid ();

  void
  vendorkeyid (const vendorkeyid_type& x);

  void
  vendorkeyid (const vendorkeyid_optional& x);

  void
  vendorkeyid (::std::unique_ptr< vendorkeyid_type > p);

  // placingkey
  //
  typedef ::externalkey_type placingkey_type;
  typedef ::xsd::cxx::tree::optional< placingkey_type > placingkey_optional;
  typedef ::xsd::cxx::tree::traits< placingkey_type, wchar_t > placingkey_traits;

  const placingkey_optional&
  placingkey () const;

  placingkey_optional&
  placingkey ();

  void
  placingkey (const placingkey_type& x);

  void
  placingkey (const placingkey_optional& x);

  void
  placingkey (::std::unique_ptr< placingkey_type > p);

  // placingcode
  //
  typedef ::text16_type placingcode_type;
  typedef ::xsd::cxx::tree::optional< placingcode_type > placingcode_optional;
  typedef ::xsd::cxx::tree::traits< placingcode_type, wchar_t > placingcode_traits;

  const placingcode_optional&
  placingcode () const;

  placingcode_optional&
  placingcode ();

  void
  placingcode (const placingcode_type& x);

  void
  placingcode (const placingcode_optional& x);

  void
  placingcode (::std::unique_ptr< placingcode_type > p);

  // placingname
  //
  typedef ::text64_type placingname_type;
  typedef ::xsd::cxx::tree::optional< placingname_type > placingname_optional;
  typedef ::xsd::cxx::tree::traits< placingname_type, wchar_t > placingname_traits;

  const placingname_optional&
  placingname () const;

  placingname_optional&
  placingname ();

  void
  placingname (const placingname_type& x);

  void
  placingname (const placingname_optional& x);

  void
  placingname (::std::unique_ptr< placingname_type > p);

  // number
  //
  typedef ::text16_type number_type;
  typedef ::xsd::cxx::tree::optional< number_type > number_optional;
  typedef ::xsd::cxx::tree::traits< number_type, wchar_t > number_traits;

  const number_optional&
  number () const;

  number_optional&
  number ();

  void
  number (const number_type& x);

  void
  number (const number_optional& x);

  void
  number (::std::unique_ptr< number_type > p);

  // numbercol
  //
  typedef ::text16_type numbercol_type;
  typedef ::xsd::cxx::tree::optional< numbercol_type > numbercol_optional;
  typedef ::xsd::cxx::tree::traits< numbercol_type, wchar_t > numbercol_traits;

  const numbercol_optional&
  numbercol () const;

  numbercol_optional&
  numbercol ();

  void
  numbercol (const numbercol_type& x);

  void
  numbercol (const numbercol_optional& x);

  void
  numbercol (::std::unique_ptr< numbercol_type > p);

  // order
  //
  typedef ::text128_type order_type;
  typedef ::xsd::cxx::tree::optional< order_type > order_optional;
  typedef ::xsd::cxx::tree::traits< order_type, wchar_t > order_traits;

  const order_optional&
  order () const;

  order_optional&
  order ();

  void
  order (const order_type& x);

  void
  order (const order_optional& x);

  void
  order (::std::unique_ptr< order_type > p);

  // contract
  //
  typedef ::text32_type contract_type;
  typedef ::xsd::cxx::tree::optional< contract_type > contract_optional;
  typedef ::xsd::cxx::tree::traits< contract_type, wchar_t > contract_traits;

  const contract_optional&
  contract () const;

  contract_optional&
  contract ();

  void
  contract (const contract_type& x);

  void
  contract (const contract_optional& x);

  void
  contract (::std::unique_ptr< contract_type > p);

  // extern1
  //
  typedef ::text128_type extern1_type;
  typedef ::xsd::cxx::tree::optional< extern1_type > extern1_optional;
  typedef ::xsd::cxx::tree::traits< extern1_type, wchar_t > extern1_traits;

  const extern1_optional&
  extern1 () const;

  extern1_optional&
  extern1 ();

  void
  extern1 (const extern1_type& x);

  void
  extern1 (const extern1_optional& x);

  void
  extern1 (::std::unique_ptr< extern1_type > p);

  // extern2
  //
  typedef ::text128_type extern2_type;
  typedef ::xsd::cxx::tree::optional< extern2_type > extern2_optional;
  typedef ::xsd::cxx::tree::traits< extern2_type, wchar_t > extern2_traits;

  const extern2_optional&
  extern2 () const;

  extern2_optional&
  extern2 ();

  void
  extern2 (const extern2_type& x);

  void
  extern2 (const extern2_optional& x);

  void
  extern2 (::std::unique_ptr< extern2_type > p);

  // extern3
  //
  typedef ::text128_type extern3_type;
  typedef ::xsd::cxx::tree::optional< extern3_type > extern3_optional;
  typedef ::xsd::cxx::tree::traits< extern3_type, wchar_t > extern3_traits;

  const extern3_optional&
  extern3 () const;

  extern3_optional&
  extern3 ();

  void
  extern3 (const extern3_type& x);

  void
  extern3 (const extern3_optional& x);

  void
  extern3 (::std::unique_ptr< extern3_type > p);

  // currency
  //
  typedef ::text16_type currency_type;
  typedef ::xsd::cxx::tree::optional< currency_type > currency_optional;
  typedef ::xsd::cxx::tree::traits< currency_type, wchar_t > currency_traits;

  const currency_optional&
  currency () const;

  currency_optional&
  currency ();

  void
  currency (const currency_type& x);

  void
  currency (const currency_optional& x);

  void
  currency (::std::unique_ptr< currency_type > p);

  // orderbtr
  //
  typedef ::decimal_type orderbtr_type;
  typedef ::xsd::cxx::tree::optional< orderbtr_type > orderbtr_optional;
  typedef ::xsd::cxx::tree::traits< orderbtr_type, wchar_t > orderbtr_traits;

  const orderbtr_optional&
  orderbtr () const;

  orderbtr_optional&
  orderbtr ();

  void
  orderbtr (const orderbtr_type& x);

  void
  orderbtr (const orderbtr_optional& x);

  void
  orderbtr (::std::unique_ptr< orderbtr_type > p);

  // rebatebtr
  //
  typedef ::decimal_type rebatebtr_type;
  typedef ::xsd::cxx::tree::optional< rebatebtr_type > rebatebtr_optional;
  typedef ::xsd::cxx::tree::traits< rebatebtr_type, wchar_t > rebatebtr_traits;

  const rebatebtr_optional&
  rebatebtr () const;

  rebatebtr_optional&
  rebatebtr ();

  void
  rebatebtr (const rebatebtr_type& x);

  void
  rebatebtr (const rebatebtr_optional& x);

  void
  rebatebtr (::std::unique_ptr< rebatebtr_type > p);

  // orderdate
  //
  typedef ::xml_schema::date orderdate_type;
  typedef ::xsd::cxx::tree::optional< orderdate_type > orderdate_optional;
  typedef ::xsd::cxx::tree::traits< orderdate_type, wchar_t > orderdate_traits;

  const orderdate_optional&
  orderdate () const;

  orderdate_optional&
  orderdate ();

  void
  orderdate (const orderdate_type& x);

  void
  orderdate (const orderdate_optional& x);

  void
  orderdate (::std::unique_ptr< orderdate_type > p);

  // indexdate
  //
  typedef ::xml_schema::date indexdate_type;
  typedef ::xsd::cxx::tree::optional< indexdate_type > indexdate_optional;
  typedef ::xsd::cxx::tree::traits< indexdate_type, wchar_t > indexdate_traits;

  const indexdate_optional&
  indexdate () const;

  indexdate_optional&
  indexdate ();

  void
  indexdate (const indexdate_type& x);

  void
  indexdate (const indexdate_optional& x);

  void
  indexdate (::std::unique_ptr< indexdate_type > p);

  // lstgstart
  //
  typedef ::xml_schema::date lstgstart_type;
  typedef ::xsd::cxx::tree::optional< lstgstart_type > lstgstart_optional;
  typedef ::xsd::cxx::tree::traits< lstgstart_type, wchar_t > lstgstart_traits;

  const lstgstart_optional&
  lstgstart () const;

  lstgstart_optional&
  lstgstart ();

  void
  lstgstart (const lstgstart_type& x);

  void
  lstgstart (const lstgstart_optional& x);

  void
  lstgstart (::std::unique_ptr< lstgstart_type > p);

  // lstgend
  //
  typedef ::xml_schema::date lstgend_type;
  typedef ::xsd::cxx::tree::optional< lstgend_type > lstgend_optional;
  typedef ::xsd::cxx::tree::traits< lstgend_type, wchar_t > lstgend_traits;

  const lstgend_optional&
  lstgend () const;

  lstgend_optional&
  lstgend ();

  void
  lstgend (const lstgend_type& x);

  void
  lstgend (const lstgend_optional& x);

  void
  lstgend (::std::unique_ptr< lstgend_type > p);

  // offerdate
  //
  typedef ::xml_schema::date offerdate_type;
  typedef ::xsd::cxx::tree::optional< offerdate_type > offerdate_optional;
  typedef ::xsd::cxx::tree::traits< offerdate_type, wchar_t > offerdate_traits;

  const offerdate_optional&
  offerdate () const;

  offerdate_optional&
  offerdate ();

  void
  offerdate (const offerdate_type& x);

  void
  offerdate (const offerdate_optional& x);

  void
  offerdate (::std::unique_ptr< offerdate_type > p);

  // liabilityperiod
  //
  typedef ::xml_schema::int_ liabilityperiod_type;
  typedef ::xsd::cxx::tree::optional< liabilityperiod_type > liabilityperiod_optional;
  typedef ::xsd::cxx::tree::traits< liabilityperiod_type, wchar_t > liabilityperiod_traits;

  const liabilityperiod_optional&
  liabilityperiod () const;

  liabilityperiod_optional&
  liabilityperiod ();

  void
  liabilityperiod (const liabilityperiod_type& x);

  void
  liabilityperiod (const liabilityperiod_optional& x);

  // discountprz
  //
  typedef ::percent_type discountprz_type;
  typedef ::xsd::cxx::tree::optional< discountprz_type > discountprz_optional;
  typedef ::xsd::cxx::tree::traits< discountprz_type, wchar_t > discountprz_traits;

  const discountprz_optional&
  discountprz () const;

  discountprz_optional&
  discountprz ();

  void
  discountprz (const discountprz_type& x);

  void
  discountprz (const discountprz_optional& x);

  void
  discountprz (::std::unique_ptr< discountprz_type > p);

  // skontoprz
  //
  typedef ::percent_type skontoprz_type;
  typedef ::xsd::cxx::tree::optional< skontoprz_type > skontoprz_optional;
  typedef ::xsd::cxx::tree::traits< skontoprz_type, wchar_t > skontoprz_traits;

  const skontoprz_optional&
  skontoprz () const;

  skontoprz_optional&
  skontoprz ();

  void
  skontoprz (const skontoprz_type& x);

  void
  skontoprz (const skontoprz_optional& x);

  void
  skontoprz (::std::unique_ptr< skontoprz_type > p);

  // vatprz
  //
  typedef ::percent_type vatprz_type;
  typedef ::xsd::cxx::tree::optional< vatprz_type > vatprz_optional;
  typedef ::xsd::cxx::tree::traits< vatprz_type, wchar_t > vatprz_traits;

  const vatprz_optional&
  vatprz () const;

  vatprz_optional&
  vatprz ();

  void
  vatprz (const vatprz_type& x);

  void
  vatprz (const vatprz_optional& x);

  void
  vatprz (::std::unique_ptr< vatprz_type > p);

  // statuscode
  //
  typedef ::text8_type statuscode_type;
  typedef ::xsd::cxx::tree::optional< statuscode_type > statuscode_optional;
  typedef ::xsd::cxx::tree::traits< statuscode_type, wchar_t > statuscode_traits;

  const statuscode_optional&
  statuscode () const;

  statuscode_optional&
  statuscode ();

  void
  statuscode (const statuscode_type& x);

  void
  statuscode (const statuscode_optional& x);

  void
  statuscode (::std::unique_ptr< statuscode_type > p);

  // statusname
  //
  typedef ::text32_type statusname_type;
  typedef ::xsd::cxx::tree::optional< statusname_type > statusname_optional;
  typedef ::xsd::cxx::tree::traits< statusname_type, wchar_t > statusname_traits;

  const statusname_optional&
  statusname () const;

  statusname_optional&
  statusname ();

  void
  statusname (const statusname_type& x);

  void
  statusname (const statusname_optional& x);

  void
  statusname (::std::unique_ptr< statusname_type > p);

  // groupcode
  //
  typedef ::text8_type groupcode_type;
  typedef ::xsd::cxx::tree::optional< groupcode_type > groupcode_optional;
  typedef ::xsd::cxx::tree::traits< groupcode_type, wchar_t > groupcode_traits;

  const groupcode_optional&
  groupcode () const;

  groupcode_optional&
  groupcode ();

  void
  groupcode (const groupcode_type& x);

  void
  groupcode (const groupcode_optional& x);

  void
  groupcode (::std::unique_ptr< groupcode_type > p);

  // groupname
  //
  typedef ::text64_type groupname_type;
  typedef ::xsd::cxx::tree::optional< groupname_type > groupname_optional;
  typedef ::xsd::cxx::tree::traits< groupname_type, wchar_t > groupname_traits;

  const groupname_optional&
  groupname () const;

  groupname_optional&
  groupname ();

  void
  groupname (const groupname_type& x);

  void
  groupname (const groupname_optional& x);

  void
  groupname (::std::unique_ptr< groupname_type > p);

  // ordertypecode
  //
  typedef ::text16_type ordertypecode_type;
  typedef ::xsd::cxx::tree::optional< ordertypecode_type > ordertypecode_optional;
  typedef ::xsd::cxx::tree::traits< ordertypecode_type, wchar_t > ordertypecode_traits;

  const ordertypecode_optional&
  ordertypecode () const;

  ordertypecode_optional&
  ordertypecode ();

  void
  ordertypecode (const ordertypecode_type& x);

  void
  ordertypecode (const ordertypecode_optional& x);

  void
  ordertypecode (::std::unique_ptr< ordertypecode_type > p);

  // ordertypename
  //
  typedef ::text64_type ordertypename_type;
  typedef ::xsd::cxx::tree::optional< ordertypename_type > ordertypename_optional;
  typedef ::xsd::cxx::tree::traits< ordertypename_type, wchar_t > ordertypename_traits;

  const ordertypename_optional&
  ordertypename () const;

  ordertypename_optional&
  ordertypename ();

  void
  ordertypename (const ordertypename_type& x);

  void
  ordertypename (const ordertypename_optional& x);

  void
  ordertypename (::std::unique_ptr< ordertypename_type > p);

  // userfield1
  //
  typedef ::text256_type userfield1_type;
  typedef ::xsd::cxx::tree::optional< userfield1_type > userfield1_optional;
  typedef ::xsd::cxx::tree::traits< userfield1_type, wchar_t > userfield1_traits;

  const userfield1_optional&
  userfield1 () const;

  userfield1_optional&
  userfield1 ();

  void
  userfield1 (const userfield1_type& x);

  void
  userfield1 (const userfield1_optional& x);

  void
  userfield1 (::std::unique_ptr< userfield1_type > p);

  // userfield2
  //
  typedef ::text256_type userfield2_type;
  typedef ::xsd::cxx::tree::optional< userfield2_type > userfield2_optional;
  typedef ::xsd::cxx::tree::traits< userfield2_type, wchar_t > userfield2_traits;

  const userfield2_optional&
  userfield2 () const;

  userfield2_optional&
  userfield2 ();

  void
  userfield2 (const userfield2_type& x);

  void
  userfield2 (const userfield2_optional& x);

  void
  userfield2 (::std::unique_ptr< userfield2_type > p);

  // userfield3
  //
  typedef ::text256_type userfield3_type;
  typedef ::xsd::cxx::tree::optional< userfield3_type > userfield3_optional;
  typedef ::xsd::cxx::tree::traits< userfield3_type, wchar_t > userfield3_traits;

  const userfield3_optional&
  userfield3 () const;

  userfield3_optional&
  userfield3 ();

  void
  userfield3 (const userfield3_type& x);

  void
  userfield3 (const userfield3_optional& x);

  void
  userfield3 (::std::unique_ptr< userfield3_type > p);

  // desc
  //
  typedef ::xml_schema::string desc_type;
  typedef ::xsd::cxx::tree::optional< desc_type > desc_optional;
  typedef ::xsd::cxx::tree::traits< desc_type, wchar_t > desc_traits;

  const desc_optional&
  desc () const;

  desc_optional&
  desc ();

  void
  desc (const desc_type& x);

  void
  desc (const desc_optional& x);

  void
  desc (::std::unique_ptr< desc_type > p);

  // note
  //
  typedef ::xml_schema::string note_type;
  typedef ::xsd::cxx::tree::optional< note_type > note_optional;
  typedef ::xsd::cxx::tree::traits< note_type, wchar_t > note_traits;

  const note_optional&
  note () const;

  note_optional&
  note ();

  void
  note (const note_type& x);

  void
  note (const note_optional& x);

  void
  note (::std::unique_ptr< note_type > p);

  // remark
  //
  typedef ::xml_schema::string remark_type;
  typedef ::xsd::cxx::tree::optional< remark_type > remark_optional;
  typedef ::xsd::cxx::tree::traits< remark_type, wchar_t > remark_traits;

  const remark_optional&
  remark () const;

  remark_optional&
  remark ();

  void
  remark (const remark_type& x);

  void
  remark (const remark_optional& x);

  void
  remark (::std::unique_ptr< remark_type > p);

  // vatopt
  //
  typedef ::percent_type vatopt_type;
  typedef ::xsd::cxx::tree::optional< vatopt_type > vatopt_optional;
  typedef ::xsd::cxx::tree::traits< vatopt_type, wchar_t > vatopt_traits;

  const vatopt_optional&
  vatopt () const;

  vatopt_optional&
  vatopt ();

  void
  vatopt (const vatopt_type& x);

  void
  vatopt (const vatopt_optional& x);

  void
  vatopt (::std::unique_ptr< vatopt_type > p);

  // collect
  //
  typedef ::collect_type collect_type;
  typedef ::xsd::cxx::tree::optional< collect_type > collect_optional;
  typedef ::xsd::cxx::tree::traits< collect_type, wchar_t > collect_traits;

  const collect_optional&
  collect () const;

  collect_optional&
  collect ();

  void
  collect (const collect_type& x);

  void
  collect (const collect_optional& x);

  void
  collect (::std::unique_ptr< collect_type > p);

  // parentkey
  //
  typedef ::externalkey_type parentkey_type;
  typedef ::xsd::cxx::tree::optional< parentkey_type > parentkey_optional;
  typedef ::xsd::cxx::tree::traits< parentkey_type, wchar_t > parentkey_traits;

  const parentkey_optional&
  parentkey () const;

  parentkey_optional&
  parentkey ();

  void
  parentkey (const parentkey_type& x);

  void
  parentkey (const parentkey_optional& x);

  void
  parentkey (::std::unique_ptr< parentkey_type > p);

  // Constructors.
  //
  bkm_order (const externalkey_type&);

  bkm_order (const bkm_order& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  virtual bkm_order*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  bkm_order&
  operator= (const bkm_order& x);

  virtual 
  ~bkm_order ();

  // Implementation.
  //
  protected:
  bkm_invoicedef_sequence bkm_invoicedef_;
  bkm_keyvalue_sequence bkm_keyvalue_;
  id_optional id_;
  external_optional external_;
  ::xsd::cxx::tree::one< externalkey_type > externalkey_;
  projectkey_optional projectkey_;
  matchfield_optional matchfield_;
  partcode_optional partcode_;
  controlcode_optional controlcode_;
  vendorcode_optional vendorcode_;
  vendorkey_optional vendorkey_;
  vendorname_optional vendorname_;
  vendorname2_optional vendorname2_;
  vendorname3_optional vendorname3_;
  vendorkeyid_optional vendorkeyid_;
  placingkey_optional placingkey_;
  placingcode_optional placingcode_;
  placingname_optional placingname_;
  number_optional number_;
  numbercol_optional numbercol_;
  order_optional order_;
  contract_optional contract_;
  extern1_optional extern1_;
  extern2_optional extern2_;
  extern3_optional extern3_;
  currency_optional currency_;
  orderbtr_optional orderbtr_;
  rebatebtr_optional rebatebtr_;
  orderdate_optional orderdate_;
  indexdate_optional indexdate_;
  lstgstart_optional lstgstart_;
  lstgend_optional lstgend_;
  offerdate_optional offerdate_;
  liabilityperiod_optional liabilityperiod_;
  discountprz_optional discountprz_;
  skontoprz_optional skontoprz_;
  vatprz_optional vatprz_;
  statuscode_optional statuscode_;
  statusname_optional statusname_;
  groupcode_optional groupcode_;
  groupname_optional groupname_;
  ordertypecode_optional ordertypecode_;
  ordertypename_optional ordertypename_;
  userfield1_optional userfield1_;
  userfield2_optional userfield2_;
  userfield3_optional userfield3_;
  desc_optional desc_;
  note_optional note_;
  remark_optional remark_;
  vatopt_optional vatopt_;
  collect_optional collect_;
  parentkey_optional parentkey_;
};

class bkm_addition: public ::xml_schema::type
{
  public:
  // id
  //
  typedef ::xml_schema::int_ id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  // externalkey
  //
  typedef ::externalkey_type externalkey_type;
  typedef ::xsd::cxx::tree::traits< externalkey_type, wchar_t > externalkey_traits;

  const externalkey_type&
  externalkey () const;

  externalkey_type&
  externalkey ();

  void
  externalkey (const externalkey_type& x);

  void
  externalkey (::std::unique_ptr< externalkey_type > p);

  // controlcode
  //
  typedef ::text256_type controlcode_type;
  typedef ::xsd::cxx::tree::optional< controlcode_type > controlcode_optional;
  typedef ::xsd::cxx::tree::traits< controlcode_type, wchar_t > controlcode_traits;

  const controlcode_optional&
  controlcode () const;

  controlcode_optional&
  controlcode ();

  void
  controlcode (const controlcode_type& x);

  void
  controlcode (const controlcode_optional& x);

  void
  controlcode (::std::unique_ptr< controlcode_type > p);

  // matchfield
  //
  typedef ::matchfieldaddition_type matchfield_type;
  typedef ::xsd::cxx::tree::optional< matchfield_type > matchfield_optional;
  typedef ::xsd::cxx::tree::traits< matchfield_type, wchar_t > matchfield_traits;

  const matchfield_optional&
  matchfield () const;

  matchfield_optional&
  matchfield ();

  void
  matchfield (const matchfield_type& x);

  void
  matchfield (const matchfield_optional& x);

  void
  matchfield (::std::unique_ptr< matchfield_type > p);

  // projectkey
  //
  typedef ::externalkey_type projectkey_type;
  typedef ::xsd::cxx::tree::optional< projectkey_type > projectkey_optional;
  typedef ::xsd::cxx::tree::traits< projectkey_type, wchar_t > projectkey_traits;

  const projectkey_optional&
  projectkey () const;

  projectkey_optional&
  projectkey ();

  void
  projectkey (const projectkey_type& x);

  void
  projectkey (const projectkey_optional& x);

  void
  projectkey (::std::unique_ptr< projectkey_type > p);

  // orderkey
  //
  typedef ::externalkey_type orderkey_type;
  typedef ::xsd::cxx::tree::optional< orderkey_type > orderkey_optional;
  typedef ::xsd::cxx::tree::traits< orderkey_type, wchar_t > orderkey_traits;

  const orderkey_optional&
  orderkey () const;

  orderkey_optional&
  orderkey ();

  void
  orderkey (const orderkey_type& x);

  void
  orderkey (const orderkey_optional& x);

  void
  orderkey (::std::unique_ptr< orderkey_type > p);

  // number
  //
  typedef ::text16_type number_type;
  typedef ::xsd::cxx::tree::optional< number_type > number_optional;
  typedef ::xsd::cxx::tree::traits< number_type, wchar_t > number_traits;

  const number_optional&
  number () const;

  number_optional&
  number ();

  void
  number (const number_type& x);

  void
  number (const number_optional& x);

  void
  number (::std::unique_ptr< number_type > p);

  // numberproject
  //
  typedef ::text16_type numberproject_type;
  typedef ::xsd::cxx::tree::optional< numberproject_type > numberproject_optional;
  typedef ::xsd::cxx::tree::traits< numberproject_type, wchar_t > numberproject_traits;

  const numberproject_optional&
  numberproject () const;

  numberproject_optional&
  numberproject ();

  void
  numberproject (const numberproject_type& x);

  void
  numberproject (const numberproject_optional& x);

  void
  numberproject (::std::unique_ptr< numberproject_type > p);

  // addition
  //
  typedef ::text128_type addition_type;
  typedef ::xsd::cxx::tree::optional< addition_type > addition_optional;
  typedef ::xsd::cxx::tree::traits< addition_type, wchar_t > addition_traits;

  const addition_optional&
  addition () const;

  addition_optional&
  addition ();

  void
  addition (const addition_type& x);

  void
  addition (const addition_optional& x);

  void
  addition (::std::unique_ptr< addition_type > p);

  // extern1
  //
  typedef ::text128_type extern1_type;
  typedef ::xsd::cxx::tree::optional< extern1_type > extern1_optional;
  typedef ::xsd::cxx::tree::traits< extern1_type, wchar_t > extern1_traits;

  const extern1_optional&
  extern1 () const;

  extern1_optional&
  extern1 ();

  void
  extern1 (const extern1_type& x);

  void
  extern1 (const extern1_optional& x);

  void
  extern1 (::std::unique_ptr< extern1_type > p);

  // extern2
  //
  typedef ::text128_type extern2_type;
  typedef ::xsd::cxx::tree::optional< extern2_type > extern2_optional;
  typedef ::xsd::cxx::tree::traits< extern2_type, wchar_t > extern2_traits;

  const extern2_optional&
  extern2 () const;

  extern2_optional&
  extern2 ();

  void
  extern2 (const extern2_type& x);

  void
  extern2 (const extern2_optional& x);

  void
  extern2 (::std::unique_ptr< extern2_type > p);

  // extern3
  //
  typedef ::text128_type extern3_type;
  typedef ::xsd::cxx::tree::optional< extern3_type > extern3_optional;
  typedef ::xsd::cxx::tree::traits< extern3_type, wchar_t > extern3_traits;

  const extern3_optional&
  extern3 () const;

  extern3_optional&
  extern3 ();

  void
  extern3 (const extern3_type& x);

  void
  extern3 (const extern3_optional& x);

  void
  extern3 (::std::unique_ptr< extern3_type > p);

  // additionbtr
  //
  typedef ::decimal_type additionbtr_type;
  typedef ::xsd::cxx::tree::optional< additionbtr_type > additionbtr_optional;
  typedef ::xsd::cxx::tree::traits< additionbtr_type, wchar_t > additionbtr_traits;

  const additionbtr_optional&
  additionbtr () const;

  additionbtr_optional&
  additionbtr ();

  void
  additionbtr (const additionbtr_type& x);

  void
  additionbtr (const additionbtr_optional& x);

  void
  additionbtr (::std::unique_ptr< additionbtr_type > p);

  // discountprz
  //
  typedef ::percent_type discountprz_type;
  typedef ::xsd::cxx::tree::optional< discountprz_type > discountprz_optional;
  typedef ::xsd::cxx::tree::traits< discountprz_type, wchar_t > discountprz_traits;

  const discountprz_optional&
  discountprz () const;

  discountprz_optional&
  discountprz ();

  void
  discountprz (const discountprz_type& x);

  void
  discountprz (const discountprz_optional& x);

  void
  discountprz (::std::unique_ptr< discountprz_type > p);

  // orderdate
  //
  typedef ::xml_schema::date orderdate_type;
  typedef ::xsd::cxx::tree::optional< orderdate_type > orderdate_optional;
  typedef ::xsd::cxx::tree::traits< orderdate_type, wchar_t > orderdate_traits;

  const orderdate_optional&
  orderdate () const;

  orderdate_optional&
  orderdate ();

  void
  orderdate (const orderdate_type& x);

  void
  orderdate (const orderdate_optional& x);

  void
  orderdate (::std::unique_ptr< orderdate_type > p);

  // offerdate
  //
  typedef ::xml_schema::date offerdate_type;
  typedef ::xsd::cxx::tree::optional< offerdate_type > offerdate_optional;
  typedef ::xsd::cxx::tree::traits< offerdate_type, wchar_t > offerdate_traits;

  const offerdate_optional&
  offerdate () const;

  offerdate_optional&
  offerdate ();

  void
  offerdate (const offerdate_type& x);

  void
  offerdate (const offerdate_optional& x);

  void
  offerdate (::std::unique_ptr< offerdate_type > p);

  // statuscode
  //
  typedef ::text16_type statuscode_type;
  typedef ::xsd::cxx::tree::optional< statuscode_type > statuscode_optional;
  typedef ::xsd::cxx::tree::traits< statuscode_type, wchar_t > statuscode_traits;

  const statuscode_optional&
  statuscode () const;

  statuscode_optional&
  statuscode ();

  void
  statuscode (const statuscode_type& x);

  void
  statuscode (const statuscode_optional& x);

  void
  statuscode (::std::unique_ptr< statuscode_type > p);

  // statusname
  //
  typedef ::text32_type statusname_type;
  typedef ::xsd::cxx::tree::optional< statusname_type > statusname_optional;
  typedef ::xsd::cxx::tree::traits< statusname_type, wchar_t > statusname_traits;

  const statusname_optional&
  statusname () const;

  statusname_optional&
  statusname ();

  void
  statusname (const statusname_type& x);

  void
  statusname (const statusname_optional& x);

  void
  statusname (::std::unique_ptr< statusname_type > p);

  // groupcode
  //
  typedef ::text16_type groupcode_type;
  typedef ::xsd::cxx::tree::optional< groupcode_type > groupcode_optional;
  typedef ::xsd::cxx::tree::traits< groupcode_type, wchar_t > groupcode_traits;

  const groupcode_optional&
  groupcode () const;

  groupcode_optional&
  groupcode ();

  void
  groupcode (const groupcode_type& x);

  void
  groupcode (const groupcode_optional& x);

  void
  groupcode (::std::unique_ptr< groupcode_type > p);

  // groupname
  //
  typedef ::text64_type groupname_type;
  typedef ::xsd::cxx::tree::optional< groupname_type > groupname_optional;
  typedef ::xsd::cxx::tree::traits< groupname_type, wchar_t > groupname_traits;

  const groupname_optional&
  groupname () const;

  groupname_optional&
  groupname ();

  void
  groupname (const groupname_type& x);

  void
  groupname (const groupname_optional& x);

  void
  groupname (::std::unique_ptr< groupname_type > p);

  // desc
  //
  typedef ::xml_schema::string desc_type;
  typedef ::xsd::cxx::tree::optional< desc_type > desc_optional;
  typedef ::xsd::cxx::tree::traits< desc_type, wchar_t > desc_traits;

  const desc_optional&
  desc () const;

  desc_optional&
  desc ();

  void
  desc (const desc_type& x);

  void
  desc (const desc_optional& x);

  void
  desc (::std::unique_ptr< desc_type > p);

  // note
  //
  typedef ::xml_schema::string note_type;
  typedef ::xsd::cxx::tree::optional< note_type > note_optional;
  typedef ::xsd::cxx::tree::traits< note_type, wchar_t > note_traits;

  const note_optional&
  note () const;

  note_optional&
  note ();

  void
  note (const note_type& x);

  void
  note (const note_optional& x);

  void
  note (::std::unique_ptr< note_type > p);

  // remark
  //
  typedef ::xml_schema::string remark_type;
  typedef ::xsd::cxx::tree::optional< remark_type > remark_optional;
  typedef ::xsd::cxx::tree::traits< remark_type, wchar_t > remark_traits;

  const remark_optional&
  remark () const;

  remark_optional&
  remark ();

  void
  remark (const remark_type& x);

  void
  remark (const remark_optional& x);

  void
  remark (::std::unique_ptr< remark_type > p);

  // Constructors.
  //
  bkm_addition (const externalkey_type&);

  bkm_addition (const bkm_addition& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual bkm_addition*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  bkm_addition&
  operator= (const bkm_addition& x);

  virtual 
  ~bkm_addition ();

  // Implementation.
  //
  protected:
  id_optional id_;
  ::xsd::cxx::tree::one< externalkey_type > externalkey_;
  controlcode_optional controlcode_;
  matchfield_optional matchfield_;
  projectkey_optional projectkey_;
  orderkey_optional orderkey_;
  number_optional number_;
  numberproject_optional numberproject_;
  addition_optional addition_;
  extern1_optional extern1_;
  extern2_optional extern2_;
  extern3_optional extern3_;
  additionbtr_optional additionbtr_;
  discountprz_optional discountprz_;
  orderdate_optional orderdate_;
  offerdate_optional offerdate_;
  statuscode_optional statuscode_;
  statusname_optional statusname_;
  groupcode_optional groupcode_;
  groupname_optional groupname_;
  desc_optional desc_;
  note_optional note_;
  remark_optional remark_;
};

class bkm_evident: public ::xml_schema::type
{
  public:
  // id
  //
  typedef ::xml_schema::int_ id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  // externalkey
  //
  typedef ::externalkey_type externalkey_type;
  typedef ::xsd::cxx::tree::traits< externalkey_type, wchar_t > externalkey_traits;

  const externalkey_type&
  externalkey () const;

  externalkey_type&
  externalkey ();

  void
  externalkey (const externalkey_type& x);

  void
  externalkey (::std::unique_ptr< externalkey_type > p);

  // controlcode
  //
  typedef ::text256_type controlcode_type;
  typedef ::xsd::cxx::tree::optional< controlcode_type > controlcode_optional;
  typedef ::xsd::cxx::tree::traits< controlcode_type, wchar_t > controlcode_traits;

  const controlcode_optional&
  controlcode () const;

  controlcode_optional&
  controlcode ();

  void
  controlcode (const controlcode_type& x);

  void
  controlcode (const controlcode_optional& x);

  void
  controlcode (::std::unique_ptr< controlcode_type > p);

  // matchfield
  //
  typedef ::matchfieldevident_type matchfield_type;
  typedef ::xsd::cxx::tree::optional< matchfield_type > matchfield_optional;
  typedef ::xsd::cxx::tree::traits< matchfield_type, wchar_t > matchfield_traits;

  const matchfield_optional&
  matchfield () const;

  matchfield_optional&
  matchfield ();

  void
  matchfield (const matchfield_type& x);

  void
  matchfield (const matchfield_optional& x);

  void
  matchfield (::std::unique_ptr< matchfield_type > p);

  // projectkey
  //
  typedef ::externalkey_type projectkey_type;
  typedef ::xsd::cxx::tree::optional< projectkey_type > projectkey_optional;
  typedef ::xsd::cxx::tree::traits< projectkey_type, wchar_t > projectkey_traits;

  const projectkey_optional&
  projectkey () const;

  projectkey_optional&
  projectkey ();

  void
  projectkey (const projectkey_type& x);

  void
  projectkey (const projectkey_optional& x);

  void
  projectkey (::std::unique_ptr< projectkey_type > p);

  // orderkey
  //
  typedef ::externalkey_type orderkey_type;
  typedef ::xsd::cxx::tree::optional< orderkey_type > orderkey_optional;
  typedef ::xsd::cxx::tree::traits< orderkey_type, wchar_t > orderkey_traits;

  const orderkey_optional&
  orderkey () const;

  orderkey_optional&
  orderkey ();

  void
  orderkey (const orderkey_type& x);

  void
  orderkey (const orderkey_optional& x);

  void
  orderkey (::std::unique_ptr< orderkey_type > p);

  // number
  //
  typedef ::text16_type number_type;
  typedef ::xsd::cxx::tree::optional< number_type > number_optional;
  typedef ::xsd::cxx::tree::traits< number_type, wchar_t > number_traits;

  const number_optional&
  number () const;

  number_optional&
  number ();

  void
  number (const number_type& x);

  void
  number (const number_optional& x);

  void
  number (::std::unique_ptr< number_type > p);

  // numberproject
  //
  typedef ::text16_type numberproject_type;
  typedef ::xsd::cxx::tree::optional< numberproject_type > numberproject_optional;
  typedef ::xsd::cxx::tree::traits< numberproject_type, wchar_t > numberproject_traits;

  const numberproject_optional&
  numberproject () const;

  numberproject_optional&
  numberproject ();

  void
  numberproject (const numberproject_type& x);

  void
  numberproject (const numberproject_optional& x);

  void
  numberproject (::std::unique_ptr< numberproject_type > p);

  // extern1
  //
  typedef ::text128_type extern1_type;
  typedef ::xsd::cxx::tree::optional< extern1_type > extern1_optional;
  typedef ::xsd::cxx::tree::traits< extern1_type, wchar_t > extern1_traits;

  const extern1_optional&
  extern1 () const;

  extern1_optional&
  extern1 ();

  void
  extern1 (const extern1_type& x);

  void
  extern1 (const extern1_optional& x);

  void
  extern1 (::std::unique_ptr< extern1_type > p);

  // extern2
  //
  typedef ::text128_type extern2_type;
  typedef ::xsd::cxx::tree::optional< extern2_type > extern2_optional;
  typedef ::xsd::cxx::tree::traits< extern2_type, wchar_t > extern2_traits;

  const extern2_optional&
  extern2 () const;

  extern2_optional&
  extern2 ();

  void
  extern2 (const extern2_type& x);

  void
  extern2 (const extern2_optional& x);

  void
  extern2 (::std::unique_ptr< extern2_type > p);

  // extern3
  //
  typedef ::text128_type extern3_type;
  typedef ::xsd::cxx::tree::optional< extern3_type > extern3_optional;
  typedef ::xsd::cxx::tree::traits< extern3_type, wchar_t > extern3_traits;

  const extern3_optional&
  extern3 () const;

  extern3_optional&
  extern3 ();

  void
  extern3 (const extern3_type& x);

  void
  extern3 (const extern3_optional& x);

  void
  extern3 (::std::unique_ptr< extern3_type > p);

  // evident
  //
  typedef ::text128_type evident_type;
  typedef ::xsd::cxx::tree::optional< evident_type > evident_optional;
  typedef ::xsd::cxx::tree::traits< evident_type, wchar_t > evident_traits;

  const evident_optional&
  evident () const;

  evident_optional&
  evident ();

  void
  evident (const evident_type& x);

  void
  evident (const evident_optional& x);

  void
  evident (::std::unique_ptr< evident_type > p);

  // evidentnote
  //
  typedef ::text64_type evidentnote_type;
  typedef ::xsd::cxx::tree::optional< evidentnote_type > evidentnote_optional;
  typedef ::xsd::cxx::tree::traits< evidentnote_type, wchar_t > evidentnote_traits;

  const evidentnote_optional&
  evidentnote () const;

  evidentnote_optional&
  evidentnote ();

  void
  evidentnote (const evidentnote_type& x);

  void
  evidentnote (const evidentnote_optional& x);

  void
  evidentnote (::std::unique_ptr< evidentnote_type > p);

  // evidentbtr
  //
  typedef ::decimal_type evidentbtr_type;
  typedef ::xsd::cxx::tree::optional< evidentbtr_type > evidentbtr_optional;
  typedef ::xsd::cxx::tree::traits< evidentbtr_type, wchar_t > evidentbtr_traits;

  const evidentbtr_optional&
  evidentbtr () const;

  evidentbtr_optional&
  evidentbtr ();

  void
  evidentbtr (const evidentbtr_type& x);

  void
  evidentbtr (const evidentbtr_optional& x);

  void
  evidentbtr (::std::unique_ptr< evidentbtr_type > p);

  // offerbtr
  //
  typedef ::decimal_type offerbtr_type;
  typedef ::xsd::cxx::tree::optional< offerbtr_type > offerbtr_optional;
  typedef ::xsd::cxx::tree::traits< offerbtr_type, wchar_t > offerbtr_traits;

  const offerbtr_optional&
  offerbtr () const;

  offerbtr_optional&
  offerbtr ();

  void
  offerbtr (const offerbtr_type& x);

  void
  offerbtr (const offerbtr_optional& x);

  void
  offerbtr (::std::unique_ptr< offerbtr_type > p);

  // ratedbtr
  //
  typedef ::decimal_type ratedbtr_type;
  typedef ::xsd::cxx::tree::optional< ratedbtr_type > ratedbtr_optional;
  typedef ::xsd::cxx::tree::traits< ratedbtr_type, wchar_t > ratedbtr_traits;

  const ratedbtr_optional&
  ratedbtr () const;

  ratedbtr_optional&
  ratedbtr ();

  void
  ratedbtr (const ratedbtr_type& x);

  void
  ratedbtr (const ratedbtr_optional& x);

  void
  ratedbtr (::std::unique_ptr< ratedbtr_type > p);

  // entrydate
  //
  typedef ::xml_schema::date entrydate_type;
  typedef ::xsd::cxx::tree::optional< entrydate_type > entrydate_optional;
  typedef ::xsd::cxx::tree::traits< entrydate_type, wchar_t > entrydate_traits;

  const entrydate_optional&
  entrydate () const;

  entrydate_optional&
  entrydate ();

  void
  entrydate (const entrydate_type& x);

  void
  entrydate (const entrydate_optional& x);

  void
  entrydate (::std::unique_ptr< entrydate_type > p);

  // signdate
  //
  typedef ::xml_schema::date signdate_type;
  typedef ::xsd::cxx::tree::optional< signdate_type > signdate_optional;
  typedef ::xsd::cxx::tree::traits< signdate_type, wchar_t > signdate_traits;

  const signdate_optional&
  signdate () const;

  signdate_optional&
  signdate ();

  void
  signdate (const signdate_type& x);

  void
  signdate (const signdate_optional& x);

  void
  signdate (::std::unique_ptr< signdate_type > p);

  // statuscode
  //
  typedef ::text16_type statuscode_type;
  typedef ::xsd::cxx::tree::optional< statuscode_type > statuscode_optional;
  typedef ::xsd::cxx::tree::traits< statuscode_type, wchar_t > statuscode_traits;

  const statuscode_optional&
  statuscode () const;

  statuscode_optional&
  statuscode ();

  void
  statuscode (const statuscode_type& x);

  void
  statuscode (const statuscode_optional& x);

  void
  statuscode (::std::unique_ptr< statuscode_type > p);

  // statusname
  //
  typedef ::text32_type statusname_type;
  typedef ::xsd::cxx::tree::optional< statusname_type > statusname_optional;
  typedef ::xsd::cxx::tree::traits< statusname_type, wchar_t > statusname_traits;

  const statusname_optional&
  statusname () const;

  statusname_optional&
  statusname ();

  void
  statusname (const statusname_type& x);

  void
  statusname (const statusname_optional& x);

  void
  statusname (::std::unique_ptr< statusname_type > p);

  // groupcode
  //
  typedef ::text16_type groupcode_type;
  typedef ::xsd::cxx::tree::optional< groupcode_type > groupcode_optional;
  typedef ::xsd::cxx::tree::traits< groupcode_type, wchar_t > groupcode_traits;

  const groupcode_optional&
  groupcode () const;

  groupcode_optional&
  groupcode ();

  void
  groupcode (const groupcode_type& x);

  void
  groupcode (const groupcode_optional& x);

  void
  groupcode (::std::unique_ptr< groupcode_type > p);

  // groupname
  //
  typedef ::text64_type groupname_type;
  typedef ::xsd::cxx::tree::optional< groupname_type > groupname_optional;
  typedef ::xsd::cxx::tree::traits< groupname_type, wchar_t > groupname_traits;

  const groupname_optional&
  groupname () const;

  groupname_optional&
  groupname ();

  void
  groupname (const groupname_type& x);

  void
  groupname (const groupname_optional& x);

  void
  groupname (::std::unique_ptr< groupname_type > p);

  // desc
  //
  typedef ::xml_schema::string desc_type;
  typedef ::xsd::cxx::tree::optional< desc_type > desc_optional;
  typedef ::xsd::cxx::tree::traits< desc_type, wchar_t > desc_traits;

  const desc_optional&
  desc () const;

  desc_optional&
  desc ();

  void
  desc (const desc_type& x);

  void
  desc (const desc_optional& x);

  void
  desc (::std::unique_ptr< desc_type > p);

  // note
  //
  typedef ::xml_schema::string note_type;
  typedef ::xsd::cxx::tree::optional< note_type > note_optional;
  typedef ::xsd::cxx::tree::traits< note_type, wchar_t > note_traits;

  const note_optional&
  note () const;

  note_optional&
  note ();

  void
  note (const note_type& x);

  void
  note (const note_optional& x);

  void
  note (::std::unique_ptr< note_type > p);

  // remark
  //
  typedef ::xml_schema::string remark_type;
  typedef ::xsd::cxx::tree::optional< remark_type > remark_optional;
  typedef ::xsd::cxx::tree::traits< remark_type, wchar_t > remark_traits;

  const remark_optional&
  remark () const;

  remark_optional&
  remark ();

  void
  remark (const remark_type& x);

  void
  remark (const remark_optional& x);

  void
  remark (::std::unique_ptr< remark_type > p);

  // Constructors.
  //
  bkm_evident (const externalkey_type&);

  bkm_evident (const bkm_evident& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  virtual bkm_evident*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  bkm_evident&
  operator= (const bkm_evident& x);

  virtual 
  ~bkm_evident ();

  // Implementation.
  //
  protected:
  id_optional id_;
  ::xsd::cxx::tree::one< externalkey_type > externalkey_;
  controlcode_optional controlcode_;
  matchfield_optional matchfield_;
  projectkey_optional projectkey_;
  orderkey_optional orderkey_;
  number_optional number_;
  numberproject_optional numberproject_;
  extern1_optional extern1_;
  extern2_optional extern2_;
  extern3_optional extern3_;
  evident_optional evident_;
  evidentnote_optional evidentnote_;
  evidentbtr_optional evidentbtr_;
  offerbtr_optional offerbtr_;
  ratedbtr_optional ratedbtr_;
  entrydate_optional entrydate_;
  signdate_optional signdate_;
  statuscode_optional statuscode_;
  statusname_optional statusname_;
  groupcode_optional groupcode_;
  groupname_optional groupname_;
  desc_optional desc_;
  note_optional note_;
  remark_optional remark_;
};

class bkm_backup: public ::xml_schema::type
{
  public:
  // id
  //
  typedef ::xml_schema::int_ id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  // externalkey
  //
  typedef ::externalkey_type externalkey_type;
  typedef ::xsd::cxx::tree::traits< externalkey_type, wchar_t > externalkey_traits;

  const externalkey_type&
  externalkey () const;

  externalkey_type&
  externalkey ();

  void
  externalkey (const externalkey_type& x);

  void
  externalkey (::std::unique_ptr< externalkey_type > p);

  // controlcode
  //
  typedef ::text256_type controlcode_type;
  typedef ::xsd::cxx::tree::optional< controlcode_type > controlcode_optional;
  typedef ::xsd::cxx::tree::traits< controlcode_type, wchar_t > controlcode_traits;

  const controlcode_optional&
  controlcode () const;

  controlcode_optional&
  controlcode ();

  void
  controlcode (const controlcode_type& x);

  void
  controlcode (const controlcode_optional& x);

  void
  controlcode (::std::unique_ptr< controlcode_type > p);

  // matchfield
  //
  typedef ::matchfieldbackup_type matchfield_type;
  typedef ::xsd::cxx::tree::optional< matchfield_type > matchfield_optional;
  typedef ::xsd::cxx::tree::traits< matchfield_type, wchar_t > matchfield_traits;

  const matchfield_optional&
  matchfield () const;

  matchfield_optional&
  matchfield ();

  void
  matchfield (const matchfield_type& x);

  void
  matchfield (const matchfield_optional& x);

  void
  matchfield (::std::unique_ptr< matchfield_type > p);

  // projectkey
  //
  typedef ::externalkey_type projectkey_type;
  typedef ::xsd::cxx::tree::optional< projectkey_type > projectkey_optional;
  typedef ::xsd::cxx::tree::traits< projectkey_type, wchar_t > projectkey_traits;

  const projectkey_optional&
  projectkey () const;

  projectkey_optional&
  projectkey ();

  void
  projectkey (const projectkey_type& x);

  void
  projectkey (const projectkey_optional& x);

  void
  projectkey (::std::unique_ptr< projectkey_type > p);

  // orderkey
  //
  typedef ::externalkey_type orderkey_type;
  typedef ::xsd::cxx::tree::optional< orderkey_type > orderkey_optional;
  typedef ::xsd::cxx::tree::traits< orderkey_type, wchar_t > orderkey_traits;

  const orderkey_optional&
  orderkey () const;

  orderkey_optional&
  orderkey ();

  void
  orderkey (const orderkey_type& x);

  void
  orderkey (const orderkey_optional& x);

  void
  orderkey (::std::unique_ptr< orderkey_type > p);

  // code
  //
  typedef ::text16_type code_type;
  typedef ::xsd::cxx::tree::optional< code_type > code_optional;
  typedef ::xsd::cxx::tree::traits< code_type, wchar_t > code_traits;

  const code_optional&
  code () const;

  code_optional&
  code ();

  void
  code (const code_type& x);

  void
  code (const code_optional& x);

  void
  code (::std::unique_ptr< code_type > p);

  // extern1
  //
  typedef ::text128_type extern1_type;
  typedef ::xsd::cxx::tree::optional< extern1_type > extern1_optional;
  typedef ::xsd::cxx::tree::traits< extern1_type, wchar_t > extern1_traits;

  const extern1_optional&
  extern1 () const;

  extern1_optional&
  extern1 ();

  void
  extern1 (const extern1_type& x);

  void
  extern1 (const extern1_optional& x);

  void
  extern1 (::std::unique_ptr< extern1_type > p);

  // extern2
  //
  typedef ::text128_type extern2_type;
  typedef ::xsd::cxx::tree::optional< extern2_type > extern2_optional;
  typedef ::xsd::cxx::tree::traits< extern2_type, wchar_t > extern2_traits;

  const extern2_optional&
  extern2 () const;

  extern2_optional&
  extern2 ();

  void
  extern2 (const extern2_type& x);

  void
  extern2 (const extern2_optional& x);

  void
  extern2 (::std::unique_ptr< extern2_type > p);

  // extern3
  //
  typedef ::text128_type extern3_type;
  typedef ::xsd::cxx::tree::optional< extern3_type > extern3_optional;
  typedef ::xsd::cxx::tree::traits< extern3_type, wchar_t > extern3_traits;

  const extern3_optional&
  extern3 () const;

  extern3_optional&
  extern3 ();

  void
  extern3 (const extern3_type& x);

  void
  extern3 (const extern3_optional& x);

  void
  extern3 (::std::unique_ptr< extern3_type > p);

  // backup
  //
  typedef ::text64_type backup_type;
  typedef ::xsd::cxx::tree::optional< backup_type > backup_optional;
  typedef ::xsd::cxx::tree::traits< backup_type, wchar_t > backup_traits;

  const backup_optional&
  backup () const;

  backup_optional&
  backup ();

  void
  backup (const backup_type& x);

  void
  backup (const backup_optional& x);

  void
  backup (::std::unique_ptr< backup_type > p);

  // contractid
  //
  typedef ::text32_type contractid_type;
  typedef ::xsd::cxx::tree::optional< contractid_type > contractid_optional;
  typedef ::xsd::cxx::tree::traits< contractid_type, wchar_t > contractid_traits;

  const contractid_optional&
  contractid () const;

  contractid_optional&
  contractid ();

  void
  contractid (const contractid_type& x);

  void
  contractid (const contractid_optional& x);

  void
  contractid (::std::unique_ptr< contractid_type > p);

  // backupbtr
  //
  typedef ::decimal_type backupbtr_type;
  typedef ::xsd::cxx::tree::optional< backupbtr_type > backupbtr_optional;
  typedef ::xsd::cxx::tree::traits< backupbtr_type, wchar_t > backupbtr_traits;

  const backupbtr_optional&
  backupbtr () const;

  backupbtr_optional&
  backupbtr ();

  void
  backupbtr (const backupbtr_type& x);

  void
  backupbtr (const backupbtr_optional& x);

  void
  backupbtr (::std::unique_ptr< backupbtr_type > p);

  // issuedate
  //
  typedef ::xml_schema::date issuedate_type;
  typedef ::xsd::cxx::tree::optional< issuedate_type > issuedate_optional;
  typedef ::xsd::cxx::tree::traits< issuedate_type, wchar_t > issuedate_traits;

  const issuedate_optional&
  issuedate () const;

  issuedate_optional&
  issuedate ();

  void
  issuedate (const issuedate_type& x);

  void
  issuedate (const issuedate_optional& x);

  void
  issuedate (::std::unique_ptr< issuedate_type > p);

  // periodofnotice
  //
  typedef ::xml_schema::date periodofnotice_type;
  typedef ::xsd::cxx::tree::optional< periodofnotice_type > periodofnotice_optional;
  typedef ::xsd::cxx::tree::traits< periodofnotice_type, wchar_t > periodofnotice_traits;

  const periodofnotice_optional&
  periodofnotice () const;

  periodofnotice_optional&
  periodofnotice ();

  void
  periodofnotice (const periodofnotice_type& x);

  void
  periodofnotice (const periodofnotice_optional& x);

  void
  periodofnotice (::std::unique_ptr< periodofnotice_type > p);

  // returndate
  //
  typedef ::xml_schema::date returndate_type;
  typedef ::xsd::cxx::tree::optional< returndate_type > returndate_optional;
  typedef ::xsd::cxx::tree::traits< returndate_type, wchar_t > returndate_traits;

  const returndate_optional&
  returndate () const;

  returndate_optional&
  returndate ();

  void
  returndate (const returndate_type& x);

  void
  returndate (const returndate_optional& x);

  void
  returndate (::std::unique_ptr< returndate_type > p);

  // quitdate
  //
  typedef ::xml_schema::date quitdate_type;
  typedef ::xsd::cxx::tree::optional< quitdate_type > quitdate_optional;
  typedef ::xsd::cxx::tree::traits< quitdate_type, wchar_t > quitdate_traits;

  const quitdate_optional&
  quitdate () const;

  quitdate_optional&
  quitdate ();

  void
  quitdate (const quitdate_type& x);

  void
  quitdate (const quitdate_optional& x);

  void
  quitdate (::std::unique_ptr< quitdate_type > p);

  // validfromdate
  //
  typedef ::xml_schema::date validfromdate_type;
  typedef ::xsd::cxx::tree::optional< validfromdate_type > validfromdate_optional;
  typedef ::xsd::cxx::tree::traits< validfromdate_type, wchar_t > validfromdate_traits;

  const validfromdate_optional&
  validfromdate () const;

  validfromdate_optional&
  validfromdate ();

  void
  validfromdate (const validfromdate_type& x);

  void
  validfromdate (const validfromdate_optional& x);

  void
  validfromdate (::std::unique_ptr< validfromdate_type > p);

  // validtodate
  //
  typedef ::xml_schema::date validtodate_type;
  typedef ::xsd::cxx::tree::optional< validtodate_type > validtodate_optional;
  typedef ::xsd::cxx::tree::traits< validtodate_type, wchar_t > validtodate_traits;

  const validtodate_optional&
  validtodate () const;

  validtodate_optional&
  validtodate ();

  void
  validtodate (const validtodate_type& x);

  void
  validtodate (const validtodate_optional& x);

  void
  validtodate (::std::unique_ptr< validtodate_type > p);

  // warrantyfromdate
  //
  typedef ::xml_schema::date warrantyfromdate_type;
  typedef ::xsd::cxx::tree::optional< warrantyfromdate_type > warrantyfromdate_optional;
  typedef ::xsd::cxx::tree::traits< warrantyfromdate_type, wchar_t > warrantyfromdate_traits;

  const warrantyfromdate_optional&
  warrantyfromdate () const;

  warrantyfromdate_optional&
  warrantyfromdate ();

  void
  warrantyfromdate (const warrantyfromdate_type& x);

  void
  warrantyfromdate (const warrantyfromdate_optional& x);

  void
  warrantyfromdate (::std::unique_ptr< warrantyfromdate_type > p);

  // warrantytodate
  //
  typedef ::xml_schema::date warrantytodate_type;
  typedef ::xsd::cxx::tree::optional< warrantytodate_type > warrantytodate_optional;
  typedef ::xsd::cxx::tree::traits< warrantytodate_type, wchar_t > warrantytodate_traits;

  const warrantytodate_optional&
  warrantytodate () const;

  warrantytodate_optional&
  warrantytodate ();

  void
  warrantytodate (const warrantytodate_type& x);

  void
  warrantytodate (const warrantytodate_optional& x);

  void
  warrantytodate (::std::unique_ptr< warrantytodate_type > p);

  // account
  //
  typedef ::text32_type account_type;
  typedef ::xsd::cxx::tree::optional< account_type > account_optional;
  typedef ::xsd::cxx::tree::traits< account_type, wchar_t > account_traits;

  const account_optional&
  account () const;

  account_optional&
  account ();

  void
  account (const account_type& x);

  void
  account (const account_optional& x);

  void
  account (::std::unique_ptr< account_type > p);

  // iban
  //
  typedef ::text48_type iban_type;
  typedef ::xsd::cxx::tree::optional< iban_type > iban_optional;
  typedef ::xsd::cxx::tree::traits< iban_type, wchar_t > iban_traits;

  const iban_optional&
  iban () const;

  iban_optional&
  iban ();

  void
  iban (const iban_type& x);

  void
  iban (const iban_optional& x);

  void
  iban (::std::unique_ptr< iban_type > p);

  // bankkey
  //
  typedef ::text256_type bankkey_type;
  typedef ::xsd::cxx::tree::optional< bankkey_type > bankkey_optional;
  typedef ::xsd::cxx::tree::traits< bankkey_type, wchar_t > bankkey_traits;

  const bankkey_optional&
  bankkey () const;

  bankkey_optional&
  bankkey ();

  void
  bankkey (const bankkey_type& x);

  void
  bankkey (const bankkey_optional& x);

  void
  bankkey (::std::unique_ptr< bankkey_type > p);

  // bankswift
  //
  typedef ::text12_type bankswift_type;
  typedef ::xsd::cxx::tree::optional< bankswift_type > bankswift_optional;
  typedef ::xsd::cxx::tree::traits< bankswift_type, wchar_t > bankswift_traits;

  const bankswift_optional&
  bankswift () const;

  bankswift_optional&
  bankswift ();

  void
  bankswift (const bankswift_type& x);

  void
  bankswift (const bankswift_optional& x);

  void
  bankswift (::std::unique_ptr< bankswift_type > p);

  // typecode
  //
  typedef ::text16_type typecode_type;
  typedef ::xsd::cxx::tree::optional< typecode_type > typecode_optional;
  typedef ::xsd::cxx::tree::traits< typecode_type, wchar_t > typecode_traits;

  const typecode_optional&
  typecode () const;

  typecode_optional&
  typecode ();

  void
  typecode (const typecode_type& x);

  void
  typecode (const typecode_optional& x);

  void
  typecode (::std::unique_ptr< typecode_type > p);

  // typename
  //
  typedef ::text64_type typename_type;
  typedef ::xsd::cxx::tree::optional< typename_type > typename_optional;
  typedef ::xsd::cxx::tree::traits< typename_type, wchar_t > typename_traits;

  const typename_optional&
  typename_ () const;

  typename_optional&
  typename_ ();

  void
  typename_ (const typename_type& x);

  void
  typename_ (const typename_optional& x);

  void
  typename_ (::std::unique_ptr< typename_type > p);

  // statuscode
  //
  typedef ::text16_type statuscode_type;
  typedef ::xsd::cxx::tree::optional< statuscode_type > statuscode_optional;
  typedef ::xsd::cxx::tree::traits< statuscode_type, wchar_t > statuscode_traits;

  const statuscode_optional&
  statuscode () const;

  statuscode_optional&
  statuscode ();

  void
  statuscode (const statuscode_type& x);

  void
  statuscode (const statuscode_optional& x);

  void
  statuscode (::std::unique_ptr< statuscode_type > p);

  // statusname
  //
  typedef ::text32_type statusname_type;
  typedef ::xsd::cxx::tree::optional< statusname_type > statusname_optional;
  typedef ::xsd::cxx::tree::traits< statusname_type, wchar_t > statusname_traits;

  const statusname_optional&
  statusname () const;

  statusname_optional&
  statusname ();

  void
  statusname (const statusname_type& x);

  void
  statusname (const statusname_optional& x);

  void
  statusname (::std::unique_ptr< statusname_type > p);

  // groupcode
  //
  typedef ::text16_type groupcode_type;
  typedef ::xsd::cxx::tree::optional< groupcode_type > groupcode_optional;
  typedef ::xsd::cxx::tree::traits< groupcode_type, wchar_t > groupcode_traits;

  const groupcode_optional&
  groupcode () const;

  groupcode_optional&
  groupcode ();

  void
  groupcode (const groupcode_type& x);

  void
  groupcode (const groupcode_optional& x);

  void
  groupcode (::std::unique_ptr< groupcode_type > p);

  // groupname
  //
  typedef ::text64_type groupname_type;
  typedef ::xsd::cxx::tree::optional< groupname_type > groupname_optional;
  typedef ::xsd::cxx::tree::traits< groupname_type, wchar_t > groupname_traits;

  const groupname_optional&
  groupname () const;

  groupname_optional&
  groupname ();

  void
  groupname (const groupname_type& x);

  void
  groupname (const groupname_optional& x);

  void
  groupname (::std::unique_ptr< groupname_type > p);

  // desc
  //
  typedef ::xml_schema::string desc_type;
  typedef ::xsd::cxx::tree::optional< desc_type > desc_optional;
  typedef ::xsd::cxx::tree::traits< desc_type, wchar_t > desc_traits;

  const desc_optional&
  desc () const;

  desc_optional&
  desc ();

  void
  desc (const desc_type& x);

  void
  desc (const desc_optional& x);

  void
  desc (::std::unique_ptr< desc_type > p);

  // note
  //
  typedef ::xml_schema::string note_type;
  typedef ::xsd::cxx::tree::optional< note_type > note_optional;
  typedef ::xsd::cxx::tree::traits< note_type, wchar_t > note_traits;

  const note_optional&
  note () const;

  note_optional&
  note ();

  void
  note (const note_type& x);

  void
  note (const note_optional& x);

  void
  note (::std::unique_ptr< note_type > p);

  // remark
  //
  typedef ::xml_schema::string remark_type;
  typedef ::xsd::cxx::tree::optional< remark_type > remark_optional;
  typedef ::xsd::cxx::tree::traits< remark_type, wchar_t > remark_traits;

  const remark_optional&
  remark () const;

  remark_optional&
  remark ();

  void
  remark (const remark_type& x);

  void
  remark (const remark_optional& x);

  void
  remark (::std::unique_ptr< remark_type > p);

  // Constructors.
  //
  bkm_backup (const externalkey_type&);

  bkm_backup (const bkm_backup& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual bkm_backup*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  bkm_backup&
  operator= (const bkm_backup& x);

  virtual 
  ~bkm_backup ();

  // Implementation.
  //
  protected:
  id_optional id_;
  ::xsd::cxx::tree::one< externalkey_type > externalkey_;
  controlcode_optional controlcode_;
  matchfield_optional matchfield_;
  projectkey_optional projectkey_;
  orderkey_optional orderkey_;
  code_optional code_;
  extern1_optional extern1_;
  extern2_optional extern2_;
  extern3_optional extern3_;
  backup_optional backup_;
  contractid_optional contractid_;
  backupbtr_optional backupbtr_;
  issuedate_optional issuedate_;
  periodofnotice_optional periodofnotice_;
  returndate_optional returndate_;
  quitdate_optional quitdate_;
  validfromdate_optional validfromdate_;
  validtodate_optional validtodate_;
  warrantyfromdate_optional warrantyfromdate_;
  warrantytodate_optional warrantytodate_;
  account_optional account_;
  iban_optional iban_;
  bankkey_optional bankkey_;
  bankswift_optional bankswift_;
  typecode_optional typecode_;
  typename_optional typename__;
  statuscode_optional statuscode_;
  statusname_optional statusname_;
  groupcode_optional groupcode_;
  groupname_optional groupname_;
  desc_optional desc_;
  note_optional note_;
  remark_optional remark_;
};

class bkm_invdeftype: public ::xml_schema::type
{
  public:
  // code
  //
  typedef ::text32_type code_type;
  typedef ::xsd::cxx::tree::optional< code_type > code_optional;
  typedef ::xsd::cxx::tree::traits< code_type, wchar_t > code_traits;

  const code_optional&
  code () const;

  code_optional&
  code ();

  void
  code (const code_type& x);

  void
  code (const code_optional& x);

  void
  code (::std::unique_ptr< code_type > p);

  // invoicedef
  //
  typedef ::text64_type invoicedef_type;
  typedef ::xsd::cxx::tree::traits< invoicedef_type, wchar_t > invoicedef_traits;

  const invoicedef_type&
  invoicedef () const;

  invoicedef_type&
  invoicedef ();

  void
  invoicedef (const invoicedef_type& x);

  void
  invoicedef (::std::unique_ptr< invoicedef_type > p);

  // valueprz
  //
  typedef ::percent_type valueprz_type;
  typedef ::xsd::cxx::tree::optional< valueprz_type > valueprz_optional;
  typedef ::xsd::cxx::tree::traits< valueprz_type, wchar_t > valueprz_traits;

  const valueprz_optional&
  valueprz () const;

  valueprz_optional&
  valueprz ();

  void
  valueprz (const valueprz_type& x);

  void
  valueprz (const valueprz_optional& x);

  void
  valueprz (::std::unique_ptr< valueprz_type > p);

  // Constructors.
  //
  bkm_invdeftype (const invoicedef_type&);

  bkm_invdeftype (const bkm_invdeftype& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  virtual bkm_invdeftype*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  bkm_invdeftype&
  operator= (const bkm_invdeftype& x);

  virtual 
  ~bkm_invdeftype ();

  // Implementation.
  //
  protected:
  code_optional code_;
  ::xsd::cxx::tree::one< invoicedef_type > invoicedef_;
  valueprz_optional valueprz_;
};

class bkm_invoice: public ::xml_schema::type
{
  public:
  // bkm.invoicepos
  //
  typedef ::bkm_invoicepos bkm_invoicepos_type;
  typedef ::xsd::cxx::tree::sequence< bkm_invoicepos_type > bkm_invoicepos_sequence;
  typedef bkm_invoicepos_sequence::iterator bkm_invoicepos_iterator;
  typedef bkm_invoicepos_sequence::const_iterator bkm_invoicepos_const_iterator;
  typedef ::xsd::cxx::tree::traits< bkm_invoicepos_type, wchar_t > bkm_invoicepos_traits;

  const bkm_invoicepos_sequence&
  bkm_invoicepos () const;

  bkm_invoicepos_sequence&
  bkm_invoicepos ();

  void
  bkm_invoicepos (const bkm_invoicepos_sequence& s);

  // bkm.splitinvoice
  //
  typedef ::bkm_splitinvoice bkm_splitinvoice_type;
  typedef ::xsd::cxx::tree::sequence< bkm_splitinvoice_type > bkm_splitinvoice_sequence;
  typedef bkm_splitinvoice_sequence::iterator bkm_splitinvoice_iterator;
  typedef bkm_splitinvoice_sequence::const_iterator bkm_splitinvoice_const_iterator;
  typedef ::xsd::cxx::tree::traits< bkm_splitinvoice_type, wchar_t > bkm_splitinvoice_traits;

  const bkm_splitinvoice_sequence&
  bkm_splitinvoice () const;

  bkm_splitinvoice_sequence&
  bkm_splitinvoice ();

  void
  bkm_splitinvoice (const bkm_splitinvoice_sequence& s);

  // id
  //
  typedef ::xml_schema::int_ id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  // externalkey
  //
  typedef ::externalkey_type externalkey_type;
  typedef ::xsd::cxx::tree::traits< externalkey_type, wchar_t > externalkey_traits;

  const externalkey_type&
  externalkey () const;

  externalkey_type&
  externalkey ();

  void
  externalkey (const externalkey_type& x);

  void
  externalkey (::std::unique_ptr< externalkey_type > p);

  // matchfield
  //
  typedef ::matchfieldinvoice_type matchfield_type;
  typedef ::xsd::cxx::tree::optional< matchfield_type > matchfield_optional;
  typedef ::xsd::cxx::tree::traits< matchfield_type, wchar_t > matchfield_traits;

  const matchfield_optional&
  matchfield () const;

  matchfield_optional&
  matchfield ();

  void
  matchfield (const matchfield_type& x);

  void
  matchfield (const matchfield_optional& x);

  void
  matchfield (::std::unique_ptr< matchfield_type > p);

  // partcode
  //
  typedef ::text32_type partcode_type;
  typedef ::xsd::cxx::tree::optional< partcode_type > partcode_optional;
  typedef ::xsd::cxx::tree::traits< partcode_type, wchar_t > partcode_traits;

  const partcode_optional&
  partcode () const;

  partcode_optional&
  partcode ();

  void
  partcode (const partcode_type& x);

  void
  partcode (const partcode_optional& x);

  void
  partcode (::std::unique_ptr< partcode_type > p);

  // controlcode
  //
  typedef ::text256_type controlcode_type;
  typedef ::xsd::cxx::tree::optional< controlcode_type > controlcode_optional;
  typedef ::xsd::cxx::tree::traits< controlcode_type, wchar_t > controlcode_traits;

  const controlcode_optional&
  controlcode () const;

  controlcode_optional&
  controlcode ();

  void
  controlcode (const controlcode_type& x);

  void
  controlcode (const controlcode_optional& x);

  void
  controlcode (::std::unique_ptr< controlcode_type > p);

  // projectkey
  //
  typedef ::externalkey_type projectkey_type;
  typedef ::xsd::cxx::tree::optional< projectkey_type > projectkey_optional;
  typedef ::xsd::cxx::tree::traits< projectkey_type, wchar_t > projectkey_traits;

  const projectkey_optional&
  projectkey () const;

  projectkey_optional&
  projectkey ();

  void
  projectkey (const projectkey_type& x);

  void
  projectkey (const projectkey_optional& x);

  void
  projectkey (::std::unique_ptr< projectkey_type > p);

  // orderkey
  //
  typedef ::externalkey_type orderkey_type;
  typedef ::xsd::cxx::tree::optional< orderkey_type > orderkey_optional;
  typedef ::xsd::cxx::tree::traits< orderkey_type, wchar_t > orderkey_traits;

  const orderkey_optional&
  orderkey () const;

  orderkey_optional&
  orderkey ();

  void
  orderkey (const orderkey_type& x);

  void
  orderkey (const orderkey_optional& x);

  void
  orderkey (::std::unique_ptr< orderkey_type > p);

  // external
  //
  typedef ::text256_type external_type;
  typedef ::xsd::cxx::tree::optional< external_type > external_optional;
  typedef ::xsd::cxx::tree::traits< external_type, wchar_t > external_traits;

  const external_optional&
  external () const;

  external_optional&
  external ();

  void
  external (const external_type& x);

  void
  external (const external_optional& x);

  void
  external (::std::unique_ptr< external_type > p);

  // calculation
  //
  typedef ::text256_type calculation_type;
  typedef ::xsd::cxx::tree::optional< calculation_type > calculation_optional;
  typedef ::xsd::cxx::tree::traits< calculation_type, wchar_t > calculation_traits;

  const calculation_optional&
  calculation () const;

  calculation_optional&
  calculation ();

  void
  calculation (const calculation_type& x);

  void
  calculation (const calculation_optional& x);

  void
  calculation (::std::unique_ptr< calculation_type > p);

  // typecode
  //
  typedef ::invoicetype_type typecode_type;
  typedef ::xsd::cxx::tree::optional< typecode_type > typecode_optional;
  typedef ::xsd::cxx::tree::traits< typecode_type, wchar_t > typecode_traits;

  const typecode_optional&
  typecode () const;

  typecode_optional&
  typecode ();

  void
  typecode (const typecode_type& x);

  void
  typecode (const typecode_optional& x);

  void
  typecode (::std::unique_ptr< typecode_type > p);

  // typecount
  //
  typedef ::xml_schema::short_ typecount_type;
  typedef ::xsd::cxx::tree::optional< typecount_type > typecount_optional;
  typedef ::xsd::cxx::tree::traits< typecount_type, wchar_t > typecount_traits;

  const typecount_optional&
  typecount () const;

  typecount_optional&
  typecount ();

  void
  typecount (const typecount_type& x);

  void
  typecount (const typecount_optional& x);

  // number
  //
  typedef ::text32_type number_type;
  typedef ::xsd::cxx::tree::optional< number_type > number_optional;
  typedef ::xsd::cxx::tree::traits< number_type, wchar_t > number_traits;

  const number_optional&
  number () const;

  number_optional&
  number ();

  void
  number (const number_type& x);

  void
  number (const number_optional& x);

  void
  number (::std::unique_ptr< number_type > p);

  // numbercol
  //
  typedef ::text32_type numbercol_type;
  typedef ::xsd::cxx::tree::optional< numbercol_type > numbercol_optional;
  typedef ::xsd::cxx::tree::traits< numbercol_type, wchar_t > numbercol_traits;

  const numbercol_optional&
  numbercol () const;

  numbercol_optional&
  numbercol ();

  void
  numbercol (const numbercol_type& x);

  void
  numbercol (const numbercol_optional& x);

  void
  numbercol (::std::unique_ptr< numbercol_type > p);

  // invoicedate
  //
  typedef ::xml_schema::date invoicedate_type;
  typedef ::xsd::cxx::tree::optional< invoicedate_type > invoicedate_optional;
  typedef ::xsd::cxx::tree::traits< invoicedate_type, wchar_t > invoicedate_traits;

  const invoicedate_optional&
  invoicedate () const;

  invoicedate_optional&
  invoicedate ();

  void
  invoicedate (const invoicedate_type& x);

  void
  invoicedate (const invoicedate_optional& x);

  void
  invoicedate (::std::unique_ptr< invoicedate_type > p);

  // entrydate
  //
  typedef ::xml_schema::date entrydate_type;
  typedef ::xsd::cxx::tree::optional< entrydate_type > entrydate_optional;
  typedef ::xsd::cxx::tree::traits< entrydate_type, wchar_t > entrydate_traits;

  const entrydate_optional&
  entrydate () const;

  entrydate_optional&
  entrydate ();

  void
  entrydate (const entrydate_type& x);

  void
  entrydate (const entrydate_optional& x);

  void
  entrydate (::std::unique_ptr< entrydate_type > p);

  // entry2date
  //
  typedef ::xml_schema::date entry2date_type;
  typedef ::xsd::cxx::tree::optional< entry2date_type > entry2date_optional;
  typedef ::xsd::cxx::tree::traits< entry2date_type, wchar_t > entry2date_traits;

  const entry2date_optional&
  entry2date () const;

  entry2date_optional&
  entry2date ();

  void
  entry2date (const entry2date_type& x);

  void
  entry2date (const entry2date_optional& x);

  void
  entry2date (::std::unique_ptr< entry2date_type > p);

  // verifydate
  //
  typedef ::xml_schema::date verifydate_type;
  typedef ::xsd::cxx::tree::optional< verifydate_type > verifydate_optional;
  typedef ::xsd::cxx::tree::traits< verifydate_type, wchar_t > verifydate_traits;

  const verifydate_optional&
  verifydate () const;

  verifydate_optional&
  verifydate ();

  void
  verifydate (const verifydate_type& x);

  void
  verifydate (const verifydate_optional& x);

  void
  verifydate (::std::unique_ptr< verifydate_type > p);

  // discountdate
  //
  typedef ::xml_schema::date discountdate_type;
  typedef ::xsd::cxx::tree::optional< discountdate_type > discountdate_optional;
  typedef ::xsd::cxx::tree::traits< discountdate_type, wchar_t > discountdate_traits;

  const discountdate_optional&
  discountdate () const;

  discountdate_optional&
  discountdate ();

  void
  discountdate (const discountdate_type& x);

  void
  discountdate (const discountdate_optional& x);

  void
  discountdate (::std::unique_ptr< discountdate_type > p);

  // discountnto
  //
  typedef ::decimal_type discountnto_type;
  typedef ::xsd::cxx::tree::optional< discountnto_type > discountnto_optional;
  typedef ::xsd::cxx::tree::traits< discountnto_type, wchar_t > discountnto_traits;

  const discountnto_optional&
  discountnto () const;

  discountnto_optional&
  discountnto ();

  void
  discountnto (const discountnto_type& x);

  void
  discountnto (const discountnto_optional& x);

  void
  discountnto (::std::unique_ptr< discountnto_type > p);

  // agingdate
  //
  typedef ::xml_schema::date agingdate_type;
  typedef ::xsd::cxx::tree::optional< agingdate_type > agingdate_optional;
  typedef ::xsd::cxx::tree::traits< agingdate_type, wchar_t > agingdate_traits;

  const agingdate_optional&
  agingdate () const;

  agingdate_optional&
  agingdate ();

  void
  agingdate (const agingdate_type& x);

  void
  agingdate (const agingdate_optional& x);

  void
  agingdate (::std::unique_ptr< agingdate_type > p);

  // respitedate
  //
  typedef ::xml_schema::date respitedate_type;
  typedef ::xsd::cxx::tree::optional< respitedate_type > respitedate_optional;
  typedef ::xsd::cxx::tree::traits< respitedate_type, wchar_t > respitedate_traits;

  const respitedate_optional&
  respitedate () const;

  respitedate_optional&
  respitedate ();

  void
  respitedate (const respitedate_type& x);

  void
  respitedate (const respitedate_optional& x);

  void
  respitedate (::std::unique_ptr< respitedate_type > p);

  // extern1
  //
  typedef ::text128_type extern1_type;
  typedef ::xsd::cxx::tree::optional< extern1_type > extern1_optional;
  typedef ::xsd::cxx::tree::traits< extern1_type, wchar_t > extern1_traits;

  const extern1_optional&
  extern1 () const;

  extern1_optional&
  extern1 ();

  void
  extern1 (const extern1_type& x);

  void
  extern1 (const extern1_optional& x);

  void
  extern1 (::std::unique_ptr< extern1_type > p);

  // extern2
  //
  typedef ::text128_type extern2_type;
  typedef ::xsd::cxx::tree::optional< extern2_type > extern2_optional;
  typedef ::xsd::cxx::tree::traits< extern2_type, wchar_t > extern2_traits;

  const extern2_optional&
  extern2 () const;

  extern2_optional&
  extern2 ();

  void
  extern2 (const extern2_type& x);

  void
  extern2 (const extern2_optional& x);

  void
  extern2 (::std::unique_ptr< extern2_type > p);

  // extern3
  //
  typedef ::text128_type extern3_type;
  typedef ::xsd::cxx::tree::optional< extern3_type > extern3_optional;
  typedef ::xsd::cxx::tree::traits< extern3_type, wchar_t > extern3_traits;

  const extern3_optional&
  extern3 () const;

  extern3_optional&
  extern3 ();

  void
  extern3 (const extern3_type& x);

  void
  extern3 (const extern3_optional& x);

  void
  extern3 (::std::unique_ptr< extern3_type > p);

  // range
  //
  typedef ::text16_type range_type;
  typedef ::xsd::cxx::tree::optional< range_type > range_optional;
  typedef ::xsd::cxx::tree::traits< range_type, wchar_t > range_traits;

  const range_optional&
  range () const;

  range_optional&
  range ();

  void
  range (const range_type& x);

  void
  range (const range_optional& x);

  void
  range (::std::unique_ptr< range_type > p);

  // period
  //
  typedef ::text128_type period_type;
  typedef ::xsd::cxx::tree::optional< period_type > period_optional;
  typedef ::xsd::cxx::tree::traits< period_type, wchar_t > period_traits;

  const period_optional&
  period () const;

  period_optional&
  period ();

  void
  period (const period_type& x);

  void
  period (const period_optional& x);

  void
  period (::std::unique_ptr< period_type > p);

  // barcode
  //
  typedef ::text128_type barcode_type;
  typedef ::xsd::cxx::tree::optional< barcode_type > barcode_optional;
  typedef ::xsd::cxx::tree::traits< barcode_type, wchar_t > barcode_traits;

  const barcode_optional&
  barcode () const;

  barcode_optional&
  barcode ();

  void
  barcode (const barcode_type& x);

  void
  barcode (const barcode_optional& x);

  void
  barcode (::std::unique_ptr< barcode_type > p);

  // verifier
  //
  typedef ::text32_type verifier_type;
  typedef ::xsd::cxx::tree::optional< verifier_type > verifier_optional;
  typedef ::xsd::cxx::tree::traits< verifier_type, wchar_t > verifier_traits;

  const verifier_optional&
  verifier () const;

  verifier_optional&
  verifier ();

  void
  verifier (const verifier_type& x);

  void
  verifier (const verifier_optional& x);

  void
  verifier (::std::unique_ptr< verifier_type > p);

  // statuscode
  //
  typedef ::text16_type statuscode_type;
  typedef ::xsd::cxx::tree::optional< statuscode_type > statuscode_optional;
  typedef ::xsd::cxx::tree::traits< statuscode_type, wchar_t > statuscode_traits;

  const statuscode_optional&
  statuscode () const;

  statuscode_optional&
  statuscode ();

  void
  statuscode (const statuscode_type& x);

  void
  statuscode (const statuscode_optional& x);

  void
  statuscode (::std::unique_ptr< statuscode_type > p);

  // statusname
  //
  typedef ::text32_type statusname_type;
  typedef ::xsd::cxx::tree::optional< statusname_type > statusname_optional;
  typedef ::xsd::cxx::tree::traits< statusname_type, wchar_t > statusname_traits;

  const statusname_optional&
  statusname () const;

  statusname_optional&
  statusname ();

  void
  statusname (const statusname_type& x);

  void
  statusname (const statusname_optional& x);

  void
  statusname (::std::unique_ptr< statusname_type > p);

  // groupcode
  //
  typedef ::text8_type groupcode_type;
  typedef ::xsd::cxx::tree::optional< groupcode_type > groupcode_optional;
  typedef ::xsd::cxx::tree::traits< groupcode_type, wchar_t > groupcode_traits;

  const groupcode_optional&
  groupcode () const;

  groupcode_optional&
  groupcode ();

  void
  groupcode (const groupcode_type& x);

  void
  groupcode (const groupcode_optional& x);

  void
  groupcode (::std::unique_ptr< groupcode_type > p);

  // groupname
  //
  typedef ::text64_type groupname_type;
  typedef ::xsd::cxx::tree::optional< groupname_type > groupname_optional;
  typedef ::xsd::cxx::tree::traits< groupname_type, wchar_t > groupname_traits;

  const groupname_optional&
  groupname () const;

  groupname_optional&
  groupname ();

  void
  groupname (const groupname_type& x);

  void
  groupname (const groupname_optional& x);

  void
  groupname (::std::unique_ptr< groupname_type > p);

  // totalnto
  //
  typedef ::decimal_type totalnto_type;
  typedef ::xsd::cxx::tree::optional< totalnto_type > totalnto_optional;
  typedef ::xsd::cxx::tree::traits< totalnto_type, wchar_t > totalnto_traits;

  const totalnto_optional&
  totalnto () const;

  totalnto_optional&
  totalnto ();

  void
  totalnto (const totalnto_type& x);

  void
  totalnto (const totalnto_optional& x);

  void
  totalnto (::std::unique_ptr< totalnto_type > p);

  // ntoverified
  //
  typedef ::decimal_type ntoverified_type;
  typedef ::xsd::cxx::tree::optional< ntoverified_type > ntoverified_optional;
  typedef ::xsd::cxx::tree::traits< ntoverified_type, wchar_t > ntoverified_traits;

  const ntoverified_optional&
  ntoverified () const;

  ntoverified_optional&
  ntoverified ();

  void
  ntoverified (const ntoverified_type& x);

  void
  ntoverified (const ntoverified_optional& x);

  void
  ntoverified (::std::unique_ptr< ntoverified_type > p);

  // amountnto
  //
  typedef ::decimal_type amountnto_type;
  typedef ::xsd::cxx::tree::optional< amountnto_type > amountnto_optional;
  typedef ::xsd::cxx::tree::traits< amountnto_type, wchar_t > amountnto_traits;

  const amountnto_optional&
  amountnto () const;

  amountnto_optional&
  amountnto ();

  void
  amountnto (const amountnto_type& x);

  void
  amountnto (const amountnto_optional& x);

  void
  amountnto (::std::unique_ptr< amountnto_type > p);

  // deducted
  //
  typedef ::decimal_type deducted_type;
  typedef ::xsd::cxx::tree::optional< deducted_type > deducted_optional;
  typedef ::xsd::cxx::tree::traits< deducted_type, wchar_t > deducted_traits;

  const deducted_optional&
  deducted () const;

  deducted_optional&
  deducted ();

  void
  deducted (const deducted_type& x);

  void
  deducted (const deducted_optional& x);

  void
  deducted (::std::unique_ptr< deducted_type > p);

  // deductedvat
  //
  typedef ::decimal_type deductedvat_type;
  typedef ::xsd::cxx::tree::optional< deductedvat_type > deductedvat_optional;
  typedef ::xsd::cxx::tree::traits< deductedvat_type, wchar_t > deductedvat_traits;

  const deductedvat_optional&
  deductedvat () const;

  deductedvat_optional&
  deductedvat ();

  void
  deductedvat (const deductedvat_type& x);

  void
  deductedvat (const deductedvat_optional& x);

  void
  deductedvat (::std::unique_ptr< deductedvat_type > p);

  // anwbtr
  //
  typedef ::decimal_type anwbtr_type;
  typedef ::xsd::cxx::tree::optional< anwbtr_type > anwbtr_optional;
  typedef ::xsd::cxx::tree::traits< anwbtr_type, wchar_t > anwbtr_traits;

  const anwbtr_optional&
  anwbtr () const;

  anwbtr_optional&
  anwbtr ();

  void
  anwbtr (const anwbtr_type& x);

  void
  anwbtr (const anwbtr_optional& x);

  void
  anwbtr (::std::unique_ptr< anwbtr_type > p);

  // anwbtrnto
  //
  typedef ::decimal_type anwbtrnto_type;
  typedef ::xsd::cxx::tree::optional< anwbtrnto_type > anwbtrnto_optional;
  typedef ::xsd::cxx::tree::traits< anwbtrnto_type, wchar_t > anwbtrnto_traits;

  const anwbtrnto_optional&
  anwbtrnto () const;

  anwbtrnto_optional&
  anwbtrnto ();

  void
  anwbtrnto (const anwbtrnto_type& x);

  void
  anwbtrnto (const anwbtrnto_optional& x);

  void
  anwbtrnto (::std::unique_ptr< anwbtrnto_type > p);

  // anwskobtr
  //
  typedef ::decimal_type anwskobtr_type;
  typedef ::xsd::cxx::tree::optional< anwskobtr_type > anwskobtr_optional;
  typedef ::xsd::cxx::tree::traits< anwskobtr_type, wchar_t > anwskobtr_traits;

  const anwskobtr_optional&
  anwskobtr () const;

  anwskobtr_optional&
  anwskobtr ();

  void
  anwskobtr (const anwskobtr_type& x);

  void
  anwskobtr (const anwskobtr_optional& x);

  void
  anwskobtr (::std::unique_ptr< anwskobtr_type > p);

  // anwskonto
  //
  typedef ::decimal_type anwskonto_type;
  typedef ::xsd::cxx::tree::optional< anwskonto_type > anwskonto_optional;
  typedef ::xsd::cxx::tree::traits< anwskonto_type, wchar_t > anwskonto_traits;

  const anwskonto_optional&
  anwskonto () const;

  anwskonto_optional&
  anwskonto ();

  void
  anwskonto (const anwskonto_type& x);

  void
  anwskonto (const anwskonto_optional& x);

  void
  anwskonto (::std::unique_ptr< anwskonto_type > p);

  // vatbtr
  //
  typedef ::decimal_type vatbtr_type;
  typedef ::xsd::cxx::tree::optional< vatbtr_type > vatbtr_optional;
  typedef ::xsd::cxx::tree::traits< vatbtr_type, wchar_t > vatbtr_traits;

  const vatbtr_optional&
  vatbtr () const;

  vatbtr_optional&
  vatbtr ();

  void
  vatbtr (const vatbtr_type& x);

  void
  vatbtr (const vatbtr_optional& x);

  void
  vatbtr (::std::unique_ptr< vatbtr_type > p);

  // vatprz
  //
  typedef ::percent_type vatprz_type;
  typedef ::xsd::cxx::tree::optional< vatprz_type > vatprz_optional;
  typedef ::xsd::cxx::tree::traits< vatprz_type, wchar_t > vatprz_traits;

  const vatprz_optional&
  vatprz () const;

  vatprz_optional&
  vatprz ();

  void
  vatprz (const vatprz_type& x);

  void
  vatprz (const vatprz_optional& x);

  void
  vatprz (::std::unique_ptr< vatprz_type > p);

  // skontobto
  //
  typedef ::decimal_type skontobto_type;
  typedef ::xsd::cxx::tree::optional< skontobto_type > skontobto_optional;
  typedef ::xsd::cxx::tree::traits< skontobto_type, wchar_t > skontobto_traits;

  const skontobto_optional&
  skontobto () const;

  skontobto_optional&
  skontobto ();

  void
  skontobto (const skontobto_type& x);

  void
  skontobto (const skontobto_optional& x);

  void
  skontobto (::std::unique_ptr< skontobto_type > p);

  // skontonto
  //
  typedef ::decimal_type skontonto_type;
  typedef ::xsd::cxx::tree::optional< skontonto_type > skontonto_optional;
  typedef ::xsd::cxx::tree::traits< skontonto_type, wchar_t > skontonto_traits;

  const skontonto_optional&
  skontonto () const;

  skontonto_optional&
  skontonto ();

  void
  skontonto (const skontonto_type& x);

  void
  skontonto (const skontonto_optional& x);

  void
  skontonto (::std::unique_ptr< skontonto_type > p);

  // skontoprz
  //
  typedef ::percent_type skontoprz_type;
  typedef ::xsd::cxx::tree::optional< skontoprz_type > skontoprz_optional;
  typedef ::xsd::cxx::tree::traits< skontoprz_type, wchar_t > skontoprz_traits;

  const skontoprz_optional&
  skontoprz () const;

  skontoprz_optional&
  skontoprz ();

  void
  skontoprz (const skontoprz_type& x);

  void
  skontoprz (const skontoprz_optional& x);

  void
  skontoprz (::std::unique_ptr< skontoprz_type > p);

  // drl
  //
  typedef ::decimal_type drl_type;
  typedef ::xsd::cxx::tree::optional< drl_type > drl_optional;
  typedef ::xsd::cxx::tree::traits< drl_type, wchar_t > drl_traits;

  const drl_optional&
  drl () const;

  drl_optional&
  drl ();

  void
  drl (const drl_type& x);

  void
  drl (const drl_optional& x);

  void
  drl (::std::unique_ptr< drl_type > p);

  // drlvat
  //
  typedef ::decimal_type drlvat_type;
  typedef ::xsd::cxx::tree::optional< drlvat_type > drlvat_optional;
  typedef ::xsd::cxx::tree::traits< drlvat_type, wchar_t > drlvat_traits;

  const drlvat_optional&
  drlvat () const;

  drlvat_optional&
  drlvat ();

  void
  drlvat (const drlvat_type& x);

  void
  drlvat (const drlvat_optional& x);

  void
  drlvat (::std::unique_ptr< drlvat_type > p);

  // drlprz
  //
  typedef ::percent_type drlprz_type;
  typedef ::xsd::cxx::tree::optional< drlprz_type > drlprz_optional;
  typedef ::xsd::cxx::tree::traits< drlprz_type, wchar_t > drlprz_traits;

  const drlprz_optional&
  drlprz () const;

  drlprz_optional&
  drlprz ();

  void
  drlprz (const drlprz_type& x);

  void
  drlprz (const drlprz_optional& x);

  void
  drlprz (::std::unique_ptr< drlprz_type > p);

  // drlsurety
  //
  typedef ::decimal_type drlsurety_type;
  typedef ::xsd::cxx::tree::optional< drlsurety_type > drlsurety_optional;
  typedef ::xsd::cxx::tree::traits< drlsurety_type, wchar_t > drlsurety_traits;

  const drlsurety_optional&
  drlsurety () const;

  drlsurety_optional&
  drlsurety ();

  void
  drlsurety (const drlsurety_type& x);

  void
  drlsurety (const drlsurety_optional& x);

  void
  drlsurety (::std::unique_ptr< drlsurety_type > p);

  // drlsuretyvat
  //
  typedef ::decimal_type drlsuretyvat_type;
  typedef ::xsd::cxx::tree::optional< drlsuretyvat_type > drlsuretyvat_optional;
  typedef ::xsd::cxx::tree::traits< drlsuretyvat_type, wchar_t > drlsuretyvat_traits;

  const drlsuretyvat_optional&
  drlsuretyvat () const;

  drlsuretyvat_optional&
  drlsuretyvat ();

  void
  drlsuretyvat (const drlsuretyvat_type& x);

  void
  drlsuretyvat (const drlsuretyvat_optional& x);

  void
  drlsuretyvat (::std::unique_ptr< drlsuretyvat_type > p);

  // hrl
  //
  typedef ::decimal_type hrl_type;
  typedef ::xsd::cxx::tree::optional< hrl_type > hrl_optional;
  typedef ::xsd::cxx::tree::traits< hrl_type, wchar_t > hrl_traits;

  const hrl_optional&
  hrl () const;

  hrl_optional&
  hrl ();

  void
  hrl (const hrl_type& x);

  void
  hrl (const hrl_optional& x);

  void
  hrl (::std::unique_ptr< hrl_type > p);

  // hrlvat
  //
  typedef ::decimal_type hrlvat_type;
  typedef ::xsd::cxx::tree::optional< hrlvat_type > hrlvat_optional;
  typedef ::xsd::cxx::tree::traits< hrlvat_type, wchar_t > hrlvat_traits;

  const hrlvat_optional&
  hrlvat () const;

  hrlvat_optional&
  hrlvat ();

  void
  hrlvat (const hrlvat_type& x);

  void
  hrlvat (const hrlvat_optional& x);

  void
  hrlvat (::std::unique_ptr< hrlvat_type > p);

  // hrlprz
  //
  typedef ::percent_type hrlprz_type;
  typedef ::xsd::cxx::tree::optional< hrlprz_type > hrlprz_optional;
  typedef ::xsd::cxx::tree::traits< hrlprz_type, wchar_t > hrlprz_traits;

  const hrlprz_optional&
  hrlprz () const;

  hrlprz_optional&
  hrlprz ();

  void
  hrlprz (const hrlprz_type& x);

  void
  hrlprz (const hrlprz_optional& x);

  void
  hrlprz (::std::unique_ptr< hrlprz_type > p);

  // hrlsurety
  //
  typedef ::decimal_type hrlsurety_type;
  typedef ::xsd::cxx::tree::optional< hrlsurety_type > hrlsurety_optional;
  typedef ::xsd::cxx::tree::traits< hrlsurety_type, wchar_t > hrlsurety_traits;

  const hrlsurety_optional&
  hrlsurety () const;

  hrlsurety_optional&
  hrlsurety ();

  void
  hrlsurety (const hrlsurety_type& x);

  void
  hrlsurety (const hrlsurety_optional& x);

  void
  hrlsurety (::std::unique_ptr< hrlsurety_type > p);

  // hrlsuretyvat
  //
  typedef ::decimal_type hrlsuretyvat_type;
  typedef ::xsd::cxx::tree::optional< hrlsuretyvat_type > hrlsuretyvat_optional;
  typedef ::xsd::cxx::tree::traits< hrlsuretyvat_type, wchar_t > hrlsuretyvat_traits;

  const hrlsuretyvat_optional&
  hrlsuretyvat () const;

  hrlsuretyvat_optional&
  hrlsuretyvat ();

  void
  hrlsuretyvat (const hrlsuretyvat_type& x);

  void
  hrlsuretyvat (const hrlsuretyvat_optional& x);

  void
  hrlsuretyvat (::std::unique_ptr< hrlsuretyvat_type > p);

  // userfield1
  //
  typedef ::text256_type userfield1_type;
  typedef ::xsd::cxx::tree::optional< userfield1_type > userfield1_optional;
  typedef ::xsd::cxx::tree::traits< userfield1_type, wchar_t > userfield1_traits;

  const userfield1_optional&
  userfield1 () const;

  userfield1_optional&
  userfield1 ();

  void
  userfield1 (const userfield1_type& x);

  void
  userfield1 (const userfield1_optional& x);

  void
  userfield1 (::std::unique_ptr< userfield1_type > p);

  // userfield2
  //
  typedef ::text256_type userfield2_type;
  typedef ::xsd::cxx::tree::optional< userfield2_type > userfield2_optional;
  typedef ::xsd::cxx::tree::traits< userfield2_type, wchar_t > userfield2_traits;

  const userfield2_optional&
  userfield2 () const;

  userfield2_optional&
  userfield2 ();

  void
  userfield2 (const userfield2_type& x);

  void
  userfield2 (const userfield2_optional& x);

  void
  userfield2 (::std::unique_ptr< userfield2_type > p);

  // userfield3
  //
  typedef ::text256_type userfield3_type;
  typedef ::xsd::cxx::tree::optional< userfield3_type > userfield3_optional;
  typedef ::xsd::cxx::tree::traits< userfield3_type, wchar_t > userfield3_traits;

  const userfield3_optional&
  userfield3 () const;

  userfield3_optional&
  userfield3 ();

  void
  userfield3 (const userfield3_type& x);

  void
  userfield3 (const userfield3_optional& x);

  void
  userfield3 (::std::unique_ptr< userfield3_type > p);

  // custom1
  //
  typedef ::text128_type custom1_type;
  typedef ::xsd::cxx::tree::optional< custom1_type > custom1_optional;
  typedef ::xsd::cxx::tree::traits< custom1_type, wchar_t > custom1_traits;

  const custom1_optional&
  custom1 () const;

  custom1_optional&
  custom1 ();

  void
  custom1 (const custom1_type& x);

  void
  custom1 (const custom1_optional& x);

  void
  custom1 (::std::unique_ptr< custom1_type > p);

  // custom2
  //
  typedef ::text128_type custom2_type;
  typedef ::xsd::cxx::tree::optional< custom2_type > custom2_optional;
  typedef ::xsd::cxx::tree::traits< custom2_type, wchar_t > custom2_traits;

  const custom2_optional&
  custom2 () const;

  custom2_optional&
  custom2 ();

  void
  custom2 (const custom2_type& x);

  void
  custom2 (const custom2_optional& x);

  void
  custom2 (::std::unique_ptr< custom2_type > p);

  // custom3
  //
  typedef ::text128_type custom3_type;
  typedef ::xsd::cxx::tree::optional< custom3_type > custom3_optional;
  typedef ::xsd::cxx::tree::traits< custom3_type, wchar_t > custom3_traits;

  const custom3_optional&
  custom3 () const;

  custom3_optional&
  custom3 ();

  void
  custom3 (const custom3_type& x);

  void
  custom3 (const custom3_optional& x);

  void
  custom3 (::std::unique_ptr< custom3_type > p);

  // custom4
  //
  typedef ::text128_type custom4_type;
  typedef ::xsd::cxx::tree::optional< custom4_type > custom4_optional;
  typedef ::xsd::cxx::tree::traits< custom4_type, wchar_t > custom4_traits;

  const custom4_optional&
  custom4 () const;

  custom4_optional&
  custom4 ();

  void
  custom4 (const custom4_type& x);

  void
  custom4 (const custom4_optional& x);

  void
  custom4 (::std::unique_ptr< custom4_type > p);

  // custom5
  //
  typedef ::text128_type custom5_type;
  typedef ::xsd::cxx::tree::optional< custom5_type > custom5_optional;
  typedef ::xsd::cxx::tree::traits< custom5_type, wchar_t > custom5_traits;

  const custom5_optional&
  custom5 () const;

  custom5_optional&
  custom5 ();

  void
  custom5 (const custom5_type& x);

  void
  custom5 (const custom5_optional& x);

  void
  custom5 (::std::unique_ptr< custom5_type > p);

  // desc
  //
  typedef ::xml_schema::string desc_type;
  typedef ::xsd::cxx::tree::optional< desc_type > desc_optional;
  typedef ::xsd::cxx::tree::traits< desc_type, wchar_t > desc_traits;

  const desc_optional&
  desc () const;

  desc_optional&
  desc ();

  void
  desc (const desc_type& x);

  void
  desc (const desc_optional& x);

  void
  desc (::std::unique_ptr< desc_type > p);

  // note
  //
  typedef ::xml_schema::string note_type;
  typedef ::xsd::cxx::tree::optional< note_type > note_optional;
  typedef ::xsd::cxx::tree::traits< note_type, wchar_t > note_traits;

  const note_optional&
  note () const;

  note_optional&
  note ();

  void
  note (const note_type& x);

  void
  note (const note_optional& x);

  void
  note (::std::unique_ptr< note_type > p);

  // remark
  //
  typedef ::xml_schema::string remark_type;
  typedef ::xsd::cxx::tree::optional< remark_type > remark_optional;
  typedef ::xsd::cxx::tree::traits< remark_type, wchar_t > remark_traits;

  const remark_optional&
  remark () const;

  remark_optional&
  remark ();

  void
  remark (const remark_type& x);

  void
  remark (const remark_optional& x);

  void
  remark (::std::unique_ptr< remark_type > p);

  // liabilityperiod1
  //
  typedef ::xml_schema::int_ liabilityperiod1_type;
  typedef ::xsd::cxx::tree::optional< liabilityperiod1_type > liabilityperiod1_optional;
  typedef ::xsd::cxx::tree::traits< liabilityperiod1_type, wchar_t > liabilityperiod1_traits;

  const liabilityperiod1_optional&
  liabilityperiod1 () const;

  liabilityperiod1_optional&
  liabilityperiod1 ();

  void
  liabilityperiod1 (const liabilityperiod1_type& x);

  void
  liabilityperiod1 (const liabilityperiod1_optional& x);

  // collect
  //
  typedef ::collect_type collect_type;
  typedef ::xsd::cxx::tree::optional< collect_type > collect_optional;
  typedef ::xsd::cxx::tree::traits< collect_type, wchar_t > collect_traits;

  const collect_optional&
  collect () const;

  collect_optional&
  collect ();

  void
  collect (const collect_type& x);

  void
  collect (const collect_optional& x);

  void
  collect (::std::unique_ptr< collect_type > p);

  // parentkey
  //
  typedef ::externalkey_type parentkey_type;
  typedef ::xsd::cxx::tree::optional< parentkey_type > parentkey_optional;
  typedef ::xsd::cxx::tree::traits< parentkey_type, wchar_t > parentkey_traits;

  const parentkey_optional&
  parentkey () const;

  parentkey_optional&
  parentkey ();

  void
  parentkey (const parentkey_type& x);

  void
  parentkey (const parentkey_optional& x);

  void
  parentkey (::std::unique_ptr< parentkey_type > p);

  // Constructors.
  //
  bkm_invoice (const externalkey_type&);

  bkm_invoice (const bkm_invoice& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  virtual bkm_invoice*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  bkm_invoice&
  operator= (const bkm_invoice& x);

  virtual 
  ~bkm_invoice ();

  // Implementation.
  //
  protected:
  bkm_invoicepos_sequence bkm_invoicepos_;
  bkm_splitinvoice_sequence bkm_splitinvoice_;
  id_optional id_;
  ::xsd::cxx::tree::one< externalkey_type > externalkey_;
  matchfield_optional matchfield_;
  partcode_optional partcode_;
  controlcode_optional controlcode_;
  projectkey_optional projectkey_;
  orderkey_optional orderkey_;
  external_optional external_;
  calculation_optional calculation_;
  typecode_optional typecode_;
  typecount_optional typecount_;
  number_optional number_;
  numbercol_optional numbercol_;
  invoicedate_optional invoicedate_;
  entrydate_optional entrydate_;
  entry2date_optional entry2date_;
  verifydate_optional verifydate_;
  discountdate_optional discountdate_;
  discountnto_optional discountnto_;
  agingdate_optional agingdate_;
  respitedate_optional respitedate_;
  extern1_optional extern1_;
  extern2_optional extern2_;
  extern3_optional extern3_;
  range_optional range_;
  period_optional period_;
  barcode_optional barcode_;
  verifier_optional verifier_;
  statuscode_optional statuscode_;
  statusname_optional statusname_;
  groupcode_optional groupcode_;
  groupname_optional groupname_;
  totalnto_optional totalnto_;
  ntoverified_optional ntoverified_;
  amountnto_optional amountnto_;
  deducted_optional deducted_;
  deductedvat_optional deductedvat_;
  anwbtr_optional anwbtr_;
  anwbtrnto_optional anwbtrnto_;
  anwskobtr_optional anwskobtr_;
  anwskonto_optional anwskonto_;
  vatbtr_optional vatbtr_;
  vatprz_optional vatprz_;
  skontobto_optional skontobto_;
  skontonto_optional skontonto_;
  skontoprz_optional skontoprz_;
  drl_optional drl_;
  drlvat_optional drlvat_;
  drlprz_optional drlprz_;
  drlsurety_optional drlsurety_;
  drlsuretyvat_optional drlsuretyvat_;
  hrl_optional hrl_;
  hrlvat_optional hrlvat_;
  hrlprz_optional hrlprz_;
  hrlsurety_optional hrlsurety_;
  hrlsuretyvat_optional hrlsuretyvat_;
  userfield1_optional userfield1_;
  userfield2_optional userfield2_;
  userfield3_optional userfield3_;
  custom1_optional custom1_;
  custom2_optional custom2_;
  custom3_optional custom3_;
  custom4_optional custom4_;
  custom5_optional custom5_;
  desc_optional desc_;
  note_optional note_;
  remark_optional remark_;
  liabilityperiod1_optional liabilityperiod1_;
  collect_optional collect_;
  parentkey_optional parentkey_;
};

class bkm_invoicedef: public ::xml_schema::type
{
  public:
  // bkm.invdeftype
  //
  typedef ::bkm_invdeftype bkm_invdeftype_type;
  typedef ::xsd::cxx::tree::sequence< bkm_invdeftype_type > bkm_invdeftype_sequence;
  typedef bkm_invdeftype_sequence::iterator bkm_invdeftype_iterator;
  typedef bkm_invdeftype_sequence::const_iterator bkm_invdeftype_const_iterator;
  typedef ::xsd::cxx::tree::traits< bkm_invdeftype_type, wchar_t > bkm_invdeftype_traits;

  const bkm_invdeftype_sequence&
  bkm_invdeftype () const;

  bkm_invdeftype_sequence&
  bkm_invdeftype ();

  void
  bkm_invdeftype (const bkm_invdeftype_sequence& s);

  // typecode
  //
  typedef ::invoicetype_type typecode_type;
  typedef ::xsd::cxx::tree::traits< typecode_type, wchar_t > typecode_traits;

  const typecode_type&
  typecode () const;

  typecode_type&
  typecode ();

  void
  typecode (const typecode_type& x);

  void
  typecode (::std::unique_ptr< typecode_type > p);

  // skontoperiod
  //
  typedef ::text16_type skontoperiod_type;
  typedef ::xsd::cxx::tree::optional< skontoperiod_type > skontoperiod_optional;
  typedef ::xsd::cxx::tree::traits< skontoperiod_type, wchar_t > skontoperiod_traits;

  const skontoperiod_optional&
  skontoperiod () const;

  skontoperiod_optional&
  skontoperiod ();

  void
  skontoperiod (const skontoperiod_type& x);

  void
  skontoperiod (const skontoperiod_optional& x);

  void
  skontoperiod (::std::unique_ptr< skontoperiod_type > p);

  // checkperiod
  //
  typedef ::text16_type checkperiod_type;
  typedef ::xsd::cxx::tree::optional< checkperiod_type > checkperiod_optional;
  typedef ::xsd::cxx::tree::traits< checkperiod_type, wchar_t > checkperiod_traits;

  const checkperiod_optional&
  checkperiod () const;

  checkperiod_optional&
  checkperiod ();

  void
  checkperiod (const checkperiod_type& x);

  void
  checkperiod (const checkperiod_optional& x);

  void
  checkperiod (::std::unique_ptr< checkperiod_type > p);

  // spanunitcode
  //
  typedef ::text16_type spanunitcode_type;
  typedef ::xsd::cxx::tree::optional< spanunitcode_type > spanunitcode_optional;
  typedef ::xsd::cxx::tree::traits< spanunitcode_type, wchar_t > spanunitcode_traits;

  const spanunitcode_optional&
  spanunitcode () const;

  spanunitcode_optional&
  spanunitcode ();

  void
  spanunitcode (const spanunitcode_type& x);

  void
  spanunitcode (const spanunitcode_optional& x);

  void
  spanunitcode (::std::unique_ptr< spanunitcode_type > p);

  // Constructors.
  //
  bkm_invoicedef (const typecode_type&);

  bkm_invoicedef (const bkm_invoicedef& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  virtual bkm_invoicedef*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  bkm_invoicedef&
  operator= (const bkm_invoicedef& x);

  virtual 
  ~bkm_invoicedef ();

  // Implementation.
  //
  protected:
  bkm_invdeftype_sequence bkm_invdeftype_;
  ::xsd::cxx::tree::one< typecode_type > typecode_;
  skontoperiod_optional skontoperiod_;
  checkperiod_optional checkperiod_;
  spanunitcode_optional spanunitcode_;
};

class bkm_invoicepos: public ::xml_schema::type
{
  public:
  // id
  //
  typedef ::xml_schema::int_ id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  // code
  //
  typedef ::text32_type code_type;
  typedef ::xsd::cxx::tree::optional< code_type > code_optional;
  typedef ::xsd::cxx::tree::traits< code_type, wchar_t > code_traits;

  const code_optional&
  code () const;

  code_optional&
  code ();

  void
  code (const code_type& x);

  void
  code (const code_optional& x);

  void
  code (::std::unique_ptr< code_type > p);

  // sortid
  //
  typedef ::xml_schema::int_ sortid_type;
  typedef ::xsd::cxx::tree::optional< sortid_type > sortid_optional;
  typedef ::xsd::cxx::tree::traits< sortid_type, wchar_t > sortid_traits;

  const sortid_optional&
  sortid () const;

  sortid_optional&
  sortid ();

  void
  sortid (const sortid_type& x);

  void
  sortid (const sortid_optional& x);

  // invoicedeftype
  //
  typedef ::text64_type invoicedeftype_type;
  typedef ::xsd::cxx::tree::optional< invoicedeftype_type > invoicedeftype_optional;
  typedef ::xsd::cxx::tree::traits< invoicedeftype_type, wchar_t > invoicedeftype_traits;

  const invoicedeftype_optional&
  invoicedeftype () const;

  invoicedeftype_optional&
  invoicedeftype ();

  void
  invoicedeftype (const invoicedeftype_type& x);

  void
  invoicedeftype (const invoicedeftype_optional& x);

  void
  invoicedeftype (::std::unique_ptr< invoicedeftype_type > p);

  // current
  //
  typedef ::decimal_type current_type;
  typedef ::xsd::cxx::tree::optional< current_type > current_optional;
  typedef ::xsd::cxx::tree::traits< current_type, wchar_t > current_traits;

  const current_optional&
  current () const;

  current_optional&
  current ();

  void
  current (const current_type& x);

  void
  current (const current_optional& x);

  void
  current (::std::unique_ptr< current_type > p);

  // totalvalue
  //
  typedef ::decimal_type totalvalue_type;
  typedef ::xsd::cxx::tree::optional< totalvalue_type > totalvalue_optional;
  typedef ::xsd::cxx::tree::traits< totalvalue_type, wchar_t > totalvalue_traits;

  const totalvalue_optional&
  totalvalue () const;

  totalvalue_optional&
  totalvalue ();

  void
  totalvalue (const totalvalue_type& x);

  void
  totalvalue (const totalvalue_optional& x);

  void
  totalvalue (::std::unique_ptr< totalvalue_type > p);

  // valuento
  //
  typedef ::decimal_type valuento_type;
  typedef ::xsd::cxx::tree::optional< valuento_type > valuento_optional;
  typedef ::xsd::cxx::tree::traits< valuento_type, wchar_t > valuento_traits;

  const valuento_optional&
  valuento () const;

  valuento_optional&
  valuento ();

  void
  valuento (const valuento_type& x);

  void
  valuento (const valuento_optional& x);

  void
  valuento (::std::unique_ptr< valuento_type > p);

  // valuevat
  //
  typedef ::decimal_type valuevat_type;
  typedef ::xsd::cxx::tree::optional< valuevat_type > valuevat_optional;
  typedef ::xsd::cxx::tree::traits< valuevat_type, wchar_t > valuevat_traits;

  const valuevat_optional&
  valuevat () const;

  valuevat_optional&
  valuevat ();

  void
  valuevat (const valuevat_type& x);

  void
  valuevat (const valuevat_optional& x);

  void
  valuevat (::std::unique_ptr< valuevat_type > p);

  // valueprz
  //
  typedef ::decimal_type valueprz_type;
  typedef ::xsd::cxx::tree::optional< valueprz_type > valueprz_optional;
  typedef ::xsd::cxx::tree::traits< valueprz_type, wchar_t > valueprz_traits;

  const valueprz_optional&
  valueprz () const;

  valueprz_optional&
  valueprz ();

  void
  valueprz (const valueprz_type& x);

  void
  valueprz (const valueprz_optional& x);

  void
  valueprz (::std::unique_ptr< valueprz_type > p);

  // Constructors.
  //
  bkm_invoicepos ();

  bkm_invoicepos (const bkm_invoicepos& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  virtual bkm_invoicepos*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  bkm_invoicepos&
  operator= (const bkm_invoicepos& x);

  virtual 
  ~bkm_invoicepos ();

  // Implementation.
  //
  protected:
  id_optional id_;
  code_optional code_;
  sortid_optional sortid_;
  invoicedeftype_optional invoicedeftype_;
  current_optional current_;
  totalvalue_optional totalvalue_;
  valuento_optional valuento_;
  valuevat_optional valuevat_;
  valueprz_optional valueprz_;
};

class bkm_splitinvoice: public ::xml_schema::type
{
  public:
  // splititemid
  //
  typedef ::xml_schema::int_ splititemid_type;
  typedef ::xsd::cxx::tree::optional< splititemid_type > splititemid_optional;
  typedef ::xsd::cxx::tree::traits< splititemid_type, wchar_t > splititemid_traits;

  const splititemid_optional&
  splititemid () const;

  splititemid_optional&
  splititemid ();

  void
  splititemid (const splititemid_type& x);

  void
  splititemid (const splititemid_optional& x);

  // amountnto
  //
  typedef ::decimal_type amountnto_type;
  typedef ::xsd::cxx::tree::optional< amountnto_type > amountnto_optional;
  typedef ::xsd::cxx::tree::traits< amountnto_type, wchar_t > amountnto_traits;

  const amountnto_optional&
  amountnto () const;

  amountnto_optional&
  amountnto ();

  void
  amountnto (const amountnto_type& x);

  void
  amountnto (const amountnto_optional& x);

  void
  amountnto (::std::unique_ptr< amountnto_type > p);

  // deducted
  //
  typedef ::decimal_type deducted_type;
  typedef ::xsd::cxx::tree::optional< deducted_type > deducted_optional;
  typedef ::xsd::cxx::tree::traits< deducted_type, wchar_t > deducted_traits;

  const deducted_optional&
  deducted () const;

  deducted_optional&
  deducted ();

  void
  deducted (const deducted_type& x);

  void
  deducted (const deducted_optional& x);

  void
  deducted (::std::unique_ptr< deducted_type > p);

  // deductedvat
  //
  typedef ::decimal_type deductedvat_type;
  typedef ::xsd::cxx::tree::optional< deductedvat_type > deductedvat_optional;
  typedef ::xsd::cxx::tree::traits< deductedvat_type, wchar_t > deductedvat_traits;

  const deductedvat_optional&
  deductedvat () const;

  deductedvat_optional&
  deductedvat ();

  void
  deductedvat (const deductedvat_type& x);

  void
  deductedvat (const deductedvat_optional& x);

  void
  deductedvat (::std::unique_ptr< deductedvat_type > p);

  // drl
  //
  typedef ::decimal_type drl_type;
  typedef ::xsd::cxx::tree::optional< drl_type > drl_optional;
  typedef ::xsd::cxx::tree::traits< drl_type, wchar_t > drl_traits;

  const drl_optional&
  drl () const;

  drl_optional&
  drl ();

  void
  drl (const drl_type& x);

  void
  drl (const drl_optional& x);

  void
  drl (::std::unique_ptr< drl_type > p);

  // drlvat
  //
  typedef ::decimal_type drlvat_type;
  typedef ::xsd::cxx::tree::optional< drlvat_type > drlvat_optional;
  typedef ::xsd::cxx::tree::traits< drlvat_type, wchar_t > drlvat_traits;

  const drlvat_optional&
  drlvat () const;

  drlvat_optional&
  drlvat ();

  void
  drlvat (const drlvat_type& x);

  void
  drlvat (const drlvat_optional& x);

  void
  drlvat (::std::unique_ptr< drlvat_type > p);

  // hrl
  //
  typedef ::decimal_type hrl_type;
  typedef ::xsd::cxx::tree::optional< hrl_type > hrl_optional;
  typedef ::xsd::cxx::tree::traits< hrl_type, wchar_t > hrl_traits;

  const hrl_optional&
  hrl () const;

  hrl_optional&
  hrl ();

  void
  hrl (const hrl_type& x);

  void
  hrl (const hrl_optional& x);

  void
  hrl (::std::unique_ptr< hrl_type > p);

  // hrlvat
  //
  typedef ::decimal_type hrlvat_type;
  typedef ::xsd::cxx::tree::optional< hrlvat_type > hrlvat_optional;
  typedef ::xsd::cxx::tree::traits< hrlvat_type, wchar_t > hrlvat_traits;

  const hrlvat_optional&
  hrlvat () const;

  hrlvat_optional&
  hrlvat ();

  void
  hrlvat (const hrlvat_type& x);

  void
  hrlvat (const hrlvat_optional& x);

  void
  hrlvat (::std::unique_ptr< hrlvat_type > p);

  // vatbtr
  //
  typedef ::decimal_type vatbtr_type;
  typedef ::xsd::cxx::tree::optional< vatbtr_type > vatbtr_optional;
  typedef ::xsd::cxx::tree::traits< vatbtr_type, wchar_t > vatbtr_traits;

  const vatbtr_optional&
  vatbtr () const;

  vatbtr_optional&
  vatbtr ();

  void
  vatbtr (const vatbtr_type& x);

  void
  vatbtr (const vatbtr_optional& x);

  void
  vatbtr (::std::unique_ptr< vatbtr_type > p);

  // discountnto
  //
  typedef ::decimal_type discountnto_type;
  typedef ::xsd::cxx::tree::optional< discountnto_type > discountnto_optional;
  typedef ::xsd::cxx::tree::traits< discountnto_type, wchar_t > discountnto_traits;

  const discountnto_optional&
  discountnto () const;

  discountnto_optional&
  discountnto ();

  void
  discountnto (const discountnto_type& x);

  void
  discountnto (const discountnto_optional& x);

  void
  discountnto (::std::unique_ptr< discountnto_type > p);

  // drlsurety
  //
  typedef ::decimal_type drlsurety_type;
  typedef ::xsd::cxx::tree::optional< drlsurety_type > drlsurety_optional;
  typedef ::xsd::cxx::tree::traits< drlsurety_type, wchar_t > drlsurety_traits;

  const drlsurety_optional&
  drlsurety () const;

  drlsurety_optional&
  drlsurety ();

  void
  drlsurety (const drlsurety_type& x);

  void
  drlsurety (const drlsurety_optional& x);

  void
  drlsurety (::std::unique_ptr< drlsurety_type > p);

  // drlsuretyvat
  //
  typedef ::decimal_type drlsuretyvat_type;
  typedef ::xsd::cxx::tree::optional< drlsuretyvat_type > drlsuretyvat_optional;
  typedef ::xsd::cxx::tree::traits< drlsuretyvat_type, wchar_t > drlsuretyvat_traits;

  const drlsuretyvat_optional&
  drlsuretyvat () const;

  drlsuretyvat_optional&
  drlsuretyvat ();

  void
  drlsuretyvat (const drlsuretyvat_type& x);

  void
  drlsuretyvat (const drlsuretyvat_optional& x);

  void
  drlsuretyvat (::std::unique_ptr< drlsuretyvat_type > p);

  // hrlsurety
  //
  typedef ::decimal_type hrlsurety_type;
  typedef ::xsd::cxx::tree::optional< hrlsurety_type > hrlsurety_optional;
  typedef ::xsd::cxx::tree::traits< hrlsurety_type, wchar_t > hrlsurety_traits;

  const hrlsurety_optional&
  hrlsurety () const;

  hrlsurety_optional&
  hrlsurety ();

  void
  hrlsurety (const hrlsurety_type& x);

  void
  hrlsurety (const hrlsurety_optional& x);

  void
  hrlsurety (::std::unique_ptr< hrlsurety_type > p);

  // hrlsuretyvat
  //
  typedef ::decimal_type hrlsuretyvat_type;
  typedef ::xsd::cxx::tree::optional< hrlsuretyvat_type > hrlsuretyvat_optional;
  typedef ::xsd::cxx::tree::traits< hrlsuretyvat_type, wchar_t > hrlsuretyvat_traits;

  const hrlsuretyvat_optional&
  hrlsuretyvat () const;

  hrlsuretyvat_optional&
  hrlsuretyvat ();

  void
  hrlsuretyvat (const hrlsuretyvat_type& x);

  void
  hrlsuretyvat (const hrlsuretyvat_optional& x);

  void
  hrlsuretyvat (::std::unique_ptr< hrlsuretyvat_type > p);

  // skontonto
  //
  typedef ::decimal_type skontonto_type;
  typedef ::xsd::cxx::tree::optional< skontonto_type > skontonto_optional;
  typedef ::xsd::cxx::tree::traits< skontonto_type, wchar_t > skontonto_traits;

  const skontonto_optional&
  skontonto () const;

  skontonto_optional&
  skontonto ();

  void
  skontonto (const skontonto_type& x);

  void
  skontonto (const skontonto_optional& x);

  void
  skontonto (::std::unique_ptr< skontonto_type > p);

  // anwbtrnto
  //
  typedef ::decimal_type anwbtrnto_type;
  typedef ::xsd::cxx::tree::optional< anwbtrnto_type > anwbtrnto_optional;
  typedef ::xsd::cxx::tree::traits< anwbtrnto_type, wchar_t > anwbtrnto_traits;

  const anwbtrnto_optional&
  anwbtrnto () const;

  anwbtrnto_optional&
  anwbtrnto ();

  void
  anwbtrnto (const anwbtrnto_type& x);

  void
  anwbtrnto (const anwbtrnto_optional& x);

  void
  anwbtrnto (::std::unique_ptr< anwbtrnto_type > p);

  // anwskonto
  //
  typedef ::decimal_type anwskonto_type;
  typedef ::xsd::cxx::tree::optional< anwskonto_type > anwskonto_optional;
  typedef ::xsd::cxx::tree::traits< anwskonto_type, wchar_t > anwskonto_traits;

  const anwskonto_optional&
  anwskonto () const;

  anwskonto_optional&
  anwskonto ();

  void
  anwskonto (const anwskonto_type& x);

  void
  anwskonto (const anwskonto_optional& x);

  void
  anwskonto (::std::unique_ptr< anwskonto_type > p);

  // anwbtr
  //
  typedef ::decimal_type anwbtr_type;
  typedef ::xsd::cxx::tree::optional< anwbtr_type > anwbtr_optional;
  typedef ::xsd::cxx::tree::traits< anwbtr_type, wchar_t > anwbtr_traits;

  const anwbtr_optional&
  anwbtr () const;

  anwbtr_optional&
  anwbtr ();

  void
  anwbtr (const anwbtr_type& x);

  void
  anwbtr (const anwbtr_optional& x);

  void
  anwbtr (::std::unique_ptr< anwbtr_type > p);

  // anwskobtr
  //
  typedef ::decimal_type anwskobtr_type;
  typedef ::xsd::cxx::tree::optional< anwskobtr_type > anwskobtr_optional;
  typedef ::xsd::cxx::tree::traits< anwskobtr_type, wchar_t > anwskobtr_traits;

  const anwskobtr_optional&
  anwskobtr () const;

  anwskobtr_optional&
  anwskobtr ();

  void
  anwskobtr (const anwskobtr_type& x);

  void
  anwskobtr (const anwskobtr_optional& x);

  void
  anwskobtr (::std::unique_ptr< anwskobtr_type > p);

  // skontobto
  //
  typedef ::decimal_type skontobto_type;
  typedef ::xsd::cxx::tree::optional< skontobto_type > skontobto_optional;
  typedef ::xsd::cxx::tree::traits< skontobto_type, wchar_t > skontobto_traits;

  const skontobto_optional&
  skontobto () const;

  skontobto_optional&
  skontobto ();

  void
  skontobto (const skontobto_type& x);

  void
  skontobto (const skontobto_optional& x);

  void
  skontobto (::std::unique_ptr< skontobto_type > p);

  // Constructors.
  //
  bkm_splitinvoice ();

  bkm_splitinvoice (const bkm_splitinvoice& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  virtual bkm_splitinvoice*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  bkm_splitinvoice&
  operator= (const bkm_splitinvoice& x);

  virtual 
  ~bkm_splitinvoice ();

  // Implementation.
  //
  protected:
  splititemid_optional splititemid_;
  amountnto_optional amountnto_;
  deducted_optional deducted_;
  deductedvat_optional deductedvat_;
  drl_optional drl_;
  drlvat_optional drlvat_;
  hrl_optional hrl_;
  hrlvat_optional hrlvat_;
  vatbtr_optional vatbtr_;
  discountnto_optional discountnto_;
  drlsurety_optional drlsurety_;
  drlsuretyvat_optional drlsuretyvat_;
  hrlsurety_optional hrlsurety_;
  hrlsuretyvat_optional hrlsuretyvat_;
  skontonto_optional skontonto_;
  anwbtrnto_optional anwbtrnto_;
  anwskonto_optional anwskonto_;
  anwbtr_optional anwbtr_;
  anwskobtr_optional anwskobtr_;
  skontobto_optional skontobto_;
};

class bkm_payment: public ::xml_schema::type
{
  public:
  // id
  //
  typedef ::xml_schema::int_ id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  // externalkey
  //
  typedef ::externalkey_type externalkey_type;
  typedef ::xsd::cxx::tree::traits< externalkey_type, wchar_t > externalkey_traits;

  const externalkey_type&
  externalkey () const;

  externalkey_type&
  externalkey ();

  void
  externalkey (const externalkey_type& x);

  void
  externalkey (::std::unique_ptr< externalkey_type > p);

  // invoicekey
  //
  typedef ::externalkey_type invoicekey_type;
  typedef ::xsd::cxx::tree::traits< invoicekey_type, wchar_t > invoicekey_traits;

  const invoicekey_type&
  invoicekey () const;

  invoicekey_type&
  invoicekey ();

  void
  invoicekey (const invoicekey_type& x);

  void
  invoicekey (::std::unique_ptr< invoicekey_type > p);

  // matchfield
  //
  typedef ::matchfieldpayment_type matchfield_type;
  typedef ::xsd::cxx::tree::optional< matchfield_type > matchfield_optional;
  typedef ::xsd::cxx::tree::traits< matchfield_type, wchar_t > matchfield_traits;

  const matchfield_optional&
  matchfield () const;

  matchfield_optional&
  matchfield ();

  void
  matchfield (const matchfield_type& x);

  void
  matchfield (const matchfield_optional& x);

  void
  matchfield (::std::unique_ptr< matchfield_type > p);

  // partcode
  //
  typedef ::text32_type partcode_type;
  typedef ::xsd::cxx::tree::optional< partcode_type > partcode_optional;
  typedef ::xsd::cxx::tree::traits< partcode_type, wchar_t > partcode_traits;

  const partcode_optional&
  partcode () const;

  partcode_optional&
  partcode ();

  void
  partcode (const partcode_type& x);

  void
  partcode (const partcode_optional& x);

  void
  partcode (::std::unique_ptr< partcode_type > p);

  // controlcode
  //
  typedef ::text256_type controlcode_type;
  typedef ::xsd::cxx::tree::optional< controlcode_type > controlcode_optional;
  typedef ::xsd::cxx::tree::traits< controlcode_type, wchar_t > controlcode_traits;

  const controlcode_optional&
  controlcode () const;

  controlcode_optional&
  controlcode ();

  void
  controlcode (const controlcode_type& x);

  void
  controlcode (const controlcode_optional& x);

  void
  controlcode (::std::unique_ptr< controlcode_type > p);

  // number
  //
  typedef ::text16_type number_type;
  typedef ::xsd::cxx::tree::optional< number_type > number_optional;
  typedef ::xsd::cxx::tree::traits< number_type, wchar_t > number_traits;

  const number_optional&
  number () const;

  number_optional&
  number ();

  void
  number (const number_type& x);

  void
  number (const number_optional& x);

  void
  number (::std::unique_ptr< number_type > p);

  // external
  //
  typedef ::text256_type external_type;
  typedef ::xsd::cxx::tree::optional< external_type > external_optional;
  typedef ::xsd::cxx::tree::traits< external_type, wchar_t > external_traits;

  const external_optional&
  external () const;

  external_optional&
  external ();

  void
  external (const external_type& x);

  void
  external (const external_optional& x);

  void
  external (::std::unique_ptr< external_type > p);

  // extern1
  //
  typedef ::text128_type extern1_type;
  typedef ::xsd::cxx::tree::optional< extern1_type > extern1_optional;
  typedef ::xsd::cxx::tree::traits< extern1_type, wchar_t > extern1_traits;

  const extern1_optional&
  extern1 () const;

  extern1_optional&
  extern1 ();

  void
  extern1 (const extern1_type& x);

  void
  extern1 (const extern1_optional& x);

  void
  extern1 (::std::unique_ptr< extern1_type > p);

  // extern2
  //
  typedef ::text128_type extern2_type;
  typedef ::xsd::cxx::tree::optional< extern2_type > extern2_optional;
  typedef ::xsd::cxx::tree::traits< extern2_type, wchar_t > extern2_traits;

  const extern2_optional&
  extern2 () const;

  extern2_optional&
  extern2 ();

  void
  extern2 (const extern2_type& x);

  void
  extern2 (const extern2_optional& x);

  void
  extern2 (::std::unique_ptr< extern2_type > p);

  // extern3
  //
  typedef ::text128_type extern3_type;
  typedef ::xsd::cxx::tree::optional< extern3_type > extern3_optional;
  typedef ::xsd::cxx::tree::traits< extern3_type, wchar_t > extern3_traits;

  const extern3_optional&
  extern3 () const;

  extern3_optional&
  extern3 ();

  void
  extern3 (const extern3_type& x);

  void
  extern3 (const extern3_optional& x);

  void
  extern3 (::std::unique_ptr< extern3_type > p);

  // payment
  //
  typedef ::decimal_type payment_type;
  typedef ::xsd::cxx::tree::optional< payment_type > payment_optional;
  typedef ::xsd::cxx::tree::traits< payment_type, wchar_t > payment_traits;

  const payment_optional&
  payment () const;

  payment_optional&
  payment ();

  void
  payment (const payment_type& x);

  void
  payment (const payment_optional& x);

  void
  payment (::std::unique_ptr< payment_type > p);

  // paymentvat
  //
  typedef ::decimal_type paymentvat_type;
  typedef ::xsd::cxx::tree::optional< paymentvat_type > paymentvat_optional;
  typedef ::xsd::cxx::tree::traits< paymentvat_type, wchar_t > paymentvat_traits;

  const paymentvat_optional&
  paymentvat () const;

  paymentvat_optional&
  paymentvat ();

  void
  paymentvat (const paymentvat_type& x);

  void
  paymentvat (const paymentvat_optional& x);

  void
  paymentvat (::std::unique_ptr< paymentvat_type > p);

  // paymentdate
  //
  typedef ::xml_schema::date paymentdate_type;
  typedef ::xsd::cxx::tree::optional< paymentdate_type > paymentdate_optional;
  typedef ::xsd::cxx::tree::traits< paymentdate_type, wchar_t > paymentdate_traits;

  const paymentdate_optional&
  paymentdate () const;

  paymentdate_optional&
  paymentdate ();

  void
  paymentdate (const paymentdate_type& x);

  void
  paymentdate (const paymentdate_optional& x);

  void
  paymentdate (::std::unique_ptr< paymentdate_type > p);

  // desc
  //
  typedef ::xml_schema::string desc_type;
  typedef ::xsd::cxx::tree::optional< desc_type > desc_optional;
  typedef ::xsd::cxx::tree::traits< desc_type, wchar_t > desc_traits;

  const desc_optional&
  desc () const;

  desc_optional&
  desc ();

  void
  desc (const desc_type& x);

  void
  desc (const desc_optional& x);

  void
  desc (::std::unique_ptr< desc_type > p);

  // note
  //
  typedef ::xml_schema::string note_type;
  typedef ::xsd::cxx::tree::optional< note_type > note_optional;
  typedef ::xsd::cxx::tree::traits< note_type, wchar_t > note_traits;

  const note_optional&
  note () const;

  note_optional&
  note ();

  void
  note (const note_type& x);

  void
  note (const note_optional& x);

  void
  note (::std::unique_ptr< note_type > p);

  // remark
  //
  typedef ::xml_schema::string remark_type;
  typedef ::xsd::cxx::tree::optional< remark_type > remark_optional;
  typedef ::xsd::cxx::tree::traits< remark_type, wchar_t > remark_traits;

  const remark_optional&
  remark () const;

  remark_optional&
  remark ();

  void
  remark (const remark_type& x);

  void
  remark (const remark_optional& x);

  void
  remark (::std::unique_ptr< remark_type > p);

  // Constructors.
  //
  bkm_payment (const externalkey_type&,
               const invoicekey_type&);

  bkm_payment (const bkm_payment& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  virtual bkm_payment*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  bkm_payment&
  operator= (const bkm_payment& x);

  virtual 
  ~bkm_payment ();

  // Implementation.
  //
  protected:
  id_optional id_;
  ::xsd::cxx::tree::one< externalkey_type > externalkey_;
  ::xsd::cxx::tree::one< invoicekey_type > invoicekey_;
  matchfield_optional matchfield_;
  partcode_optional partcode_;
  controlcode_optional controlcode_;
  number_optional number_;
  external_optional external_;
  extern1_optional extern1_;
  extern2_optional extern2_;
  extern3_optional extern3_;
  payment_optional payment_;
  paymentvat_optional paymentvat_;
  paymentdate_optional paymentdate_;
  desc_optional desc_;
  note_optional note_;
  remark_optional remark_;
};

class ava_unit: public ::xml_schema::type
{
  public:
  // id
  //
  typedef ::xml_schema::int_ id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  // code
  //
  typedef ::text16_type code_type;
  typedef ::xsd::cxx::tree::traits< code_type, wchar_t > code_traits;

  const code_type&
  code () const;

  code_type&
  code ();

  void
  code (const code_type& x);

  void
  code (::std::unique_ptr< code_type > p);

  // normcode
  //
  typedef ::text16_type normcode_type;
  typedef ::xsd::cxx::tree::optional< normcode_type > normcode_optional;
  typedef ::xsd::cxx::tree::traits< normcode_type, wchar_t > normcode_traits;

  const normcode_optional&
  normcode () const;

  normcode_optional&
  normcode ();

  void
  normcode (const normcode_type& x);

  void
  normcode (const normcode_optional& x);

  void
  normcode (::std::unique_ptr< normcode_type > p);

  // unit
  //
  typedef ::text64_type unit_type;
  typedef ::xsd::cxx::tree::optional< unit_type > unit_optional;
  typedef ::xsd::cxx::tree::traits< unit_type, wchar_t > unit_traits;

  const unit_optional&
  unit () const;

  unit_optional&
  unit ();

  void
  unit (const unit_type& x);

  void
  unit (const unit_optional& x);

  void
  unit (::std::unique_ptr< unit_type > p);

  // externalkey
  //
  typedef ::externalkey_type externalkey_type;
  typedef ::xsd::cxx::tree::traits< externalkey_type, wchar_t > externalkey_traits;

  const externalkey_type&
  externalkey () const;

  externalkey_type&
  externalkey ();

  void
  externalkey (const externalkey_type& x);

  void
  externalkey (::std::unique_ptr< externalkey_type > p);

  // matchfield
  //
  typedef ::matchfieldavaunit_type matchfield_type;
  typedef ::xsd::cxx::tree::optional< matchfield_type > matchfield_optional;
  typedef ::xsd::cxx::tree::traits< matchfield_type, wchar_t > matchfield_traits;

  const matchfield_optional&
  matchfield () const;

  matchfield_optional&
  matchfield ();

  void
  matchfield (const matchfield_type& x);

  void
  matchfield (const matchfield_optional& x);

  void
  matchfield (::std::unique_ptr< matchfield_type > p);

  // controlcode
  //
  typedef ::text256_type controlcode_type;
  typedef ::xsd::cxx::tree::optional< controlcode_type > controlcode_optional;
  typedef ::xsd::cxx::tree::traits< controlcode_type, wchar_t > controlcode_traits;

  const controlcode_optional&
  controlcode () const;

  controlcode_optional&
  controlcode ();

  void
  controlcode (const controlcode_type& x);

  void
  controlcode (const controlcode_optional& x);

  void
  controlcode (::std::unique_ptr< controlcode_type > p);

  // desc
  //
  typedef ::xml_schema::string desc_type;
  typedef ::xsd::cxx::tree::optional< desc_type > desc_optional;
  typedef ::xsd::cxx::tree::traits< desc_type, wchar_t > desc_traits;

  const desc_optional&
  desc () const;

  desc_optional&
  desc ();

  void
  desc (const desc_type& x);

  void
  desc (const desc_optional& x);

  void
  desc (::std::unique_ptr< desc_type > p);

  // note
  //
  typedef ::xml_schema::string note_type;
  typedef ::xsd::cxx::tree::optional< note_type > note_optional;
  typedef ::xsd::cxx::tree::traits< note_type, wchar_t > note_traits;

  const note_optional&
  note () const;

  note_optional&
  note ();

  void
  note (const note_type& x);

  void
  note (const note_optional& x);

  void
  note (::std::unique_ptr< note_type > p);

  // remark
  //
  typedef ::xml_schema::string remark_type;
  typedef ::xsd::cxx::tree::optional< remark_type > remark_optional;
  typedef ::xsd::cxx::tree::traits< remark_type, wchar_t > remark_traits;

  const remark_optional&
  remark () const;

  remark_optional&
  remark ();

  void
  remark (const remark_type& x);

  void
  remark (const remark_optional& x);

  void
  remark (::std::unique_ptr< remark_type > p);

  // Constructors.
  //
  ava_unit (const code_type&,
            const externalkey_type&);

  ava_unit (const ava_unit& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual ava_unit*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ava_unit&
  operator= (const ava_unit& x);

  virtual 
  ~ava_unit ();

  // Implementation.
  //
  protected:
  id_optional id_;
  ::xsd::cxx::tree::one< code_type > code_;
  normcode_optional normcode_;
  unit_optional unit_;
  ::xsd::cxx::tree::one< externalkey_type > externalkey_;
  matchfield_optional matchfield_;
  controlcode_optional controlcode_;
  desc_optional desc_;
  note_optional note_;
  remark_optional remark_;
};

class ava_order: public ::xml_schema::type
{
  public:
  // ava.orderpos
  //
  typedef ::ava_orderpos ava_orderpos_type;
  typedef ::xsd::cxx::tree::optional< ava_orderpos_type > ava_orderpos_optional;
  typedef ::xsd::cxx::tree::traits< ava_orderpos_type, wchar_t > ava_orderpos_traits;

  const ava_orderpos_optional&
  ava_orderpos () const;

  ava_orderpos_optional&
  ava_orderpos ();

  void
  ava_orderpos (const ava_orderpos_type& x);

  void
  ava_orderpos (const ava_orderpos_optional& x);

  void
  ava_orderpos (::std::unique_ptr< ava_orderpos_type > p);

  // id
  //
  typedef ::xml_schema::int_ id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  // externalkey
  //
  typedef ::externalkey_type externalkey_type;
  typedef ::xsd::cxx::tree::traits< externalkey_type, wchar_t > externalkey_traits;

  const externalkey_type&
  externalkey () const;

  externalkey_type&
  externalkey ();

  void
  externalkey (const externalkey_type& x);

  void
  externalkey (::std::unique_ptr< externalkey_type > p);

  // projectkey
  //
  typedef ::externalkey_type projectkey_type;
  typedef ::xsd::cxx::tree::optional< projectkey_type > projectkey_optional;
  typedef ::xsd::cxx::tree::traits< projectkey_type, wchar_t > projectkey_traits;

  const projectkey_optional&
  projectkey () const;

  projectkey_optional&
  projectkey ();

  void
  projectkey (const projectkey_type& x);

  void
  projectkey (const projectkey_optional& x);

  void
  projectkey (::std::unique_ptr< projectkey_type > p);

  // bkmorderid
  //
  typedef ::xml_schema::int_ bkmorderid_type;
  typedef ::xsd::cxx::tree::optional< bkmorderid_type > bkmorderid_optional;
  typedef ::xsd::cxx::tree::traits< bkmorderid_type, wchar_t > bkmorderid_traits;

  const bkmorderid_optional&
  bkmorderid () const;

  bkmorderid_optional&
  bkmorderid ();

  void
  bkmorderid (const bkmorderid_type& x);

  void
  bkmorderid (const bkmorderid_optional& x);

  // bkmorderkey
  //
  typedef ::externalkey_type bkmorderkey_type;
  typedef ::xsd::cxx::tree::optional< bkmorderkey_type > bkmorderkey_optional;
  typedef ::xsd::cxx::tree::traits< bkmorderkey_type, wchar_t > bkmorderkey_traits;

  const bkmorderkey_optional&
  bkmorderkey () const;

  bkmorderkey_optional&
  bkmorderkey ();

  void
  bkmorderkey (const bkmorderkey_type& x);

  void
  bkmorderkey (const bkmorderkey_optional& x);

  void
  bkmorderkey (::std::unique_ptr< bkmorderkey_type > p);

  // masterkey
  //
  typedef ::externalkey_type masterkey_type;
  typedef ::xsd::cxx::tree::optional< masterkey_type > masterkey_optional;
  typedef ::xsd::cxx::tree::traits< masterkey_type, wchar_t > masterkey_traits;

  const masterkey_optional&
  masterkey () const;

  masterkey_optional&
  masterkey ();

  void
  masterkey (const masterkey_type& x);

  void
  masterkey (const masterkey_optional& x);

  void
  masterkey (::std::unique_ptr< masterkey_type > p);

  // matchfield
  //
  typedef ::matchfieldavaorder_type matchfield_type;
  typedef ::xsd::cxx::tree::optional< matchfield_type > matchfield_optional;
  typedef ::xsd::cxx::tree::traits< matchfield_type, wchar_t > matchfield_traits;

  const matchfield_optional&
  matchfield () const;

  matchfield_optional&
  matchfield ();

  void
  matchfield (const matchfield_type& x);

  void
  matchfield (const matchfield_optional& x);

  void
  matchfield (::std::unique_ptr< matchfield_type > p);

  // controlcode
  //
  typedef ::text256_type controlcode_type;
  typedef ::xsd::cxx::tree::optional< controlcode_type > controlcode_optional;
  typedef ::xsd::cxx::tree::traits< controlcode_type, wchar_t > controlcode_traits;

  const controlcode_optional&
  controlcode () const;

  controlcode_optional&
  controlcode ();

  void
  controlcode (const controlcode_type& x);

  void
  controlcode (const controlcode_optional& x);

  void
  controlcode (::std::unique_ptr< controlcode_type > p);

  // normcode
  //
  typedef ::normdata_type normcode_type;
  typedef ::xsd::cxx::tree::optional< normcode_type > normcode_optional;
  typedef ::xsd::cxx::tree::traits< normcode_type, wchar_t > normcode_traits;

  const normcode_optional&
  normcode () const;

  normcode_optional&
  normcode ();

  void
  normcode (const normcode_type& x);

  void
  normcode (const normcode_optional& x);

  void
  normcode (::std::unique_ptr< normcode_type > p);

  // number
  //
  typedef ::text16_type number_type;
  typedef ::xsd::cxx::tree::optional< number_type > number_optional;
  typedef ::xsd::cxx::tree::traits< number_type, wchar_t > number_traits;

  const number_optional&
  number () const;

  number_optional&
  number ();

  void
  number (const number_type& x);

  void
  number (const number_optional& x);

  void
  number (::std::unique_ptr< number_type > p);

  // order
  //
  typedef ::text128_type order_type;
  typedef ::xsd::cxx::tree::optional< order_type > order_optional;
  typedef ::xsd::cxx::tree::traits< order_type, wchar_t > order_traits;

  const order_optional&
  order () const;

  order_optional&
  order ();

  void
  order (const order_type& x);

  void
  order (const order_optional& x);

  void
  order (::std::unique_ptr< order_type > p);

  // wage
  //
  typedef ::decimal_type wage_type;
  typedef ::xsd::cxx::tree::optional< wage_type > wage_optional;
  typedef ::xsd::cxx::tree::traits< wage_type, wchar_t > wage_traits;

  const wage_optional&
  wage () const;

  wage_optional&
  wage ();

  void
  wage (const wage_type& x);

  void
  wage (const wage_optional& x);

  void
  wage (::std::unique_ptr< wage_type > p);

  // other
  //
  typedef ::decimal_type other_type;
  typedef ::xsd::cxx::tree::optional< other_type > other_optional;
  typedef ::xsd::cxx::tree::traits< other_type, wchar_t > other_traits;

  const other_optional&
  other () const;

  other_optional&
  other ();

  void
  other (const other_type& x);

  void
  other (const other_optional& x);

  void
  other (::std::unique_ptr< other_type > p);

  // posprice
  //
  typedef ::decimal_type posprice_type;
  typedef ::xsd::cxx::tree::optional< posprice_type > posprice_optional;
  typedef ::xsd::cxx::tree::traits< posprice_type, wchar_t > posprice_traits;

  const posprice_optional&
  posprice () const;

  posprice_optional&
  posprice ();

  void
  posprice (const posprice_type& x);

  void
  posprice (const posprice_optional& x);

  void
  posprice (::std::unique_ptr< posprice_type > p);

  // limitdate
  //
  typedef ::xml_schema::date limitdate_type;
  typedef ::xsd::cxx::tree::optional< limitdate_type > limitdate_optional;
  typedef ::xsd::cxx::tree::traits< limitdate_type, wchar_t > limitdate_traits;

  const limitdate_optional&
  limitdate () const;

  limitdate_optional&
  limitdate ();

  void
  limitdate (const limitdate_type& x);

  void
  limitdate (const limitdate_optional& x);

  void
  limitdate (::std::unique_ptr< limitdate_type > p);

  // indexdate
  //
  typedef ::xml_schema::date indexdate_type;
  typedef ::xsd::cxx::tree::optional< indexdate_type > indexdate_optional;
  typedef ::xsd::cxx::tree::traits< indexdate_type, wchar_t > indexdate_traits;

  const indexdate_optional&
  indexdate () const;

  indexdate_optional&
  indexdate ();

  void
  indexdate (const indexdate_type& x);

  void
  indexdate (const indexdate_optional& x);

  void
  indexdate (::std::unique_ptr< indexdate_type > p);

  // discountprz
  //
  typedef ::percent_type discountprz_type;
  typedef ::xsd::cxx::tree::optional< discountprz_type > discountprz_optional;
  typedef ::xsd::cxx::tree::traits< discountprz_type, wchar_t > discountprz_traits;

  const discountprz_optional&
  discountprz () const;

  discountprz_optional&
  discountprz ();

  void
  discountprz (const discountprz_type& x);

  void
  discountprz (const discountprz_optional& x);

  void
  discountprz (::std::unique_ptr< discountprz_type > p);

  // skontoprz
  //
  typedef ::percent_type skontoprz_type;
  typedef ::xsd::cxx::tree::optional< skontoprz_type > skontoprz_optional;
  typedef ::xsd::cxx::tree::traits< skontoprz_type, wchar_t > skontoprz_traits;

  const skontoprz_optional&
  skontoprz () const;

  skontoprz_optional&
  skontoprz ();

  void
  skontoprz (const skontoprz_type& x);

  void
  skontoprz (const skontoprz_optional& x);

  void
  skontoprz (::std::unique_ptr< skontoprz_type > p);

  // vatprz
  //
  typedef ::percent_type vatprz_type;
  typedef ::xsd::cxx::tree::optional< vatprz_type > vatprz_optional;
  typedef ::xsd::cxx::tree::traits< vatprz_type, wchar_t > vatprz_traits;

  const vatprz_optional&
  vatprz () const;

  vatprz_optional&
  vatprz ();

  void
  vatprz (const vatprz_type& x);

  void
  vatprz (const vatprz_optional& x);

  void
  vatprz (::std::unique_ptr< vatprz_type > p);

  // statuscode
  //
  typedef ::text8_type statuscode_type;
  typedef ::xsd::cxx::tree::optional< statuscode_type > statuscode_optional;
  typedef ::xsd::cxx::tree::traits< statuscode_type, wchar_t > statuscode_traits;

  const statuscode_optional&
  statuscode () const;

  statuscode_optional&
  statuscode ();

  void
  statuscode (const statuscode_type& x);

  void
  statuscode (const statuscode_optional& x);

  void
  statuscode (::std::unique_ptr< statuscode_type > p);

  // statusname
  //
  typedef ::text32_type statusname_type;
  typedef ::xsd::cxx::tree::optional< statusname_type > statusname_optional;
  typedef ::xsd::cxx::tree::traits< statusname_type, wchar_t > statusname_traits;

  const statusname_optional&
  statusname () const;

  statusname_optional&
  statusname ();

  void
  statusname (const statusname_type& x);

  void
  statusname (const statusname_optional& x);

  void
  statusname (::std::unique_ptr< statusname_type > p);

  // desc
  //
  typedef ::xml_schema::string desc_type;
  typedef ::xsd::cxx::tree::optional< desc_type > desc_optional;
  typedef ::xsd::cxx::tree::traits< desc_type, wchar_t > desc_traits;

  const desc_optional&
  desc () const;

  desc_optional&
  desc ();

  void
  desc (const desc_type& x);

  void
  desc (const desc_optional& x);

  void
  desc (::std::unique_ptr< desc_type > p);

  // note
  //
  typedef ::xml_schema::string note_type;
  typedef ::xsd::cxx::tree::optional< note_type > note_optional;
  typedef ::xsd::cxx::tree::traits< note_type, wchar_t > note_traits;

  const note_optional&
  note () const;

  note_optional&
  note ();

  void
  note (const note_type& x);

  void
  note (const note_optional& x);

  void
  note (::std::unique_ptr< note_type > p);

  // remark
  //
  typedef ::xml_schema::string remark_type;
  typedef ::xsd::cxx::tree::optional< remark_type > remark_optional;
  typedef ::xsd::cxx::tree::traits< remark_type, wchar_t > remark_traits;

  const remark_optional&
  remark () const;

  remark_optional&
  remark ();

  void
  remark (const remark_type& x);

  void
  remark (const remark_optional& x);

  void
  remark (::std::unique_ptr< remark_type > p);

  // Constructors.
  //
  ava_order (const externalkey_type&);

  ava_order (const ava_order& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  virtual ava_order*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ava_order&
  operator= (const ava_order& x);

  virtual 
  ~ava_order ();

  // Implementation.
  //
  protected:
  ava_orderpos_optional ava_orderpos_;
  id_optional id_;
  ::xsd::cxx::tree::one< externalkey_type > externalkey_;
  projectkey_optional projectkey_;
  bkmorderid_optional bkmorderid_;
  bkmorderkey_optional bkmorderkey_;
  masterkey_optional masterkey_;
  matchfield_optional matchfield_;
  controlcode_optional controlcode_;
  normcode_optional normcode_;
  number_optional number_;
  order_optional order_;
  wage_optional wage_;
  other_optional other_;
  posprice_optional posprice_;
  limitdate_optional limitdate_;
  indexdate_optional indexdate_;
  discountprz_optional discountprz_;
  skontoprz_optional skontoprz_;
  vatprz_optional vatprz_;
  statuscode_optional statuscode_;
  statusname_optional statusname_;
  desc_optional desc_;
  note_optional note_;
  remark_optional remark_;
};

class ava_orderpos: public ::xml_schema::type
{
  public:
  // id
  //
  typedef ::xml_schema::int_ id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  // externalkey
  //
  typedef ::externalkey_type externalkey_type;
  typedef ::xsd::cxx::tree::traits< externalkey_type, wchar_t > externalkey_traits;

  const externalkey_type&
  externalkey () const;

  externalkey_type&
  externalkey ();

  void
  externalkey (const externalkey_type& x);

  void
  externalkey (::std::unique_ptr< externalkey_type > p);

  // poscode
  //
  typedef ::text64_type poscode_type;
  typedef ::xsd::cxx::tree::optional< poscode_type > poscode_optional;
  typedef ::xsd::cxx::tree::traits< poscode_type, wchar_t > poscode_traits;

  const poscode_optional&
  poscode () const;

  poscode_optional&
  poscode ();

  void
  poscode (const poscode_type& x);

  void
  poscode (const poscode_optional& x);

  void
  poscode (::std::unique_ptr< poscode_type > p);

  // itemnumber
  //
  typedef ::text64_type itemnumber_type;
  typedef ::xsd::cxx::tree::optional< itemnumber_type > itemnumber_optional;
  typedef ::xsd::cxx::tree::traits< itemnumber_type, wchar_t > itemnumber_traits;

  const itemnumber_optional&
  itemnumber () const;

  itemnumber_optional&
  itemnumber ();

  void
  itemnumber (const itemnumber_type& x);

  void
  itemnumber (const itemnumber_optional& x);

  void
  itemnumber (::std::unique_ptr< itemnumber_type > p);

  // controlcode
  //
  typedef ::text256_type controlcode_type;
  typedef ::xsd::cxx::tree::optional< controlcode_type > controlcode_optional;
  typedef ::xsd::cxx::tree::traits< controlcode_type, wchar_t > controlcode_traits;

  const controlcode_optional&
  controlcode () const;

  controlcode_optional&
  controlcode ();

  void
  controlcode (const controlcode_type& x);

  void
  controlcode (const controlcode_optional& x);

  void
  controlcode (::std::unique_ptr< controlcode_type > p);

  // keyword
  //
  typedef ::text128_type keyword_type;
  typedef ::xsd::cxx::tree::optional< keyword_type > keyword_optional;
  typedef ::xsd::cxx::tree::traits< keyword_type, wchar_t > keyword_traits;

  const keyword_optional&
  keyword () const;

  keyword_optional&
  keyword ();

  void
  keyword (const keyword_type& x);

  void
  keyword (const keyword_optional& x);

  void
  keyword (::std::unique_ptr< keyword_type > p);

  // unitcode
  //
  typedef ::externalkey_type unitcode_type;
  typedef ::xsd::cxx::tree::optional< unitcode_type > unitcode_optional;
  typedef ::xsd::cxx::tree::traits< unitcode_type, wchar_t > unitcode_traits;

  const unitcode_optional&
  unitcode () const;

  unitcode_optional&
  unitcode ();

  void
  unitcode (const unitcode_type& x);

  void
  unitcode (const unitcode_optional& x);

  void
  unitcode (::std::unique_ptr< unitcode_type > p);

  // unitkey
  //
  typedef ::text16_type unitkey_type;
  typedef ::xsd::cxx::tree::optional< unitkey_type > unitkey_optional;
  typedef ::xsd::cxx::tree::traits< unitkey_type, wchar_t > unitkey_traits;

  const unitkey_optional&
  unitkey () const;

  unitkey_optional&
  unitkey ();

  void
  unitkey (const unitkey_type& x);

  void
  unitkey (const unitkey_optional& x);

  void
  unitkey (::std::unique_ptr< unitkey_type > p);

  // groupcode
  //
  typedef ::text64_type groupcode_type;
  typedef ::xsd::cxx::tree::optional< groupcode_type > groupcode_optional;
  typedef ::xsd::cxx::tree::traits< groupcode_type, wchar_t > groupcode_traits;

  const groupcode_optional&
  groupcode () const;

  groupcode_optional&
  groupcode ();

  void
  groupcode (const groupcode_type& x);

  void
  groupcode (const groupcode_optional& x);

  void
  groupcode (::std::unique_ptr< groupcode_type > p);

  // text
  //
  typedef ::xml_schema::string text_type;
  typedef ::xsd::cxx::tree::optional< text_type > text_optional;
  typedef ::xsd::cxx::tree::traits< text_type, wchar_t > text_traits;

  const text_optional&
  text () const;

  text_optional&
  text ();

  void
  text (const text_type& x);

  void
  text (const text_optional& x);

  void
  text (::std::unique_ptr< text_type > p);

  // comment
  //
  typedef ::xml_schema::string comment_type;
  typedef ::xsd::cxx::tree::optional< comment_type > comment_optional;
  typedef ::xsd::cxx::tree::traits< comment_type, wchar_t > comment_traits;

  const comment_optional&
  comment () const;

  comment_optional&
  comment ();

  void
  comment (const comment_type& x);

  void
  comment (const comment_optional& x);

  void
  comment (::std::unique_ptr< comment_type > p);

  // wage
  //
  typedef ::decimal_type wage_type;
  typedef ::xsd::cxx::tree::optional< wage_type > wage_optional;
  typedef ::xsd::cxx::tree::traits< wage_type, wchar_t > wage_traits;

  const wage_optional&
  wage () const;

  wage_optional&
  wage ();

  void
  wage (const wage_type& x);

  void
  wage (const wage_optional& x);

  void
  wage (::std::unique_ptr< wage_type > p);

  // other
  //
  typedef ::decimal_type other_type;
  typedef ::xsd::cxx::tree::optional< other_type > other_optional;
  typedef ::xsd::cxx::tree::traits< other_type, wchar_t > other_traits;

  const other_optional&
  other () const;

  other_optional&
  other ();

  void
  other (const other_type& x);

  void
  other (const other_optional& x);

  void
  other (::std::unique_ptr< other_type > p);

  // quantity
  //
  typedef ::decimal_type quantity_type;
  typedef ::xsd::cxx::tree::optional< quantity_type > quantity_optional;
  typedef ::xsd::cxx::tree::traits< quantity_type, wchar_t > quantity_traits;

  const quantity_optional&
  quantity () const;

  quantity_optional&
  quantity ();

  void
  quantity (const quantity_type& x);

  void
  quantity (const quantity_optional& x);

  void
  quantity (::std::unique_ptr< quantity_type > p);

  // unitprice
  //
  typedef ::decimal_type unitprice_type;
  typedef ::xsd::cxx::tree::optional< unitprice_type > unitprice_optional;
  typedef ::xsd::cxx::tree::traits< unitprice_type, wchar_t > unitprice_traits;

  const unitprice_optional&
  unitprice () const;

  unitprice_optional&
  unitprice ();

  void
  unitprice (const unitprice_type& x);

  void
  unitprice (const unitprice_optional& x);

  void
  unitprice (::std::unique_ptr< unitprice_type > p);

  // posprice
  //
  typedef ::decimal_type posprice_type;
  typedef ::xsd::cxx::tree::optional< posprice_type > posprice_optional;
  typedef ::xsd::cxx::tree::traits< posprice_type, wchar_t > posprice_traits;

  const posprice_optional&
  posprice () const;

  posprice_optional&
  posprice ();

  void
  posprice (const posprice_type& x);

  void
  posprice (const posprice_optional& x);

  void
  posprice (::std::unique_ptr< posprice_type > p);

  // discountprz
  //
  typedef ::percent_type discountprz_type;
  typedef ::xsd::cxx::tree::optional< discountprz_type > discountprz_optional;
  typedef ::xsd::cxx::tree::traits< discountprz_type, wchar_t > discountprz_traits;

  const discountprz_optional&
  discountprz () const;

  discountprz_optional&
  discountprz ();

  void
  discountprz (const discountprz_type& x);

  void
  discountprz (const discountprz_optional& x);

  void
  discountprz (::std::unique_ptr< discountprz_type > p);

  // vatprz
  //
  typedef ::percent_type vatprz_type;
  typedef ::xsd::cxx::tree::optional< vatprz_type > vatprz_optional;
  typedef ::xsd::cxx::tree::traits< vatprz_type, wchar_t > vatprz_traits;

  const vatprz_optional&
  vatprz () const;

  vatprz_optional&
  vatprz ();

  void
  vatprz (const vatprz_type& x);

  void
  vatprz (const vatprz_optional& x);

  void
  vatprz (::std::unique_ptr< vatprz_type > p);

  // statuscode
  //
  typedef ::text8_type statuscode_type;
  typedef ::xsd::cxx::tree::optional< statuscode_type > statuscode_optional;
  typedef ::xsd::cxx::tree::traits< statuscode_type, wchar_t > statuscode_traits;

  const statuscode_optional&
  statuscode () const;

  statuscode_optional&
  statuscode ();

  void
  statuscode (const statuscode_type& x);

  void
  statuscode (const statuscode_optional& x);

  void
  statuscode (::std::unique_ptr< statuscode_type > p);

  // desc
  //
  typedef ::xml_schema::string desc_type;
  typedef ::xsd::cxx::tree::optional< desc_type > desc_optional;
  typedef ::xsd::cxx::tree::traits< desc_type, wchar_t > desc_traits;

  const desc_optional&
  desc () const;

  desc_optional&
  desc ();

  void
  desc (const desc_type& x);

  void
  desc (const desc_optional& x);

  void
  desc (::std::unique_ptr< desc_type > p);

  // note
  //
  typedef ::xml_schema::string note_type;
  typedef ::xsd::cxx::tree::optional< note_type > note_optional;
  typedef ::xsd::cxx::tree::traits< note_type, wchar_t > note_traits;

  const note_optional&
  note () const;

  note_optional&
  note ();

  void
  note (const note_type& x);

  void
  note (const note_optional& x);

  void
  note (::std::unique_ptr< note_type > p);

  // remark
  //
  typedef ::xml_schema::string remark_type;
  typedef ::xsd::cxx::tree::optional< remark_type > remark_optional;
  typedef ::xsd::cxx::tree::traits< remark_type, wchar_t > remark_traits;

  const remark_optional&
  remark () const;

  remark_optional&
  remark ();

  void
  remark (const remark_type& x);

  void
  remark (const remark_optional& x);

  void
  remark (::std::unique_ptr< remark_type > p);

  // Constructors.
  //
  ava_orderpos (const externalkey_type&);

  ava_orderpos (const ava_orderpos& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual ava_orderpos*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ava_orderpos&
  operator= (const ava_orderpos& x);

  virtual 
  ~ava_orderpos ();

  // Implementation.
  //
  protected:
  id_optional id_;
  ::xsd::cxx::tree::one< externalkey_type > externalkey_;
  poscode_optional poscode_;
  itemnumber_optional itemnumber_;
  controlcode_optional controlcode_;
  keyword_optional keyword_;
  unitcode_optional unitcode_;
  unitkey_optional unitkey_;
  groupcode_optional groupcode_;
  text_optional text_;
  comment_optional comment_;
  wage_optional wage_;
  other_optional other_;
  quantity_optional quantity_;
  unitprice_optional unitprice_;
  posprice_optional posprice_;
  discountprz_optional discountprz_;
  vatprz_optional vatprz_;
  statuscode_optional statuscode_;
  desc_optional desc_;
  note_optional note_;
  remark_optional remark_;
};

class bkm_document: public ::xml_schema::type
{
  public:
  // id
  //
  typedef ::xml_schema::int_ id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  // externalkey
  //
  typedef ::externalkey_type externalkey_type;
  typedef ::xsd::cxx::tree::traits< externalkey_type, wchar_t > externalkey_traits;

  const externalkey_type&
  externalkey () const;

  externalkey_type&
  externalkey ();

  void
  externalkey (const externalkey_type& x);

  void
  externalkey (::std::unique_ptr< externalkey_type > p);

  // scope
  //
  typedef ::scope_type scope_type;
  typedef ::xsd::cxx::tree::traits< scope_type, wchar_t > scope_traits;

  const scope_type&
  scope () const;

  scope_type&
  scope ();

  void
  scope (const scope_type& x);

  void
  scope (::std::unique_ptr< scope_type > p);

  // scopekey
  //
  typedef ::externalkey_type scopekey_type;
  typedef ::xsd::cxx::tree::traits< scopekey_type, wchar_t > scopekey_traits;

  const scopekey_type&
  scopekey () const;

  scopekey_type&
  scopekey ();

  void
  scopekey (const scopekey_type& x);

  void
  scopekey (::std::unique_ptr< scopekey_type > p);

  // matchfield
  //
  typedef ::matchfielddocument_type matchfield_type;
  typedef ::xsd::cxx::tree::optional< matchfield_type > matchfield_optional;
  typedef ::xsd::cxx::tree::traits< matchfield_type, wchar_t > matchfield_traits;

  const matchfield_optional&
  matchfield () const;

  matchfield_optional&
  matchfield ();

  void
  matchfield (const matchfield_type& x);

  void
  matchfield (const matchfield_optional& x);

  void
  matchfield (::std::unique_ptr< matchfield_type > p);

  // controlcode
  //
  typedef ::text256_type controlcode_type;
  typedef ::xsd::cxx::tree::optional< controlcode_type > controlcode_optional;
  typedef ::xsd::cxx::tree::traits< controlcode_type, wchar_t > controlcode_traits;

  const controlcode_optional&
  controlcode () const;

  controlcode_optional&
  controlcode ();

  void
  controlcode (const controlcode_type& x);

  void
  controlcode (const controlcode_optional& x);

  void
  controlcode (::std::unique_ptr< controlcode_type > p);

  // name
  //
  typedef ::text128_type name_type;
  typedef ::xsd::cxx::tree::optional< name_type > name_optional;
  typedef ::xsd::cxx::tree::traits< name_type, wchar_t > name_traits;

  const name_optional&
  name () const;

  name_optional&
  name ();

  void
  name (const name_type& x);

  void
  name (const name_optional& x);

  void
  name (::std::unique_ptr< name_type > p);

  // extension
  //
  typedef ::text32_type extension_type;
  typedef ::xsd::cxx::tree::optional< extension_type > extension_optional;
  typedef ::xsd::cxx::tree::traits< extension_type, wchar_t > extension_traits;

  const extension_optional&
  extension () const;

  extension_optional&
  extension ();

  void
  extension (const extension_type& x);

  void
  extension (const extension_optional& x);

  void
  extension (::std::unique_ptr< extension_type > p);

  // zipformat
  //
  typedef ::xml_schema::byte zipformat_type;
  typedef ::xsd::cxx::tree::optional< zipformat_type > zipformat_optional;
  typedef ::xsd::cxx::tree::traits< zipformat_type, wchar_t > zipformat_traits;

  const zipformat_optional&
  zipformat () const;

  zipformat_optional&
  zipformat ();

  void
  zipformat (const zipformat_type& x);

  void
  zipformat (const zipformat_optional& x);

  // link
  //
  typedef ::text256_type link_type;
  typedef ::xsd::cxx::tree::optional< link_type > link_optional;
  typedef ::xsd::cxx::tree::traits< link_type, wchar_t > link_traits;

  const link_optional&
  link () const;

  link_optional&
  link ();

  void
  link (const link_type& x);

  void
  link (const link_optional& x);

  void
  link (::std::unique_ptr< link_type > p);

  // data
  //
  typedef ::xml_schema::string data_type;
  typedef ::xsd::cxx::tree::optional< data_type > data_optional;
  typedef ::xsd::cxx::tree::traits< data_type, wchar_t > data_traits;

  const data_optional&
  data () const;

  data_optional&
  data ();

  void
  data (const data_type& x);

  void
  data (const data_optional& x);

  void
  data (::std::unique_ptr< data_type > p);

  // filename
  //
  typedef ::text256_type filename_type;
  typedef ::xsd::cxx::tree::optional< filename_type > filename_optional;
  typedef ::xsd::cxx::tree::traits< filename_type, wchar_t > filename_traits;

  const filename_optional&
  filename () const;

  filename_optional&
  filename ();

  void
  filename (const filename_type& x);

  void
  filename (const filename_optional& x);

  void
  filename (::std::unique_ptr< filename_type > p);

  // desc
  //
  typedef ::xml_schema::string desc_type;
  typedef ::xsd::cxx::tree::optional< desc_type > desc_optional;
  typedef ::xsd::cxx::tree::traits< desc_type, wchar_t > desc_traits;

  const desc_optional&
  desc () const;

  desc_optional&
  desc ();

  void
  desc (const desc_type& x);

  void
  desc (const desc_optional& x);

  void
  desc (::std::unique_ptr< desc_type > p);

  // note
  //
  typedef ::xml_schema::string note_type;
  typedef ::xsd::cxx::tree::optional< note_type > note_optional;
  typedef ::xsd::cxx::tree::traits< note_type, wchar_t > note_traits;

  const note_optional&
  note () const;

  note_optional&
  note ();

  void
  note (const note_type& x);

  void
  note (const note_optional& x);

  void
  note (::std::unique_ptr< note_type > p);

  // remark
  //
  typedef ::xml_schema::string remark_type;
  typedef ::xsd::cxx::tree::optional< remark_type > remark_optional;
  typedef ::xsd::cxx::tree::traits< remark_type, wchar_t > remark_traits;

  const remark_optional&
  remark () const;

  remark_optional&
  remark ();

  void
  remark (const remark_type& x);

  void
  remark (const remark_optional& x);

  void
  remark (::std::unique_ptr< remark_type > p);

  // viewertype
  //
  typedef ::documentviewertype_type viewertype_type;
  typedef ::xsd::cxx::tree::optional< viewertype_type > viewertype_optional;
  typedef ::xsd::cxx::tree::traits< viewertype_type, wchar_t > viewertype_traits;

  const viewertype_optional&
  viewertype () const;

  viewertype_optional&
  viewertype ();

  void
  viewertype (const viewertype_type& x);

  void
  viewertype (const viewertype_optional& x);

  void
  viewertype (::std::unique_ptr< viewertype_type > p);

  // main
  //
  typedef ::xml_schema::byte main_type;
  typedef ::xsd::cxx::tree::optional< main_type > main_optional;
  typedef ::xsd::cxx::tree::traits< main_type, wchar_t > main_traits;

  const main_optional&
  main () const;

  main_optional&
  main ();

  void
  main (const main_type& x);

  void
  main (const main_optional& x);

  // Constructors.
  //
  bkm_document (const externalkey_type&,
                const scope_type&,
                const scopekey_type&);

  bkm_document (const bkm_document& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual bkm_document*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  bkm_document&
  operator= (const bkm_document& x);

  virtual 
  ~bkm_document ();

  // Implementation.
  //
  protected:
  id_optional id_;
  ::xsd::cxx::tree::one< externalkey_type > externalkey_;
  ::xsd::cxx::tree::one< scope_type > scope_;
  ::xsd::cxx::tree::one< scopekey_type > scopekey_;
  matchfield_optional matchfield_;
  controlcode_optional controlcode_;
  name_optional name_;
  extension_optional extension_;
  zipformat_optional zipformat_;
  link_optional link_;
  data_optional data_;
  filename_optional filename_;
  desc_optional desc_;
  note_optional note_;
  remark_optional remark_;
  viewertype_optional viewertype_;
  main_optional main_;
};

class bkm_keyvalue: public ::xml_schema::type
{
  public:
  // bkm.contact
  //
  typedef ::bkm_contact bkm_contact_type;
  typedef ::xsd::cxx::tree::optional< bkm_contact_type > bkm_contact_optional;
  typedef ::xsd::cxx::tree::traits< bkm_contact_type, wchar_t > bkm_contact_traits;

  const bkm_contact_optional&
  bkm_contact () const;

  bkm_contact_optional&
  bkm_contact ();

  void
  bkm_contact (const bkm_contact_type& x);

  void
  bkm_contact (const bkm_contact_optional& x);

  void
  bkm_contact (::std::unique_ptr< bkm_contact_type > p);

  // bkm.counterpart
  //
  typedef ::bkm_counterpart bkm_counterpart_type;
  typedef ::xsd::cxx::tree::optional< bkm_counterpart_type > bkm_counterpart_optional;
  typedef ::xsd::cxx::tree::traits< bkm_counterpart_type, wchar_t > bkm_counterpart_traits;

  const bkm_counterpart_optional&
  bkm_counterpart () const;

  bkm_counterpart_optional&
  bkm_counterpart ();

  void
  bkm_counterpart (const bkm_counterpart_type& x);

  void
  bkm_counterpart (const bkm_counterpart_optional& x);

  void
  bkm_counterpart (::std::unique_ptr< bkm_counterpart_type > p);

  // bkm.user
  //
  typedef ::bkm_user bkm_user_type;
  typedef ::xsd::cxx::tree::optional< bkm_user_type > bkm_user_optional;
  typedef ::xsd::cxx::tree::traits< bkm_user_type, wchar_t > bkm_user_traits;

  const bkm_user_optional&
  bkm_user () const;

  bkm_user_optional&
  bkm_user ();

  void
  bkm_user (const bkm_user_type& x);

  void
  bkm_user (const bkm_user_optional& x);

  void
  bkm_user (::std::unique_ptr< bkm_user_type > p);

  // bkm.range
  //
  typedef ::bkm_range bkm_range_type;
  typedef ::xsd::cxx::tree::optional< bkm_range_type > bkm_range_optional;
  typedef ::xsd::cxx::tree::traits< bkm_range_type, wchar_t > bkm_range_traits;

  const bkm_range_optional&
  bkm_range () const;

  bkm_range_optional&
  bkm_range ();

  void
  bkm_range (const bkm_range_type& x);

  void
  bkm_range (const bkm_range_optional& x);

  void
  bkm_range (::std::unique_ptr< bkm_range_type > p);

  // id
  //
  typedef ::xml_schema::int_ id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  // externalkey
  //
  typedef ::externalkey_type externalkey_type;
  typedef ::xsd::cxx::tree::traits< externalkey_type, wchar_t > externalkey_traits;

  const externalkey_type&
  externalkey () const;

  externalkey_type&
  externalkey ();

  void
  externalkey (const externalkey_type& x);

  void
  externalkey (::std::unique_ptr< externalkey_type > p);

  // scope
  //
  typedef ::scope_type scope_type;
  typedef ::xsd::cxx::tree::traits< scope_type, wchar_t > scope_traits;

  const scope_type&
  scope () const;

  scope_type&
  scope ();

  void
  scope (const scope_type& x);

  void
  scope (::std::unique_ptr< scope_type > p);

  // scopekey
  //
  typedef ::externalkey_type scopekey_type;
  typedef ::xsd::cxx::tree::traits< scopekey_type, wchar_t > scopekey_traits;

  const scopekey_type&
  scopekey () const;

  scopekey_type&
  scopekey ();

  void
  scopekey (const scopekey_type& x);

  void
  scopekey (::std::unique_ptr< scopekey_type > p);

  // valuetypekey
  //
  typedef ::valuedata_type valuetypekey_type;
  typedef ::xsd::cxx::tree::traits< valuetypekey_type, wchar_t > valuetypekey_traits;

  const valuetypekey_type&
  valuetypekey () const;

  valuetypekey_type&
  valuetypekey ();

  void
  valuetypekey (const valuetypekey_type& x);

  void
  valuetypekey (::std::unique_ptr< valuetypekey_type > p);

  // matchfield
  //
  typedef ::matchfieldkeyvalue_type matchfield_type;
  typedef ::xsd::cxx::tree::optional< matchfield_type > matchfield_optional;
  typedef ::xsd::cxx::tree::traits< matchfield_type, wchar_t > matchfield_traits;

  const matchfield_optional&
  matchfield () const;

  matchfield_optional&
  matchfield ();

  void
  matchfield (const matchfield_type& x);

  void
  matchfield (const matchfield_optional& x);

  void
  matchfield (::std::unique_ptr< matchfield_type > p);

  // controlcode
  //
  typedef ::text256_type controlcode_type;
  typedef ::xsd::cxx::tree::optional< controlcode_type > controlcode_optional;
  typedef ::xsd::cxx::tree::traits< controlcode_type, wchar_t > controlcode_traits;

  const controlcode_optional&
  controlcode () const;

  controlcode_optional&
  controlcode ();

  void
  controlcode (const controlcode_type& x);

  void
  controlcode (const controlcode_optional& x);

  void
  controlcode (::std::unique_ptr< controlcode_type > p);

  // code
  //
  typedef ::text64_type code_type;
  typedef ::xsd::cxx::tree::optional< code_type > code_optional;
  typedef ::xsd::cxx::tree::traits< code_type, wchar_t > code_traits;

  const code_optional&
  code () const;

  code_optional&
  code ();

  void
  code (const code_type& x);

  void
  code (const code_optional& x);

  void
  code (::std::unique_ptr< code_type > p);

  // name
  //
  typedef ::text128_type name_type;
  typedef ::xsd::cxx::tree::optional< name_type > name_optional;
  typedef ::xsd::cxx::tree::traits< name_type, wchar_t > name_traits;

  const name_optional&
  name () const;

  name_optional&
  name ();

  void
  name (const name_type& x);

  void
  name (const name_optional& x);

  void
  name (::std::unique_ptr< name_type > p);

  // value
  //
  typedef ::text256_type value_type;
  typedef ::xsd::cxx::tree::optional< value_type > value_optional;
  typedef ::xsd::cxx::tree::traits< value_type, wchar_t > value_traits;

  const value_optional&
  value () const;

  value_optional&
  value ();

  void
  value (const value_type& x);

  void
  value (const value_optional& x);

  void
  value (::std::unique_ptr< value_type > p);

  // valuekey
  //
  typedef ::externalkey_type valuekey_type;
  typedef ::xsd::cxx::tree::traits< valuekey_type, wchar_t > valuekey_traits;

  const valuekey_type&
  valuekey () const;

  valuekey_type&
  valuekey ();

  void
  valuekey (const valuekey_type& x);

  void
  valuekey (::std::unique_ptr< valuekey_type > p);

  // desc
  //
  typedef ::xml_schema::string desc_type;
  typedef ::xsd::cxx::tree::optional< desc_type > desc_optional;
  typedef ::xsd::cxx::tree::traits< desc_type, wchar_t > desc_traits;

  const desc_optional&
  desc () const;

  desc_optional&
  desc ();

  void
  desc (const desc_type& x);

  void
  desc (const desc_optional& x);

  void
  desc (::std::unique_ptr< desc_type > p);

  // note
  //
  typedef ::xml_schema::string note_type;
  typedef ::xsd::cxx::tree::optional< note_type > note_optional;
  typedef ::xsd::cxx::tree::traits< note_type, wchar_t > note_traits;

  const note_optional&
  note () const;

  note_optional&
  note ();

  void
  note (const note_type& x);

  void
  note (const note_optional& x);

  void
  note (::std::unique_ptr< note_type > p);

  // remark
  //
  typedef ::xml_schema::string remark_type;
  typedef ::xsd::cxx::tree::optional< remark_type > remark_optional;
  typedef ::xsd::cxx::tree::traits< remark_type, wchar_t > remark_traits;

  const remark_optional&
  remark () const;

  remark_optional&
  remark ();

  void
  remark (const remark_type& x);

  void
  remark (const remark_optional& x);

  void
  remark (::std::unique_ptr< remark_type > p);

  // Constructors.
  //
  bkm_keyvalue (const externalkey_type&,
                const scope_type&,
                const scopekey_type&,
                const valuetypekey_type&,
                const valuekey_type&);

  bkm_keyvalue (const bkm_keyvalue& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual bkm_keyvalue*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  bkm_keyvalue&
  operator= (const bkm_keyvalue& x);

  virtual 
  ~bkm_keyvalue ();

  // Implementation.
  //
  protected:
  bkm_contact_optional bkm_contact_;
  bkm_counterpart_optional bkm_counterpart_;
  bkm_user_optional bkm_user_;
  bkm_range_optional bkm_range_;
  id_optional id_;
  ::xsd::cxx::tree::one< externalkey_type > externalkey_;
  ::xsd::cxx::tree::one< scope_type > scope_;
  ::xsd::cxx::tree::one< scopekey_type > scopekey_;
  ::xsd::cxx::tree::one< valuetypekey_type > valuetypekey_;
  matchfield_optional matchfield_;
  controlcode_optional controlcode_;
  code_optional code_;
  name_optional name_;
  value_optional value_;
  ::xsd::cxx::tree::one< valuekey_type > valuekey_;
  desc_optional desc_;
  note_optional note_;
  remark_optional remark_;
};

class ret_order: public ::xml_schema::type
{
  public:
  // id
  //
  typedef ::xml_schema::int_ id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  // externalkey
  //
  typedef ::externalkey_type externalkey_type;
  typedef ::xsd::cxx::tree::traits< externalkey_type, wchar_t > externalkey_traits;

  const externalkey_type&
  externalkey () const;

  externalkey_type&
  externalkey ();

  void
  externalkey (const externalkey_type& x);

  void
  externalkey (::std::unique_ptr< externalkey_type > p);

  // projectkey
  //
  typedef ::externalkey_type projectkey_type;
  typedef ::xsd::cxx::tree::optional< projectkey_type > projectkey_optional;
  typedef ::xsd::cxx::tree::traits< projectkey_type, wchar_t > projectkey_traits;

  const projectkey_optional&
  projectkey () const;

  projectkey_optional&
  projectkey ();

  void
  projectkey (const projectkey_type& x);

  void
  projectkey (const projectkey_optional& x);

  void
  projectkey (::std::unique_ptr< projectkey_type > p);

  // matchfield
  //
  typedef ::matchfieldorder_type matchfield_type;
  typedef ::xsd::cxx::tree::optional< matchfield_type > matchfield_optional;
  typedef ::xsd::cxx::tree::traits< matchfield_type, wchar_t > matchfield_traits;

  const matchfield_optional&
  matchfield () const;

  matchfield_optional&
  matchfield ();

  void
  matchfield (const matchfield_type& x);

  void
  matchfield (const matchfield_optional& x);

  void
  matchfield (::std::unique_ptr< matchfield_type > p);

  // partcode
  //
  typedef ::text32_type partcode_type;
  typedef ::xsd::cxx::tree::optional< partcode_type > partcode_optional;
  typedef ::xsd::cxx::tree::traits< partcode_type, wchar_t > partcode_traits;

  const partcode_optional&
  partcode () const;

  partcode_optional&
  partcode ();

  void
  partcode (const partcode_type& x);

  void
  partcode (const partcode_optional& x);

  void
  partcode (::std::unique_ptr< partcode_type > p);

  // controlcode
  //
  typedef ::text256_type controlcode_type;
  typedef ::xsd::cxx::tree::optional< controlcode_type > controlcode_optional;
  typedef ::xsd::cxx::tree::traits< controlcode_type, wchar_t > controlcode_traits;

  const controlcode_optional&
  controlcode () const;

  controlcode_optional&
  controlcode ();

  void
  controlcode (const controlcode_type& x);

  void
  controlcode (const controlcode_optional& x);

  void
  controlcode (::std::unique_ptr< controlcode_type > p);

  // customerkey
  //
  typedef ::externalkey_type customerkey_type;
  typedef ::xsd::cxx::tree::optional< customerkey_type > customerkey_optional;
  typedef ::xsd::cxx::tree::traits< customerkey_type, wchar_t > customerkey_traits;

  const customerkey_optional&
  customerkey () const;

  customerkey_optional&
  customerkey ();

  void
  customerkey (const customerkey_type& x);

  void
  customerkey (const customerkey_optional& x);

  void
  customerkey (::std::unique_ptr< customerkey_type > p);

  // customerkeyid
  //
  typedef ::text16_type customerkeyid_type;
  typedef ::xsd::cxx::tree::optional< customerkeyid_type > customerkeyid_optional;
  typedef ::xsd::cxx::tree::traits< customerkeyid_type, wchar_t > customerkeyid_traits;

  const customerkeyid_optional&
  customerkeyid () const;

  customerkeyid_optional&
  customerkeyid ();

  void
  customerkeyid (const customerkeyid_type& x);

  void
  customerkeyid (const customerkeyid_optional& x);

  void
  customerkeyid (::std::unique_ptr< customerkeyid_type > p);

  // customercode
  //
  typedef ::text64_type customercode_type;
  typedef ::xsd::cxx::tree::optional< customercode_type > customercode_optional;
  typedef ::xsd::cxx::tree::traits< customercode_type, wchar_t > customercode_traits;

  const customercode_optional&
  customercode () const;

  customercode_optional&
  customercode ();

  void
  customercode (const customercode_type& x);

  void
  customercode (const customercode_optional& x);

  void
  customercode (::std::unique_ptr< customercode_type > p);

  // customername
  //
  typedef ::text64_type customername_type;
  typedef ::xsd::cxx::tree::optional< customername_type > customername_optional;
  typedef ::xsd::cxx::tree::traits< customername_type, wchar_t > customername_traits;

  const customername_optional&
  customername () const;

  customername_optional&
  customername ();

  void
  customername (const customername_type& x);

  void
  customername (const customername_optional& x);

  void
  customername (::std::unique_ptr< customername_type > p);

  // customercounterpartkey
  //
  typedef ::externalkey_type customercounterpartkey_type;
  typedef ::xsd::cxx::tree::optional< customercounterpartkey_type > customercounterpartkey_optional;
  typedef ::xsd::cxx::tree::traits< customercounterpartkey_type, wchar_t > customercounterpartkey_traits;

  const customercounterpartkey_optional&
  customercounterpartkey () const;

  customercounterpartkey_optional&
  customercounterpartkey ();

  void
  customercounterpartkey (const customercounterpartkey_type& x);

  void
  customercounterpartkey (const customercounterpartkey_optional& x);

  void
  customercounterpartkey (::std::unique_ptr< customercounterpartkey_type > p);

  // number
  //
  typedef ::text16_type number_type;
  typedef ::xsd::cxx::tree::optional< number_type > number_optional;
  typedef ::xsd::cxx::tree::traits< number_type, wchar_t > number_traits;

  const number_optional&
  number () const;

  number_optional&
  number ();

  void
  number (const number_type& x);

  void
  number (const number_optional& x);

  void
  number (::std::unique_ptr< number_type > p);

  // order
  //
  typedef ::text128_type order_type;
  typedef ::xsd::cxx::tree::optional< order_type > order_optional;
  typedef ::xsd::cxx::tree::traits< order_type, wchar_t > order_traits;

  const order_optional&
  order () const;

  order_optional&
  order ();

  void
  order (const order_type& x);

  void
  order (const order_optional& x);

  void
  order (::std::unique_ptr< order_type > p);

  // contract
  //
  typedef ::text32_type contract_type;
  typedef ::xsd::cxx::tree::optional< contract_type > contract_optional;
  typedef ::xsd::cxx::tree::traits< contract_type, wchar_t > contract_traits;

  const contract_optional&
  contract () const;

  contract_optional&
  contract ();

  void
  contract (const contract_type& x);

  void
  contract (const contract_optional& x);

  void
  contract (::std::unique_ptr< contract_type > p);

  // extern1
  //
  typedef ::text128_type extern1_type;
  typedef ::xsd::cxx::tree::optional< extern1_type > extern1_optional;
  typedef ::xsd::cxx::tree::traits< extern1_type, wchar_t > extern1_traits;

  const extern1_optional&
  extern1 () const;

  extern1_optional&
  extern1 ();

  void
  extern1 (const extern1_type& x);

  void
  extern1 (const extern1_optional& x);

  void
  extern1 (::std::unique_ptr< extern1_type > p);

  // extern2
  //
  typedef ::text128_type extern2_type;
  typedef ::xsd::cxx::tree::optional< extern2_type > extern2_optional;
  typedef ::xsd::cxx::tree::traits< extern2_type, wchar_t > extern2_traits;

  const extern2_optional&
  extern2 () const;

  extern2_optional&
  extern2 ();

  void
  extern2 (const extern2_type& x);

  void
  extern2 (const extern2_optional& x);

  void
  extern2 (::std::unique_ptr< extern2_type > p);

  // extern3
  //
  typedef ::text128_type extern3_type;
  typedef ::xsd::cxx::tree::optional< extern3_type > extern3_optional;
  typedef ::xsd::cxx::tree::traits< extern3_type, wchar_t > extern3_traits;

  const extern3_optional&
  extern3 () const;

  extern3_optional&
  extern3 ();

  void
  extern3 (const extern3_type& x);

  void
  extern3 (const extern3_optional& x);

  void
  extern3 (::std::unique_ptr< extern3_type > p);

  // currency
  //
  typedef ::text16_type currency_type;
  typedef ::xsd::cxx::tree::optional< currency_type > currency_optional;
  typedef ::xsd::cxx::tree::traits< currency_type, wchar_t > currency_traits;

  const currency_optional&
  currency () const;

  currency_optional&
  currency ();

  void
  currency (const currency_type& x);

  void
  currency (const currency_optional& x);

  void
  currency (::std::unique_ptr< currency_type > p);

  // exchange
  //
  typedef ::decimal8_type exchange_type;
  typedef ::xsd::cxx::tree::optional< exchange_type > exchange_optional;
  typedef ::xsd::cxx::tree::traits< exchange_type, wchar_t > exchange_traits;

  const exchange_optional&
  exchange () const;

  exchange_optional&
  exchange ();

  void
  exchange (const exchange_type& x);

  void
  exchange (const exchange_optional& x);

  void
  exchange (::std::unique_ptr< exchange_type > p);

  // budget
  //
  typedef ::decimal_type budget_type;
  typedef ::xsd::cxx::tree::optional< budget_type > budget_optional;
  typedef ::xsd::cxx::tree::traits< budget_type, wchar_t > budget_traits;

  const budget_optional&
  budget () const;

  budget_optional&
  budget ();

  void
  budget (const budget_type& x);

  void
  budget (const budget_optional& x);

  void
  budget (::std::unique_ptr< budget_type > p);

  // budgetvat
  //
  typedef ::decimal_type budgetvat_type;
  typedef ::xsd::cxx::tree::optional< budgetvat_type > budgetvat_optional;
  typedef ::xsd::cxx::tree::traits< budgetvat_type, wchar_t > budgetvat_traits;

  const budgetvat_optional&
  budgetvat () const;

  budgetvat_optional&
  budgetvat ();

  void
  budgetvat (const budgetvat_type& x);

  void
  budgetvat (const budgetvat_optional& x);

  void
  budgetvat (::std::unique_ptr< budgetvat_type > p);

  // rental
  //
  typedef ::decimal_type rental_type;
  typedef ::xsd::cxx::tree::optional< rental_type > rental_optional;
  typedef ::xsd::cxx::tree::traits< rental_type, wchar_t > rental_traits;

  const rental_optional&
  rental () const;

  rental_optional&
  rental ();

  void
  rental (const rental_type& x);

  void
  rental (const rental_optional& x);

  void
  rental (::std::unique_ptr< rental_type > p);

  // rentalvat
  //
  typedef ::decimal_type rentalvat_type;
  typedef ::xsd::cxx::tree::optional< rentalvat_type > rentalvat_optional;
  typedef ::xsd::cxx::tree::traits< rentalvat_type, wchar_t > rentalvat_traits;

  const rentalvat_optional&
  rentalvat () const;

  rentalvat_optional&
  rentalvat ();

  void
  rentalvat (const rentalvat_type& x);

  void
  rentalvat (const rentalvat_optional& x);

  void
  rentalvat (::std::unique_ptr< rentalvat_type > p);

  // vatprz
  //
  typedef ::percent_type vatprz_type;
  typedef ::xsd::cxx::tree::optional< vatprz_type > vatprz_optional;
  typedef ::xsd::cxx::tree::traits< vatprz_type, wchar_t > vatprz_traits;

  const vatprz_optional&
  vatprz () const;

  vatprz_optional&
  vatprz ();

  void
  vatprz (const vatprz_type& x);

  void
  vatprz (const vatprz_optional& x);

  void
  vatprz (::std::unique_ptr< vatprz_type > p);

  // statuscode
  //
  typedef ::text8_type statuscode_type;
  typedef ::xsd::cxx::tree::optional< statuscode_type > statuscode_optional;
  typedef ::xsd::cxx::tree::traits< statuscode_type, wchar_t > statuscode_traits;

  const statuscode_optional&
  statuscode () const;

  statuscode_optional&
  statuscode ();

  void
  statuscode (const statuscode_type& x);

  void
  statuscode (const statuscode_optional& x);

  void
  statuscode (::std::unique_ptr< statuscode_type > p);

  // statusname
  //
  typedef ::text32_type statusname_type;
  typedef ::xsd::cxx::tree::optional< statusname_type > statusname_optional;
  typedef ::xsd::cxx::tree::traits< statusname_type, wchar_t > statusname_traits;

  const statusname_optional&
  statusname () const;

  statusname_optional&
  statusname ();

  void
  statusname (const statusname_type& x);

  void
  statusname (const statusname_optional& x);

  void
  statusname (::std::unique_ptr< statusname_type > p);

  // groupcode
  //
  typedef ::text8_type groupcode_type;
  typedef ::xsd::cxx::tree::optional< groupcode_type > groupcode_optional;
  typedef ::xsd::cxx::tree::traits< groupcode_type, wchar_t > groupcode_traits;

  const groupcode_optional&
  groupcode () const;

  groupcode_optional&
  groupcode ();

  void
  groupcode (const groupcode_type& x);

  void
  groupcode (const groupcode_optional& x);

  void
  groupcode (::std::unique_ptr< groupcode_type > p);

  // desc
  //
  typedef ::xml_schema::string desc_type;
  typedef ::xsd::cxx::tree::optional< desc_type > desc_optional;
  typedef ::xsd::cxx::tree::traits< desc_type, wchar_t > desc_traits;

  const desc_optional&
  desc () const;

  desc_optional&
  desc ();

  void
  desc (const desc_type& x);

  void
  desc (const desc_optional& x);

  void
  desc (::std::unique_ptr< desc_type > p);

  // note
  //
  typedef ::xml_schema::string note_type;
  typedef ::xsd::cxx::tree::optional< note_type > note_optional;
  typedef ::xsd::cxx::tree::traits< note_type, wchar_t > note_traits;

  const note_optional&
  note () const;

  note_optional&
  note ();

  void
  note (const note_type& x);

  void
  note (const note_optional& x);

  void
  note (::std::unique_ptr< note_type > p);

  // remark
  //
  typedef ::xml_schema::string remark_type;
  typedef ::xsd::cxx::tree::optional< remark_type > remark_optional;
  typedef ::xsd::cxx::tree::traits< remark_type, wchar_t > remark_traits;

  const remark_optional&
  remark () const;

  remark_optional&
  remark ();

  void
  remark (const remark_type& x);

  void
  remark (const remark_optional& x);

  void
  remark (::std::unique_ptr< remark_type > p);

  // Constructors.
  //
  ret_order (const externalkey_type&);

  ret_order (const ret_order& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  virtual ret_order*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ret_order&
  operator= (const ret_order& x);

  virtual 
  ~ret_order ();

  // Implementation.
  //
  protected:
  id_optional id_;
  ::xsd::cxx::tree::one< externalkey_type > externalkey_;
  projectkey_optional projectkey_;
  matchfield_optional matchfield_;
  partcode_optional partcode_;
  controlcode_optional controlcode_;
  customerkey_optional customerkey_;
  customerkeyid_optional customerkeyid_;
  customercode_optional customercode_;
  customername_optional customername_;
  customercounterpartkey_optional customercounterpartkey_;
  number_optional number_;
  order_optional order_;
  contract_optional contract_;
  extern1_optional extern1_;
  extern2_optional extern2_;
  extern3_optional extern3_;
  currency_optional currency_;
  exchange_optional exchange_;
  budget_optional budget_;
  budgetvat_optional budgetvat_;
  rental_optional rental_;
  rentalvat_optional rentalvat_;
  vatprz_optional vatprz_;
  statuscode_optional statuscode_;
  statusname_optional statusname_;
  groupcode_optional groupcode_;
  desc_optional desc_;
  note_optional note_;
  remark_optional remark_;
};

class ret_invoice: public ::xml_schema::type
{
  public:
  // bkm.keyvalue
  //
  typedef ::bkm_keyvalue bkm_keyvalue_type;
  typedef ::xsd::cxx::tree::sequence< bkm_keyvalue_type > bkm_keyvalue_sequence;
  typedef bkm_keyvalue_sequence::iterator bkm_keyvalue_iterator;
  typedef bkm_keyvalue_sequence::const_iterator bkm_keyvalue_const_iterator;
  typedef ::xsd::cxx::tree::traits< bkm_keyvalue_type, wchar_t > bkm_keyvalue_traits;

  const bkm_keyvalue_sequence&
  bkm_keyvalue () const;

  bkm_keyvalue_sequence&
  bkm_keyvalue ();

  void
  bkm_keyvalue (const bkm_keyvalue_sequence& s);

  // id
  //
  typedef ::xml_schema::int_ id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  // externalkey
  //
  typedef ::externalkey_type externalkey_type;
  typedef ::xsd::cxx::tree::traits< externalkey_type, wchar_t > externalkey_traits;

  const externalkey_type&
  externalkey () const;

  externalkey_type&
  externalkey ();

  void
  externalkey (const externalkey_type& x);

  void
  externalkey (::std::unique_ptr< externalkey_type > p);

  // matchfield
  //
  typedef ::matchfieldinvoice_type matchfield_type;
  typedef ::xsd::cxx::tree::optional< matchfield_type > matchfield_optional;
  typedef ::xsd::cxx::tree::traits< matchfield_type, wchar_t > matchfield_traits;

  const matchfield_optional&
  matchfield () const;

  matchfield_optional&
  matchfield ();

  void
  matchfield (const matchfield_type& x);

  void
  matchfield (const matchfield_optional& x);

  void
  matchfield (::std::unique_ptr< matchfield_type > p);

  // controlcode
  //
  typedef ::text256_type controlcode_type;
  typedef ::xsd::cxx::tree::optional< controlcode_type > controlcode_optional;
  typedef ::xsd::cxx::tree::traits< controlcode_type, wchar_t > controlcode_traits;

  const controlcode_optional&
  controlcode () const;

  controlcode_optional&
  controlcode ();

  void
  controlcode (const controlcode_type& x);

  void
  controlcode (const controlcode_optional& x);

  void
  controlcode (::std::unique_ptr< controlcode_type > p);

  // projectkey
  //
  typedef ::externalkey_type projectkey_type;
  typedef ::xsd::cxx::tree::optional< projectkey_type > projectkey_optional;
  typedef ::xsd::cxx::tree::traits< projectkey_type, wchar_t > projectkey_traits;

  const projectkey_optional&
  projectkey () const;

  projectkey_optional&
  projectkey ();

  void
  projectkey (const projectkey_type& x);

  void
  projectkey (const projectkey_optional& x);

  void
  projectkey (::std::unique_ptr< projectkey_type > p);

  // orderkey
  //
  typedef ::externalkey_type orderkey_type;
  typedef ::xsd::cxx::tree::optional< orderkey_type > orderkey_optional;
  typedef ::xsd::cxx::tree::traits< orderkey_type, wchar_t > orderkey_traits;

  const orderkey_optional&
  orderkey () const;

  orderkey_optional&
  orderkey ();

  void
  orderkey (const orderkey_type& x);

  void
  orderkey (const orderkey_optional& x);

  void
  orderkey (::std::unique_ptr< orderkey_type > p);

  // external
  //
  typedef ::text256_type external_type;
  typedef ::xsd::cxx::tree::optional< external_type > external_optional;
  typedef ::xsd::cxx::tree::traits< external_type, wchar_t > external_traits;

  const external_optional&
  external () const;

  external_optional&
  external ();

  void
  external (const external_type& x);

  void
  external (const external_optional& x);

  void
  external (::std::unique_ptr< external_type > p);

  // calculation
  //
  typedef ::text256_type calculation_type;
  typedef ::xsd::cxx::tree::optional< calculation_type > calculation_optional;
  typedef ::xsd::cxx::tree::traits< calculation_type, wchar_t > calculation_traits;

  const calculation_optional&
  calculation () const;

  calculation_optional&
  calculation ();

  void
  calculation (const calculation_type& x);

  void
  calculation (const calculation_optional& x);

  void
  calculation (::std::unique_ptr< calculation_type > p);

  // typecode
  //
  typedef ::invoicetype_type typecode_type;
  typedef ::xsd::cxx::tree::optional< typecode_type > typecode_optional;
  typedef ::xsd::cxx::tree::traits< typecode_type, wchar_t > typecode_traits;

  const typecode_optional&
  typecode () const;

  typecode_optional&
  typecode ();

  void
  typecode (const typecode_type& x);

  void
  typecode (const typecode_optional& x);

  void
  typecode (::std::unique_ptr< typecode_type > p);

  // typecount
  //
  typedef ::xml_schema::short_ typecount_type;
  typedef ::xsd::cxx::tree::optional< typecount_type > typecount_optional;
  typedef ::xsd::cxx::tree::traits< typecount_type, wchar_t > typecount_traits;

  const typecount_optional&
  typecount () const;

  typecount_optional&
  typecount ();

  void
  typecount (const typecount_type& x);

  void
  typecount (const typecount_optional& x);

  // number
  //
  typedef ::text16_type number_type;
  typedef ::xsd::cxx::tree::optional< number_type > number_optional;
  typedef ::xsd::cxx::tree::traits< number_type, wchar_t > number_traits;

  const number_optional&
  number () const;

  number_optional&
  number ();

  void
  number (const number_type& x);

  void
  number (const number_optional& x);

  void
  number (::std::unique_ptr< number_type > p);

  // name
  //
  typedef ::text128_type name_type;
  typedef ::xsd::cxx::tree::optional< name_type > name_optional;
  typedef ::xsd::cxx::tree::traits< name_type, wchar_t > name_traits;

  const name_optional&
  name () const;

  name_optional&
  name ();

  void
  name (const name_type& x);

  void
  name (const name_optional& x);

  void
  name (::std::unique_ptr< name_type > p);

  // invoicedate
  //
  typedef ::xml_schema::date invoicedate_type;
  typedef ::xsd::cxx::tree::optional< invoicedate_type > invoicedate_optional;
  typedef ::xsd::cxx::tree::traits< invoicedate_type, wchar_t > invoicedate_traits;

  const invoicedate_optional&
  invoicedate () const;

  invoicedate_optional&
  invoicedate ();

  void
  invoicedate (const invoicedate_type& x);

  void
  invoicedate (const invoicedate_optional& x);

  void
  invoicedate (::std::unique_ptr< invoicedate_type > p);

  // invoicevat
  //
  typedef ::decimal_type invoicevat_type;
  typedef ::xsd::cxx::tree::optional< invoicevat_type > invoicevat_optional;
  typedef ::xsd::cxx::tree::traits< invoicevat_type, wchar_t > invoicevat_traits;

  const invoicevat_optional&
  invoicevat () const;

  invoicevat_optional&
  invoicevat ();

  void
  invoicevat (const invoicevat_type& x);

  void
  invoicevat (const invoicevat_optional& x);

  void
  invoicevat (::std::unique_ptr< invoicevat_type > p);

  // targetdate
  //
  typedef ::xml_schema::date targetdate_type;
  typedef ::xsd::cxx::tree::optional< targetdate_type > targetdate_optional;
  typedef ::xsd::cxx::tree::traits< targetdate_type, wchar_t > targetdate_traits;

  const targetdate_optional&
  targetdate () const;

  targetdate_optional&
  targetdate ();

  void
  targetdate (const targetdate_type& x);

  void
  targetdate (const targetdate_optional& x);

  void
  targetdate (::std::unique_ptr< targetdate_type > p);

  // payment
  //
  typedef ::decimal_type payment_type;
  typedef ::xsd::cxx::tree::optional< payment_type > payment_optional;
  typedef ::xsd::cxx::tree::traits< payment_type, wchar_t > payment_traits;

  const payment_optional&
  payment () const;

  payment_optional&
  payment ();

  void
  payment (const payment_type& x);

  void
  payment (const payment_optional& x);

  void
  payment (::std::unique_ptr< payment_type > p);

  // paymentdate
  //
  typedef ::xml_schema::date paymentdate_type;
  typedef ::xsd::cxx::tree::optional< paymentdate_type > paymentdate_optional;
  typedef ::xsd::cxx::tree::traits< paymentdate_type, wchar_t > paymentdate_traits;

  const paymentdate_optional&
  paymentdate () const;

  paymentdate_optional&
  paymentdate ();

  void
  paymentdate (const paymentdate_type& x);

  void
  paymentdate (const paymentdate_optional& x);

  void
  paymentdate (::std::unique_ptr< paymentdate_type > p);

  // paymentvat
  //
  typedef ::percent_type paymentvat_type;
  typedef ::xsd::cxx::tree::optional< paymentvat_type > paymentvat_optional;
  typedef ::xsd::cxx::tree::traits< paymentvat_type, wchar_t > paymentvat_traits;

  const paymentvat_optional&
  paymentvat () const;

  paymentvat_optional&
  paymentvat ();

  void
  paymentvat (const paymentvat_type& x);

  void
  paymentvat (const paymentvat_optional& x);

  void
  paymentvat (::std::unique_ptr< paymentvat_type > p);

  // extern1
  //
  typedef ::text128_type extern1_type;
  typedef ::xsd::cxx::tree::optional< extern1_type > extern1_optional;
  typedef ::xsd::cxx::tree::traits< extern1_type, wchar_t > extern1_traits;

  const extern1_optional&
  extern1 () const;

  extern1_optional&
  extern1 ();

  void
  extern1 (const extern1_type& x);

  void
  extern1 (const extern1_optional& x);

  void
  extern1 (::std::unique_ptr< extern1_type > p);

  // extern2
  //
  typedef ::text128_type extern2_type;
  typedef ::xsd::cxx::tree::optional< extern2_type > extern2_optional;
  typedef ::xsd::cxx::tree::traits< extern2_type, wchar_t > extern2_traits;

  const extern2_optional&
  extern2 () const;

  extern2_optional&
  extern2 ();

  void
  extern2 (const extern2_type& x);

  void
  extern2 (const extern2_optional& x);

  void
  extern2 (::std::unique_ptr< extern2_type > p);

  // extern3
  //
  typedef ::text128_type extern3_type;
  typedef ::xsd::cxx::tree::optional< extern3_type > extern3_optional;
  typedef ::xsd::cxx::tree::traits< extern3_type, wchar_t > extern3_traits;

  const extern3_optional&
  extern3 () const;

  extern3_optional&
  extern3 ();

  void
  extern3 (const extern3_type& x);

  void
  extern3 (const extern3_optional& x);

  void
  extern3 (::std::unique_ptr< extern3_type > p);

  // lstgyear
  //
  typedef ::text4_type lstgyear_type;
  typedef ::xsd::cxx::tree::optional< lstgyear_type > lstgyear_optional;
  typedef ::xsd::cxx::tree::traits< lstgyear_type, wchar_t > lstgyear_traits;

  const lstgyear_optional&
  lstgyear () const;

  lstgyear_optional&
  lstgyear ();

  void
  lstgyear (const lstgyear_type& x);

  void
  lstgyear (const lstgyear_optional& x);

  void
  lstgyear (::std::unique_ptr< lstgyear_type > p);

  // barcode
  //
  typedef ::text128_type barcode_type;
  typedef ::xsd::cxx::tree::optional< barcode_type > barcode_optional;
  typedef ::xsd::cxx::tree::traits< barcode_type, wchar_t > barcode_traits;

  const barcode_optional&
  barcode () const;

  barcode_optional&
  barcode ();

  void
  barcode (const barcode_type& x);

  void
  barcode (const barcode_optional& x);

  void
  barcode (::std::unique_ptr< barcode_type > p);

  // statuscode
  //
  typedef ::text16_type statuscode_type;
  typedef ::xsd::cxx::tree::optional< statuscode_type > statuscode_optional;
  typedef ::xsd::cxx::tree::traits< statuscode_type, wchar_t > statuscode_traits;

  const statuscode_optional&
  statuscode () const;

  statuscode_optional&
  statuscode ();

  void
  statuscode (const statuscode_type& x);

  void
  statuscode (const statuscode_optional& x);

  void
  statuscode (::std::unique_ptr< statuscode_type > p);

  // statusname
  //
  typedef ::text32_type statusname_type;
  typedef ::xsd::cxx::tree::optional< statusname_type > statusname_optional;
  typedef ::xsd::cxx::tree::traits< statusname_type, wchar_t > statusname_traits;

  const statusname_optional&
  statusname () const;

  statusname_optional&
  statusname ();

  void
  statusname (const statusname_type& x);

  void
  statusname (const statusname_optional& x);

  void
  statusname (::std::unique_ptr< statusname_type > p);

  // deducted
  //
  typedef ::decimal_type deducted_type;
  typedef ::xsd::cxx::tree::optional< deducted_type > deducted_optional;
  typedef ::xsd::cxx::tree::traits< deducted_type, wchar_t > deducted_traits;

  const deducted_optional&
  deducted () const;

  deducted_optional&
  deducted ();

  void
  deducted (const deducted_type& x);

  void
  deducted (const deducted_optional& x);

  void
  deducted (::std::unique_ptr< deducted_type > p);

  // deductedvat
  //
  typedef ::decimal_type deductedvat_type;
  typedef ::xsd::cxx::tree::optional< deductedvat_type > deductedvat_optional;
  typedef ::xsd::cxx::tree::traits< deductedvat_type, wchar_t > deductedvat_traits;

  const deductedvat_optional&
  deductedvat () const;

  deductedvat_optional&
  deductedvat ();

  void
  deductedvat (const deductedvat_type& x);

  void
  deductedvat (const deductedvat_optional& x);

  void
  deductedvat (::std::unique_ptr< deductedvat_type > p);

  // totalnto
  //
  typedef ::decimal_type totalnto_type;
  typedef ::xsd::cxx::tree::optional< totalnto_type > totalnto_optional;
  typedef ::xsd::cxx::tree::traits< totalnto_type, wchar_t > totalnto_traits;

  const totalnto_optional&
  totalnto () const;

  totalnto_optional&
  totalnto ();

  void
  totalnto (const totalnto_type& x);

  void
  totalnto (const totalnto_optional& x);

  void
  totalnto (::std::unique_ptr< totalnto_type > p);

  // totalvat
  //
  typedef ::decimal_type totalvat_type;
  typedef ::xsd::cxx::tree::optional< totalvat_type > totalvat_optional;
  typedef ::xsd::cxx::tree::traits< totalvat_type, wchar_t > totalvat_traits;

  const totalvat_optional&
  totalvat () const;

  totalvat_optional&
  totalvat ();

  void
  totalvat (const totalvat_type& x);

  void
  totalvat (const totalvat_optional& x);

  void
  totalvat (::std::unique_ptr< totalvat_type > p);

  // vatprz
  //
  typedef ::percent_type vatprz_type;
  typedef ::xsd::cxx::tree::optional< vatprz_type > vatprz_optional;
  typedef ::xsd::cxx::tree::traits< vatprz_type, wchar_t > vatprz_traits;

  const vatprz_optional&
  vatprz () const;

  vatprz_optional&
  vatprz ();

  void
  vatprz (const vatprz_type& x);

  void
  vatprz (const vatprz_optional& x);

  void
  vatprz (::std::unique_ptr< vatprz_type > p);

  // rateprz
  //
  typedef ::percent_type rateprz_type;
  typedef ::xsd::cxx::tree::optional< rateprz_type > rateprz_optional;
  typedef ::xsd::cxx::tree::traits< rateprz_type, wchar_t > rateprz_traits;

  const rateprz_optional&
  rateprz () const;

  rateprz_optional&
  rateprz ();

  void
  rateprz (const rateprz_type& x);

  void
  rateprz (const rateprz_optional& x);

  void
  rateprz (::std::unique_ptr< rateprz_type > p);

  // currency
  //
  typedef ::text16_type currency_type;
  typedef ::xsd::cxx::tree::optional< currency_type > currency_optional;
  typedef ::xsd::cxx::tree::traits< currency_type, wchar_t > currency_traits;

  const currency_optional&
  currency () const;

  currency_optional&
  currency ();

  void
  currency (const currency_type& x);

  void
  currency (const currency_optional& x);

  void
  currency (::std::unique_ptr< currency_type > p);

  // exchange
  //
  typedef ::decimal8_type exchange_type;
  typedef ::xsd::cxx::tree::optional< exchange_type > exchange_optional;
  typedef ::xsd::cxx::tree::traits< exchange_type, wchar_t > exchange_traits;

  const exchange_optional&
  exchange () const;

  exchange_optional&
  exchange ();

  void
  exchange (const exchange_type& x);

  void
  exchange (const exchange_optional& x);

  void
  exchange (::std::unique_ptr< exchange_type > p);

  // desc
  //
  typedef ::xml_schema::string desc_type;
  typedef ::xsd::cxx::tree::optional< desc_type > desc_optional;
  typedef ::xsd::cxx::tree::traits< desc_type, wchar_t > desc_traits;

  const desc_optional&
  desc () const;

  desc_optional&
  desc ();

  void
  desc (const desc_type& x);

  void
  desc (const desc_optional& x);

  void
  desc (::std::unique_ptr< desc_type > p);

  // note
  //
  typedef ::xml_schema::string note_type;
  typedef ::xsd::cxx::tree::optional< note_type > note_optional;
  typedef ::xsd::cxx::tree::traits< note_type, wchar_t > note_traits;

  const note_optional&
  note () const;

  note_optional&
  note ();

  void
  note (const note_type& x);

  void
  note (const note_optional& x);

  void
  note (::std::unique_ptr< note_type > p);

  // remark
  //
  typedef ::xml_schema::string remark_type;
  typedef ::xsd::cxx::tree::optional< remark_type > remark_optional;
  typedef ::xsd::cxx::tree::traits< remark_type, wchar_t > remark_traits;

  const remark_optional&
  remark () const;

  remark_optional&
  remark ();

  void
  remark (const remark_type& x);

  void
  remark (const remark_optional& x);

  void
  remark (::std::unique_ptr< remark_type > p);

  // skontoperiod
  //
  typedef ::xml_schema::int_ skontoperiod_type;
  typedef ::xsd::cxx::tree::optional< skontoperiod_type > skontoperiod_optional;
  typedef ::xsd::cxx::tree::traits< skontoperiod_type, wchar_t > skontoperiod_traits;

  const skontoperiod_optional&
  skontoperiod () const;

  skontoperiod_optional&
  skontoperiod ();

  void
  skontoperiod (const skontoperiod_type& x);

  void
  skontoperiod (const skontoperiod_optional& x);

  // checkperiod
  //
  typedef ::xml_schema::int_ checkperiod_type;
  typedef ::xsd::cxx::tree::optional< checkperiod_type > checkperiod_optional;
  typedef ::xsd::cxx::tree::traits< checkperiod_type, wchar_t > checkperiod_traits;

  const checkperiod_optional&
  checkperiod () const;

  checkperiod_optional&
  checkperiod ();

  void
  checkperiod (const checkperiod_type& x);

  void
  checkperiod (const checkperiod_optional& x);

  // documentdate
  //
  typedef ::xml_schema::date documentdate_type;
  typedef ::xsd::cxx::tree::optional< documentdate_type > documentdate_optional;
  typedef ::xsd::cxx::tree::traits< documentdate_type, wchar_t > documentdate_traits;

  const documentdate_optional&
  documentdate () const;

  documentdate_optional&
  documentdate ();

  void
  documentdate (const documentdate_type& x);

  void
  documentdate (const documentdate_optional& x);

  void
  documentdate (::std::unique_ptr< documentdate_type > p);

  // Constructors.
  //
  ret_invoice (const externalkey_type&);

  ret_invoice (const ret_invoice& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  virtual ret_invoice*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ret_invoice&
  operator= (const ret_invoice& x);

  virtual 
  ~ret_invoice ();

  // Implementation.
  //
  protected:
  bkm_keyvalue_sequence bkm_keyvalue_;
  id_optional id_;
  ::xsd::cxx::tree::one< externalkey_type > externalkey_;
  matchfield_optional matchfield_;
  controlcode_optional controlcode_;
  projectkey_optional projectkey_;
  orderkey_optional orderkey_;
  external_optional external_;
  calculation_optional calculation_;
  typecode_optional typecode_;
  typecount_optional typecount_;
  number_optional number_;
  name_optional name_;
  invoicedate_optional invoicedate_;
  invoicevat_optional invoicevat_;
  targetdate_optional targetdate_;
  payment_optional payment_;
  paymentdate_optional paymentdate_;
  paymentvat_optional paymentvat_;
  extern1_optional extern1_;
  extern2_optional extern2_;
  extern3_optional extern3_;
  lstgyear_optional lstgyear_;
  barcode_optional barcode_;
  statuscode_optional statuscode_;
  statusname_optional statusname_;
  deducted_optional deducted_;
  deductedvat_optional deductedvat_;
  totalnto_optional totalnto_;
  totalvat_optional totalvat_;
  vatprz_optional vatprz_;
  rateprz_optional rateprz_;
  currency_optional currency_;
  exchange_optional exchange_;
  desc_optional desc_;
  note_optional note_;
  remark_optional remark_;
  skontoperiod_optional skontoperiod_;
  checkperiod_optional checkperiod_;
  documentdate_optional documentdate_;
};

class ret_payment: public ::xml_schema::type
{
  public:
  // externalkey
  //
  typedef ::externalkey_type externalkey_type;
  typedef ::xsd::cxx::tree::traits< externalkey_type, wchar_t > externalkey_traits;

  const externalkey_type&
  externalkey () const;

  externalkey_type&
  externalkey ();

  void
  externalkey (const externalkey_type& x);

  void
  externalkey (::std::unique_ptr< externalkey_type > p);

  // invoicekey
  //
  typedef ::externalkey_type invoicekey_type;
  typedef ::xsd::cxx::tree::traits< invoicekey_type, wchar_t > invoicekey_traits;

  const invoicekey_type&
  invoicekey () const;

  invoicekey_type&
  invoicekey ();

  void
  invoicekey (const invoicekey_type& x);

  void
  invoicekey (::std::unique_ptr< invoicekey_type > p);

  // controlcode
  //
  typedef ::text256_type controlcode_type;
  typedef ::xsd::cxx::tree::optional< controlcode_type > controlcode_optional;
  typedef ::xsd::cxx::tree::traits< controlcode_type, wchar_t > controlcode_traits;

  const controlcode_optional&
  controlcode () const;

  controlcode_optional&
  controlcode ();

  void
  controlcode (const controlcode_type& x);

  void
  controlcode (const controlcode_optional& x);

  void
  controlcode (::std::unique_ptr< controlcode_type > p);

  // number
  //
  typedef ::text16_type number_type;
  typedef ::xsd::cxx::tree::optional< number_type > number_optional;
  typedef ::xsd::cxx::tree::traits< number_type, wchar_t > number_traits;

  const number_optional&
  number () const;

  number_optional&
  number ();

  void
  number (const number_type& x);

  void
  number (const number_optional& x);

  void
  number (::std::unique_ptr< number_type > p);

  // external
  //
  typedef ::text256_type external_type;
  typedef ::xsd::cxx::tree::optional< external_type > external_optional;
  typedef ::xsd::cxx::tree::traits< external_type, wchar_t > external_traits;

  const external_optional&
  external () const;

  external_optional&
  external ();

  void
  external (const external_type& x);

  void
  external (const external_optional& x);

  void
  external (::std::unique_ptr< external_type > p);

  // extern1
  //
  typedef ::text128_type extern1_type;
  typedef ::xsd::cxx::tree::optional< extern1_type > extern1_optional;
  typedef ::xsd::cxx::tree::traits< extern1_type, wchar_t > extern1_traits;

  const extern1_optional&
  extern1 () const;

  extern1_optional&
  extern1 ();

  void
  extern1 (const extern1_type& x);

  void
  extern1 (const extern1_optional& x);

  void
  extern1 (::std::unique_ptr< extern1_type > p);

  // extern2
  //
  typedef ::text128_type extern2_type;
  typedef ::xsd::cxx::tree::optional< extern2_type > extern2_optional;
  typedef ::xsd::cxx::tree::traits< extern2_type, wchar_t > extern2_traits;

  const extern2_optional&
  extern2 () const;

  extern2_optional&
  extern2 ();

  void
  extern2 (const extern2_type& x);

  void
  extern2 (const extern2_optional& x);

  void
  extern2 (::std::unique_ptr< extern2_type > p);

  // extern3
  //
  typedef ::text128_type extern3_type;
  typedef ::xsd::cxx::tree::optional< extern3_type > extern3_optional;
  typedef ::xsd::cxx::tree::traits< extern3_type, wchar_t > extern3_traits;

  const extern3_optional&
  extern3 () const;

  extern3_optional&
  extern3 ();

  void
  extern3 (const extern3_type& x);

  void
  extern3 (const extern3_optional& x);

  void
  extern3 (::std::unique_ptr< extern3_type > p);

  // statuscode
  //
  typedef ::text16_type statuscode_type;
  typedef ::xsd::cxx::tree::optional< statuscode_type > statuscode_optional;
  typedef ::xsd::cxx::tree::traits< statuscode_type, wchar_t > statuscode_traits;

  const statuscode_optional&
  statuscode () const;

  statuscode_optional&
  statuscode ();

  void
  statuscode (const statuscode_type& x);

  void
  statuscode (const statuscode_optional& x);

  void
  statuscode (::std::unique_ptr< statuscode_type > p);

  // payment
  //
  typedef ::decimal_type payment_type;
  typedef ::xsd::cxx::tree::optional< payment_type > payment_optional;
  typedef ::xsd::cxx::tree::traits< payment_type, wchar_t > payment_traits;

  const payment_optional&
  payment () const;

  payment_optional&
  payment ();

  void
  payment (const payment_type& x);

  void
  payment (const payment_optional& x);

  void
  payment (::std::unique_ptr< payment_type > p);

  // paymentvat
  //
  typedef ::percent_type paymentvat_type;
  typedef ::xsd::cxx::tree::optional< paymentvat_type > paymentvat_optional;
  typedef ::xsd::cxx::tree::traits< paymentvat_type, wchar_t > paymentvat_traits;

  const paymentvat_optional&
  paymentvat () const;

  paymentvat_optional&
  paymentvat ();

  void
  paymentvat (const paymentvat_type& x);

  void
  paymentvat (const paymentvat_optional& x);

  void
  paymentvat (::std::unique_ptr< paymentvat_type > p);

  // paymentdate
  //
  typedef ::xml_schema::date paymentdate_type;
  typedef ::xsd::cxx::tree::optional< paymentdate_type > paymentdate_optional;
  typedef ::xsd::cxx::tree::traits< paymentdate_type, wchar_t > paymentdate_traits;

  const paymentdate_optional&
  paymentdate () const;

  paymentdate_optional&
  paymentdate ();

  void
  paymentdate (const paymentdate_type& x);

  void
  paymentdate (const paymentdate_optional& x);

  void
  paymentdate (::std::unique_ptr< paymentdate_type > p);

  // currency
  //
  typedef ::text16_type currency_type;
  typedef ::xsd::cxx::tree::optional< currency_type > currency_optional;
  typedef ::xsd::cxx::tree::traits< currency_type, wchar_t > currency_traits;

  const currency_optional&
  currency () const;

  currency_optional&
  currency ();

  void
  currency (const currency_type& x);

  void
  currency (const currency_optional& x);

  void
  currency (::std::unique_ptr< currency_type > p);

  // exchange
  //
  typedef ::decimal8_type exchange_type;
  typedef ::xsd::cxx::tree::optional< exchange_type > exchange_optional;
  typedef ::xsd::cxx::tree::traits< exchange_type, wchar_t > exchange_traits;

  const exchange_optional&
  exchange () const;

  exchange_optional&
  exchange ();

  void
  exchange (const exchange_type& x);

  void
  exchange (const exchange_optional& x);

  void
  exchange (::std::unique_ptr< exchange_type > p);

  // desc
  //
  typedef ::xml_schema::string desc_type;
  typedef ::xsd::cxx::tree::optional< desc_type > desc_optional;
  typedef ::xsd::cxx::tree::traits< desc_type, wchar_t > desc_traits;

  const desc_optional&
  desc () const;

  desc_optional&
  desc ();

  void
  desc (const desc_type& x);

  void
  desc (const desc_optional& x);

  void
  desc (::std::unique_ptr< desc_type > p);

  // note
  //
  typedef ::xml_schema::string note_type;
  typedef ::xsd::cxx::tree::optional< note_type > note_optional;
  typedef ::xsd::cxx::tree::traits< note_type, wchar_t > note_traits;

  const note_optional&
  note () const;

  note_optional&
  note ();

  void
  note (const note_type& x);

  void
  note (const note_optional& x);

  void
  note (::std::unique_ptr< note_type > p);

  // remark
  //
  typedef ::xml_schema::string remark_type;
  typedef ::xsd::cxx::tree::optional< remark_type > remark_optional;
  typedef ::xsd::cxx::tree::traits< remark_type, wchar_t > remark_traits;

  const remark_optional&
  remark () const;

  remark_optional&
  remark ();

  void
  remark (const remark_type& x);

  void
  remark (const remark_optional& x);

  void
  remark (::std::unique_ptr< remark_type > p);

  // Constructors.
  //
  ret_payment (const externalkey_type&,
               const invoicekey_type&);

  ret_payment (const ret_payment& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  virtual ret_payment*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ret_payment&
  operator= (const ret_payment& x);

  virtual 
  ~ret_payment ();

  // Implementation.
  //
  protected:
  ::xsd::cxx::tree::one< externalkey_type > externalkey_;
  ::xsd::cxx::tree::one< invoicekey_type > invoicekey_;
  controlcode_optional controlcode_;
  number_optional number_;
  external_optional external_;
  extern1_optional extern1_;
  extern2_optional extern2_;
  extern3_optional extern3_;
  statuscode_optional statuscode_;
  payment_optional payment_;
  paymentvat_optional paymentvat_;
  paymentdate_optional paymentdate_;
  currency_optional currency_;
  exchange_optional exchange_;
  desc_optional desc_;
  note_optional note_;
  remark_optional remark_;
};

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

void
operator<< (::xercesc::DOMElement&, const bool_type&);

void
operator<< (::xercesc::DOMAttr&, const bool_type&);

void
operator<< (::xml_schema::list_stream&,
            const bool_type&);

void
operator<< (::xercesc::DOMElement&, const collect_type&);

void
operator<< (::xercesc::DOMAttr&, const collect_type&);

void
operator<< (::xml_schema::list_stream&,
            const collect_type&);

void
operator<< (::xercesc::DOMElement&, const text256_type&);

void
operator<< (::xercesc::DOMAttr&, const text256_type&);

void
operator<< (::xml_schema::list_stream&,
            const text256_type&);

void
operator<< (::xercesc::DOMElement&, const text128_type&);

void
operator<< (::xercesc::DOMAttr&, const text128_type&);

void
operator<< (::xml_schema::list_stream&,
            const text128_type&);

void
operator<< (::xercesc::DOMElement&, const text64_type&);

void
operator<< (::xercesc::DOMAttr&, const text64_type&);

void
operator<< (::xml_schema::list_stream&,
            const text64_type&);

void
operator<< (::xercesc::DOMElement&, const text48_type&);

void
operator<< (::xercesc::DOMAttr&, const text48_type&);

void
operator<< (::xml_schema::list_stream&,
            const text48_type&);

void
operator<< (::xercesc::DOMElement&, const text32_type&);

void
operator<< (::xercesc::DOMAttr&, const text32_type&);

void
operator<< (::xml_schema::list_stream&,
            const text32_type&);

void
operator<< (::xercesc::DOMElement&, const text16_type&);

void
operator<< (::xercesc::DOMAttr&, const text16_type&);

void
operator<< (::xml_schema::list_stream&,
            const text16_type&);

void
operator<< (::xercesc::DOMElement&, const text12_type&);

void
operator<< (::xercesc::DOMAttr&, const text12_type&);

void
operator<< (::xml_schema::list_stream&,
            const text12_type&);

void
operator<< (::xercesc::DOMElement&, const text8_type&);

void
operator<< (::xercesc::DOMAttr&, const text8_type&);

void
operator<< (::xml_schema::list_stream&,
            const text8_type&);

void
operator<< (::xercesc::DOMElement&, const text4_type&);

void
operator<< (::xercesc::DOMAttr&, const text4_type&);

void
operator<< (::xml_schema::list_stream&,
            const text4_type&);

void
operator<< (::xercesc::DOMElement&, const invoicetype_type&);

void
operator<< (::xercesc::DOMAttr&, const invoicetype_type&);

void
operator<< (::xml_schema::list_stream&,
            const invoicetype_type&);

void
operator<< (::xercesc::DOMElement&, const scope_type&);

void
operator<< (::xercesc::DOMAttr&, const scope_type&);

void
operator<< (::xml_schema::list_stream&,
            const scope_type&);

void
operator<< (::xercesc::DOMElement&, const valuedata_type&);

void
operator<< (::xercesc::DOMAttr&, const valuedata_type&);

void
operator<< (::xml_schema::list_stream&,
            const valuedata_type&);

void
operator<< (::xercesc::DOMElement&, const normdata_type&);

void
operator<< (::xercesc::DOMAttr&, const normdata_type&);

void
operator<< (::xml_schema::list_stream&,
            const normdata_type&);

void
operator<< (::xercesc::DOMElement&, const externalkey_type&);

void
operator<< (::xercesc::DOMAttr&, const externalkey_type&);

void
operator<< (::xml_schema::list_stream&,
            const externalkey_type&);

void
operator<< (::xercesc::DOMElement&, const decimal_type&);

void
operator<< (::xercesc::DOMAttr&, const decimal_type&);

void
operator<< (::xml_schema::list_stream&,
            const decimal_type&);

void
operator<< (::xercesc::DOMElement&, const decimal8_type&);

void
operator<< (::xercesc::DOMAttr&, const decimal8_type&);

void
operator<< (::xml_schema::list_stream&,
            const decimal8_type&);

void
operator<< (::xercesc::DOMElement&, const percent_type&);

void
operator<< (::xercesc::DOMAttr&, const percent_type&);

void
operator<< (::xml_schema::list_stream&,
            const percent_type&);

void
operator<< (::xercesc::DOMElement&, const documentviewertype_type&);

void
operator<< (::xercesc::DOMAttr&, const documentviewertype_type&);

void
operator<< (::xml_schema::list_stream&,
            const documentviewertype_type&);

void
operator<< (::xercesc::DOMElement&, const matchfieldrange_type&);

void
operator<< (::xercesc::DOMAttr&, const matchfieldrange_type&);

void
operator<< (::xml_schema::list_stream&,
            const matchfieldrange_type&);

void
operator<< (::xercesc::DOMElement&, const matchfielduser_type&);

void
operator<< (::xercesc::DOMAttr&, const matchfielduser_type&);

void
operator<< (::xml_schema::list_stream&,
            const matchfielduser_type&);

void
operator<< (::xercesc::DOMElement&, const matchfieldresponse_type&);

void
operator<< (::xercesc::DOMAttr&, const matchfieldresponse_type&);

void
operator<< (::xml_schema::list_stream&,
            const matchfieldresponse_type&);

void
operator<< (::xercesc::DOMElement&, const matchfieldcity_type&);

void
operator<< (::xercesc::DOMAttr&, const matchfieldcity_type&);

void
operator<< (::xml_schema::list_stream&,
            const matchfieldcity_type&);

void
operator<< (::xercesc::DOMElement&, const matchfielddocument_type&);

void
operator<< (::xercesc::DOMAttr&, const matchfielddocument_type&);

void
operator<< (::xml_schema::list_stream&,
            const matchfielddocument_type&);

void
operator<< (::xercesc::DOMElement&, const matchfieldkeyvalue_type&);

void
operator<< (::xercesc::DOMAttr&, const matchfieldkeyvalue_type&);

void
operator<< (::xml_schema::list_stream&,
            const matchfieldkeyvalue_type&);

void
operator<< (::xercesc::DOMElement&, const matchfieldparish_type&);

void
operator<< (::xercesc::DOMAttr&, const matchfieldparish_type&);

void
operator<< (::xml_schema::list_stream&,
            const matchfieldparish_type&);

void
operator<< (::xercesc::DOMElement&, const matchfieldcontact_type&);

void
operator<< (::xercesc::DOMAttr&, const matchfieldcontact_type&);

void
operator<< (::xml_schema::list_stream&,
            const matchfieldcontact_type&);

void
operator<< (::xercesc::DOMElement&, const matchfieldcounterpart_type&);

void
operator<< (::xercesc::DOMAttr&, const matchfieldcounterpart_type&);

void
operator<< (::xml_schema::list_stream&,
            const matchfieldcounterpart_type&);

void
operator<< (::xercesc::DOMElement&, const matchfieldproject_type&);

void
operator<< (::xercesc::DOMAttr&, const matchfieldproject_type&);

void
operator<< (::xml_schema::list_stream&,
            const matchfieldproject_type&);

void
operator<< (::xercesc::DOMElement&, const matchfieldpart_type&);

void
operator<< (::xercesc::DOMAttr&, const matchfieldpart_type&);

void
operator<< (::xml_schema::list_stream&,
            const matchfieldpart_type&);

void
operator<< (::xercesc::DOMElement&, const matchfieldplacing_type&);

void
operator<< (::xercesc::DOMAttr&, const matchfieldplacing_type&);

void
operator<< (::xml_schema::list_stream&,
            const matchfieldplacing_type&);

void
operator<< (::xercesc::DOMElement&, const matchfieldrevision_type&);

void
operator<< (::xercesc::DOMAttr&, const matchfieldrevision_type&);

void
operator<< (::xml_schema::list_stream&,
            const matchfieldrevision_type&);

void
operator<< (::xercesc::DOMElement&, const matchfieldorder_type&);

void
operator<< (::xercesc::DOMAttr&, const matchfieldorder_type&);

void
operator<< (::xml_schema::list_stream&,
            const matchfieldorder_type&);

void
operator<< (::xercesc::DOMElement&, const matchfieldaddition_type&);

void
operator<< (::xercesc::DOMAttr&, const matchfieldaddition_type&);

void
operator<< (::xml_schema::list_stream&,
            const matchfieldaddition_type&);

void
operator<< (::xercesc::DOMElement&, const matchfieldevident_type&);

void
operator<< (::xercesc::DOMAttr&, const matchfieldevident_type&);

void
operator<< (::xml_schema::list_stream&,
            const matchfieldevident_type&);

void
operator<< (::xercesc::DOMElement&, const matchfieldbackup_type&);

void
operator<< (::xercesc::DOMAttr&, const matchfieldbackup_type&);

void
operator<< (::xml_schema::list_stream&,
            const matchfieldbackup_type&);

void
operator<< (::xercesc::DOMElement&, const matchfieldavaorder_type&);

void
operator<< (::xercesc::DOMAttr&, const matchfieldavaorder_type&);

void
operator<< (::xml_schema::list_stream&,
            const matchfieldavaorder_type&);

void
operator<< (::xercesc::DOMElement&, const matchfieldavaunit_type&);

void
operator<< (::xercesc::DOMAttr&, const matchfieldavaunit_type&);

void
operator<< (::xml_schema::list_stream&,
            const matchfieldavaunit_type&);

void
operator<< (::xercesc::DOMElement&, const matchfieldinvoice_type&);

void
operator<< (::xercesc::DOMAttr&, const matchfieldinvoice_type&);

void
operator<< (::xml_schema::list_stream&,
            const matchfieldinvoice_type&);

void
operator<< (::xercesc::DOMElement&, const matchfieldpayment_type&);

void
operator<< (::xercesc::DOMAttr&, const matchfieldpayment_type&);

void
operator<< (::xml_schema::list_stream&,
            const matchfieldpayment_type&);

void
operator<< (::xercesc::DOMElement&, const matchfieldbank_type&);

void
operator<< (::xercesc::DOMAttr&, const matchfieldbank_type&);

void
operator<< (::xml_schema::list_stream&,
            const matchfieldbank_type&);

// Serialize to std::ostream.
//

void
coordata_ (::std::ostream& os,
           const ::coordata& x, 
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           const ::std::wstring& e = L"UTF-8",
           ::xml_schema::flags f = 0);

void
coordata_ (::std::ostream& os,
           const ::coordata& x, 
           ::xml_schema::error_handler& eh,
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           const ::std::wstring& e = L"UTF-8",
           ::xml_schema::flags f = 0);

void
coordata_ (::std::ostream& os,
           const ::coordata& x, 
           ::xercesc::DOMErrorHandler& eh,
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           const ::std::wstring& e = L"UTF-8",
           ::xml_schema::flags f = 0);

// Serialize to xercesc::XMLFormatTarget.
//

void
coordata_ (::xercesc::XMLFormatTarget& ft,
           const ::coordata& x, 
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           const ::std::wstring& e = L"UTF-8",
           ::xml_schema::flags f = 0);

void
coordata_ (::xercesc::XMLFormatTarget& ft,
           const ::coordata& x, 
           ::xml_schema::error_handler& eh,
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           const ::std::wstring& e = L"UTF-8",
           ::xml_schema::flags f = 0);

void
coordata_ (::xercesc::XMLFormatTarget& ft,
           const ::coordata& x, 
           ::xercesc::DOMErrorHandler& eh,
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           const ::std::wstring& e = L"UTF-8",
           ::xml_schema::flags f = 0);

// Serialize to an existing xercesc::DOMDocument.
//

void
coordata_ (::xercesc::DOMDocument& d,
           const ::coordata& x,
           ::xml_schema::flags f = 0);

// Serialize to a new xercesc::DOMDocument.
//

::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
coordata_ (const ::coordata& x, 
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           ::xml_schema::flags f = 0);

// Serialize to std::ostream.
//

void
bkm_response_ (::std::ostream& os,
               const ::bkm_response& x, 
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::wstring& e = L"UTF-8",
               ::xml_schema::flags f = 0);

void
bkm_response_ (::std::ostream& os,
               const ::bkm_response& x, 
               ::xml_schema::error_handler& eh,
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::wstring& e = L"UTF-8",
               ::xml_schema::flags f = 0);

void
bkm_response_ (::std::ostream& os,
               const ::bkm_response& x, 
               ::xercesc::DOMErrorHandler& eh,
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::wstring& e = L"UTF-8",
               ::xml_schema::flags f = 0);

// Serialize to xercesc::XMLFormatTarget.
//

void
bkm_response_ (::xercesc::XMLFormatTarget& ft,
               const ::bkm_response& x, 
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::wstring& e = L"UTF-8",
               ::xml_schema::flags f = 0);

void
bkm_response_ (::xercesc::XMLFormatTarget& ft,
               const ::bkm_response& x, 
               ::xml_schema::error_handler& eh,
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::wstring& e = L"UTF-8",
               ::xml_schema::flags f = 0);

void
bkm_response_ (::xercesc::XMLFormatTarget& ft,
               const ::bkm_response& x, 
               ::xercesc::DOMErrorHandler& eh,
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::wstring& e = L"UTF-8",
               ::xml_schema::flags f = 0);

// Serialize to an existing xercesc::DOMDocument.
//

void
bkm_response_ (::xercesc::DOMDocument& d,
               const ::bkm_response& x,
               ::xml_schema::flags f = 0);

// Serialize to a new xercesc::DOMDocument.
//

::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
bkm_response_ (const ::bkm_response& x, 
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               ::xml_schema::flags f = 0);

// Serialize to std::ostream.
//

void
bkm_user_ (::std::ostream& os,
           const ::bkm_user& x, 
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           const ::std::wstring& e = L"UTF-8",
           ::xml_schema::flags f = 0);

void
bkm_user_ (::std::ostream& os,
           const ::bkm_user& x, 
           ::xml_schema::error_handler& eh,
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           const ::std::wstring& e = L"UTF-8",
           ::xml_schema::flags f = 0);

void
bkm_user_ (::std::ostream& os,
           const ::bkm_user& x, 
           ::xercesc::DOMErrorHandler& eh,
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           const ::std::wstring& e = L"UTF-8",
           ::xml_schema::flags f = 0);

// Serialize to xercesc::XMLFormatTarget.
//

void
bkm_user_ (::xercesc::XMLFormatTarget& ft,
           const ::bkm_user& x, 
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           const ::std::wstring& e = L"UTF-8",
           ::xml_schema::flags f = 0);

void
bkm_user_ (::xercesc::XMLFormatTarget& ft,
           const ::bkm_user& x, 
           ::xml_schema::error_handler& eh,
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           const ::std::wstring& e = L"UTF-8",
           ::xml_schema::flags f = 0);

void
bkm_user_ (::xercesc::XMLFormatTarget& ft,
           const ::bkm_user& x, 
           ::xercesc::DOMErrorHandler& eh,
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           const ::std::wstring& e = L"UTF-8",
           ::xml_schema::flags f = 0);

// Serialize to an existing xercesc::DOMDocument.
//

void
bkm_user_ (::xercesc::DOMDocument& d,
           const ::bkm_user& x,
           ::xml_schema::flags f = 0);

// Serialize to a new xercesc::DOMDocument.
//

::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
bkm_user_ (const ::bkm_user& x, 
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           ::xml_schema::flags f = 0);

// Serialize to std::ostream.
//

void
bkm_range_ (::std::ostream& os,
            const ::bkm_range& x, 
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::wstring& e = L"UTF-8",
            ::xml_schema::flags f = 0);

void
bkm_range_ (::std::ostream& os,
            const ::bkm_range& x, 
            ::xml_schema::error_handler& eh,
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::wstring& e = L"UTF-8",
            ::xml_schema::flags f = 0);

void
bkm_range_ (::std::ostream& os,
            const ::bkm_range& x, 
            ::xercesc::DOMErrorHandler& eh,
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::wstring& e = L"UTF-8",
            ::xml_schema::flags f = 0);

// Serialize to xercesc::XMLFormatTarget.
//

void
bkm_range_ (::xercesc::XMLFormatTarget& ft,
            const ::bkm_range& x, 
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::wstring& e = L"UTF-8",
            ::xml_schema::flags f = 0);

void
bkm_range_ (::xercesc::XMLFormatTarget& ft,
            const ::bkm_range& x, 
            ::xml_schema::error_handler& eh,
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::wstring& e = L"UTF-8",
            ::xml_schema::flags f = 0);

void
bkm_range_ (::xercesc::XMLFormatTarget& ft,
            const ::bkm_range& x, 
            ::xercesc::DOMErrorHandler& eh,
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::wstring& e = L"UTF-8",
            ::xml_schema::flags f = 0);

// Serialize to an existing xercesc::DOMDocument.
//

void
bkm_range_ (::xercesc::DOMDocument& d,
            const ::bkm_range& x,
            ::xml_schema::flags f = 0);

// Serialize to a new xercesc::DOMDocument.
//

::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
bkm_range_ (const ::bkm_range& x, 
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            ::xml_schema::flags f = 0);

// Serialize to std::ostream.
//

void
bkm_city_ (::std::ostream& os,
           const ::bkm_city& x, 
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           const ::std::wstring& e = L"UTF-8",
           ::xml_schema::flags f = 0);

void
bkm_city_ (::std::ostream& os,
           const ::bkm_city& x, 
           ::xml_schema::error_handler& eh,
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           const ::std::wstring& e = L"UTF-8",
           ::xml_schema::flags f = 0);

void
bkm_city_ (::std::ostream& os,
           const ::bkm_city& x, 
           ::xercesc::DOMErrorHandler& eh,
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           const ::std::wstring& e = L"UTF-8",
           ::xml_schema::flags f = 0);

// Serialize to xercesc::XMLFormatTarget.
//

void
bkm_city_ (::xercesc::XMLFormatTarget& ft,
           const ::bkm_city& x, 
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           const ::std::wstring& e = L"UTF-8",
           ::xml_schema::flags f = 0);

void
bkm_city_ (::xercesc::XMLFormatTarget& ft,
           const ::bkm_city& x, 
           ::xml_schema::error_handler& eh,
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           const ::std::wstring& e = L"UTF-8",
           ::xml_schema::flags f = 0);

void
bkm_city_ (::xercesc::XMLFormatTarget& ft,
           const ::bkm_city& x, 
           ::xercesc::DOMErrorHandler& eh,
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           const ::std::wstring& e = L"UTF-8",
           ::xml_schema::flags f = 0);

// Serialize to an existing xercesc::DOMDocument.
//

void
bkm_city_ (::xercesc::DOMDocument& d,
           const ::bkm_city& x,
           ::xml_schema::flags f = 0);

// Serialize to a new xercesc::DOMDocument.
//

::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
bkm_city_ (const ::bkm_city& x, 
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           ::xml_schema::flags f = 0);

// Serialize to std::ostream.
//

void
bkm_bank_ (::std::ostream& os,
           const ::bkm_bank& x, 
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           const ::std::wstring& e = L"UTF-8",
           ::xml_schema::flags f = 0);

void
bkm_bank_ (::std::ostream& os,
           const ::bkm_bank& x, 
           ::xml_schema::error_handler& eh,
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           const ::std::wstring& e = L"UTF-8",
           ::xml_schema::flags f = 0);

void
bkm_bank_ (::std::ostream& os,
           const ::bkm_bank& x, 
           ::xercesc::DOMErrorHandler& eh,
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           const ::std::wstring& e = L"UTF-8",
           ::xml_schema::flags f = 0);

// Serialize to xercesc::XMLFormatTarget.
//

void
bkm_bank_ (::xercesc::XMLFormatTarget& ft,
           const ::bkm_bank& x, 
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           const ::std::wstring& e = L"UTF-8",
           ::xml_schema::flags f = 0);

void
bkm_bank_ (::xercesc::XMLFormatTarget& ft,
           const ::bkm_bank& x, 
           ::xml_schema::error_handler& eh,
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           const ::std::wstring& e = L"UTF-8",
           ::xml_schema::flags f = 0);

void
bkm_bank_ (::xercesc::XMLFormatTarget& ft,
           const ::bkm_bank& x, 
           ::xercesc::DOMErrorHandler& eh,
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           const ::std::wstring& e = L"UTF-8",
           ::xml_schema::flags f = 0);

// Serialize to an existing xercesc::DOMDocument.
//

void
bkm_bank_ (::xercesc::DOMDocument& d,
           const ::bkm_bank& x,
           ::xml_schema::flags f = 0);

// Serialize to a new xercesc::DOMDocument.
//

::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
bkm_bank_ (const ::bkm_bank& x, 
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           ::xml_schema::flags f = 0);

// Serialize to std::ostream.
//

void
bkm_parish_ (::std::ostream& os,
             const ::bkm_parish& x, 
             const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
             const ::std::wstring& e = L"UTF-8",
             ::xml_schema::flags f = 0);

void
bkm_parish_ (::std::ostream& os,
             const ::bkm_parish& x, 
             ::xml_schema::error_handler& eh,
             const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
             const ::std::wstring& e = L"UTF-8",
             ::xml_schema::flags f = 0);

void
bkm_parish_ (::std::ostream& os,
             const ::bkm_parish& x, 
             ::xercesc::DOMErrorHandler& eh,
             const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
             const ::std::wstring& e = L"UTF-8",
             ::xml_schema::flags f = 0);

// Serialize to xercesc::XMLFormatTarget.
//

void
bkm_parish_ (::xercesc::XMLFormatTarget& ft,
             const ::bkm_parish& x, 
             const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
             const ::std::wstring& e = L"UTF-8",
             ::xml_schema::flags f = 0);

void
bkm_parish_ (::xercesc::XMLFormatTarget& ft,
             const ::bkm_parish& x, 
             ::xml_schema::error_handler& eh,
             const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
             const ::std::wstring& e = L"UTF-8",
             ::xml_schema::flags f = 0);

void
bkm_parish_ (::xercesc::XMLFormatTarget& ft,
             const ::bkm_parish& x, 
             ::xercesc::DOMErrorHandler& eh,
             const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
             const ::std::wstring& e = L"UTF-8",
             ::xml_schema::flags f = 0);

// Serialize to an existing xercesc::DOMDocument.
//

void
bkm_parish_ (::xercesc::DOMDocument& d,
             const ::bkm_parish& x,
             ::xml_schema::flags f = 0);

// Serialize to a new xercesc::DOMDocument.
//

::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
bkm_parish_ (const ::bkm_parish& x, 
             const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
             ::xml_schema::flags f = 0);

// Serialize to std::ostream.
//

void
bkm_contact_ (::std::ostream& os,
              const ::bkm_contact& x, 
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::wstring& e = L"UTF-8",
              ::xml_schema::flags f = 0);

void
bkm_contact_ (::std::ostream& os,
              const ::bkm_contact& x, 
              ::xml_schema::error_handler& eh,
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::wstring& e = L"UTF-8",
              ::xml_schema::flags f = 0);

void
bkm_contact_ (::std::ostream& os,
              const ::bkm_contact& x, 
              ::xercesc::DOMErrorHandler& eh,
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::wstring& e = L"UTF-8",
              ::xml_schema::flags f = 0);

// Serialize to xercesc::XMLFormatTarget.
//

void
bkm_contact_ (::xercesc::XMLFormatTarget& ft,
              const ::bkm_contact& x, 
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::wstring& e = L"UTF-8",
              ::xml_schema::flags f = 0);

void
bkm_contact_ (::xercesc::XMLFormatTarget& ft,
              const ::bkm_contact& x, 
              ::xml_schema::error_handler& eh,
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::wstring& e = L"UTF-8",
              ::xml_schema::flags f = 0);

void
bkm_contact_ (::xercesc::XMLFormatTarget& ft,
              const ::bkm_contact& x, 
              ::xercesc::DOMErrorHandler& eh,
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::wstring& e = L"UTF-8",
              ::xml_schema::flags f = 0);

// Serialize to an existing xercesc::DOMDocument.
//

void
bkm_contact_ (::xercesc::DOMDocument& d,
              const ::bkm_contact& x,
              ::xml_schema::flags f = 0);

// Serialize to a new xercesc::DOMDocument.
//

::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
bkm_contact_ (const ::bkm_contact& x, 
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              ::xml_schema::flags f = 0);

// Serialize to std::ostream.
//

void
bkm_counterpart_ (::std::ostream& os,
                  const ::bkm_counterpart& x, 
                  const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                  const ::std::wstring& e = L"UTF-8",
                  ::xml_schema::flags f = 0);

void
bkm_counterpart_ (::std::ostream& os,
                  const ::bkm_counterpart& x, 
                  ::xml_schema::error_handler& eh,
                  const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                  const ::std::wstring& e = L"UTF-8",
                  ::xml_schema::flags f = 0);

void
bkm_counterpart_ (::std::ostream& os,
                  const ::bkm_counterpart& x, 
                  ::xercesc::DOMErrorHandler& eh,
                  const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                  const ::std::wstring& e = L"UTF-8",
                  ::xml_schema::flags f = 0);

// Serialize to xercesc::XMLFormatTarget.
//

void
bkm_counterpart_ (::xercesc::XMLFormatTarget& ft,
                  const ::bkm_counterpart& x, 
                  const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                  const ::std::wstring& e = L"UTF-8",
                  ::xml_schema::flags f = 0);

void
bkm_counterpart_ (::xercesc::XMLFormatTarget& ft,
                  const ::bkm_counterpart& x, 
                  ::xml_schema::error_handler& eh,
                  const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                  const ::std::wstring& e = L"UTF-8",
                  ::xml_schema::flags f = 0);

void
bkm_counterpart_ (::xercesc::XMLFormatTarget& ft,
                  const ::bkm_counterpart& x, 
                  ::xercesc::DOMErrorHandler& eh,
                  const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                  const ::std::wstring& e = L"UTF-8",
                  ::xml_schema::flags f = 0);

// Serialize to an existing xercesc::DOMDocument.
//

void
bkm_counterpart_ (::xercesc::DOMDocument& d,
                  const ::bkm_counterpart& x,
                  ::xml_schema::flags f = 0);

// Serialize to a new xercesc::DOMDocument.
//

::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
bkm_counterpart_ (const ::bkm_counterpart& x, 
                  const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                  ::xml_schema::flags f = 0);

// Serialize to std::ostream.
//

void
bkm_project_ (::std::ostream& os,
              const ::bkm_project& x, 
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::wstring& e = L"UTF-8",
              ::xml_schema::flags f = 0);

void
bkm_project_ (::std::ostream& os,
              const ::bkm_project& x, 
              ::xml_schema::error_handler& eh,
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::wstring& e = L"UTF-8",
              ::xml_schema::flags f = 0);

void
bkm_project_ (::std::ostream& os,
              const ::bkm_project& x, 
              ::xercesc::DOMErrorHandler& eh,
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::wstring& e = L"UTF-8",
              ::xml_schema::flags f = 0);

// Serialize to xercesc::XMLFormatTarget.
//

void
bkm_project_ (::xercesc::XMLFormatTarget& ft,
              const ::bkm_project& x, 
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::wstring& e = L"UTF-8",
              ::xml_schema::flags f = 0);

void
bkm_project_ (::xercesc::XMLFormatTarget& ft,
              const ::bkm_project& x, 
              ::xml_schema::error_handler& eh,
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::wstring& e = L"UTF-8",
              ::xml_schema::flags f = 0);

void
bkm_project_ (::xercesc::XMLFormatTarget& ft,
              const ::bkm_project& x, 
              ::xercesc::DOMErrorHandler& eh,
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::wstring& e = L"UTF-8",
              ::xml_schema::flags f = 0);

// Serialize to an existing xercesc::DOMDocument.
//

void
bkm_project_ (::xercesc::DOMDocument& d,
              const ::bkm_project& x,
              ::xml_schema::flags f = 0);

// Serialize to a new xercesc::DOMDocument.
//

::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
bkm_project_ (const ::bkm_project& x, 
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              ::xml_schema::flags f = 0);

// Serialize to std::ostream.
//

void
bkm_part_ (::std::ostream& os,
           const ::bkm_part& x, 
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           const ::std::wstring& e = L"UTF-8",
           ::xml_schema::flags f = 0);

void
bkm_part_ (::std::ostream& os,
           const ::bkm_part& x, 
           ::xml_schema::error_handler& eh,
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           const ::std::wstring& e = L"UTF-8",
           ::xml_schema::flags f = 0);

void
bkm_part_ (::std::ostream& os,
           const ::bkm_part& x, 
           ::xercesc::DOMErrorHandler& eh,
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           const ::std::wstring& e = L"UTF-8",
           ::xml_schema::flags f = 0);

// Serialize to xercesc::XMLFormatTarget.
//

void
bkm_part_ (::xercesc::XMLFormatTarget& ft,
           const ::bkm_part& x, 
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           const ::std::wstring& e = L"UTF-8",
           ::xml_schema::flags f = 0);

void
bkm_part_ (::xercesc::XMLFormatTarget& ft,
           const ::bkm_part& x, 
           ::xml_schema::error_handler& eh,
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           const ::std::wstring& e = L"UTF-8",
           ::xml_schema::flags f = 0);

void
bkm_part_ (::xercesc::XMLFormatTarget& ft,
           const ::bkm_part& x, 
           ::xercesc::DOMErrorHandler& eh,
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           const ::std::wstring& e = L"UTF-8",
           ::xml_schema::flags f = 0);

// Serialize to an existing xercesc::DOMDocument.
//

void
bkm_part_ (::xercesc::DOMDocument& d,
           const ::bkm_part& x,
           ::xml_schema::flags f = 0);

// Serialize to a new xercesc::DOMDocument.
//

::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
bkm_part_ (const ::bkm_part& x, 
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           ::xml_schema::flags f = 0);

// Serialize to std::ostream.
//

void
bkm_splititem_ (::std::ostream& os,
                const ::bkm_splititem& x, 
                const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                const ::std::wstring& e = L"UTF-8",
                ::xml_schema::flags f = 0);

void
bkm_splititem_ (::std::ostream& os,
                const ::bkm_splititem& x, 
                ::xml_schema::error_handler& eh,
                const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                const ::std::wstring& e = L"UTF-8",
                ::xml_schema::flags f = 0);

void
bkm_splititem_ (::std::ostream& os,
                const ::bkm_splititem& x, 
                ::xercesc::DOMErrorHandler& eh,
                const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                const ::std::wstring& e = L"UTF-8",
                ::xml_schema::flags f = 0);

// Serialize to xercesc::XMLFormatTarget.
//

void
bkm_splititem_ (::xercesc::XMLFormatTarget& ft,
                const ::bkm_splititem& x, 
                const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                const ::std::wstring& e = L"UTF-8",
                ::xml_schema::flags f = 0);

void
bkm_splititem_ (::xercesc::XMLFormatTarget& ft,
                const ::bkm_splititem& x, 
                ::xml_schema::error_handler& eh,
                const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                const ::std::wstring& e = L"UTF-8",
                ::xml_schema::flags f = 0);

void
bkm_splititem_ (::xercesc::XMLFormatTarget& ft,
                const ::bkm_splititem& x, 
                ::xercesc::DOMErrorHandler& eh,
                const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                const ::std::wstring& e = L"UTF-8",
                ::xml_schema::flags f = 0);

// Serialize to an existing xercesc::DOMDocument.
//

void
bkm_splititem_ (::xercesc::DOMDocument& d,
                const ::bkm_splititem& x,
                ::xml_schema::flags f = 0);

// Serialize to a new xercesc::DOMDocument.
//

::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
bkm_splititem_ (const ::bkm_splititem& x, 
                const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                ::xml_schema::flags f = 0);

// Serialize to std::ostream.
//

void
bkm_placing_ (::std::ostream& os,
              const ::bkm_placing& x, 
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::wstring& e = L"UTF-8",
              ::xml_schema::flags f = 0);

void
bkm_placing_ (::std::ostream& os,
              const ::bkm_placing& x, 
              ::xml_schema::error_handler& eh,
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::wstring& e = L"UTF-8",
              ::xml_schema::flags f = 0);

void
bkm_placing_ (::std::ostream& os,
              const ::bkm_placing& x, 
              ::xercesc::DOMErrorHandler& eh,
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::wstring& e = L"UTF-8",
              ::xml_schema::flags f = 0);

// Serialize to xercesc::XMLFormatTarget.
//

void
bkm_placing_ (::xercesc::XMLFormatTarget& ft,
              const ::bkm_placing& x, 
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::wstring& e = L"UTF-8",
              ::xml_schema::flags f = 0);

void
bkm_placing_ (::xercesc::XMLFormatTarget& ft,
              const ::bkm_placing& x, 
              ::xml_schema::error_handler& eh,
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::wstring& e = L"UTF-8",
              ::xml_schema::flags f = 0);

void
bkm_placing_ (::xercesc::XMLFormatTarget& ft,
              const ::bkm_placing& x, 
              ::xercesc::DOMErrorHandler& eh,
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::wstring& e = L"UTF-8",
              ::xml_schema::flags f = 0);

// Serialize to an existing xercesc::DOMDocument.
//

void
bkm_placing_ (::xercesc::DOMDocument& d,
              const ::bkm_placing& x,
              ::xml_schema::flags f = 0);

// Serialize to a new xercesc::DOMDocument.
//

::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
bkm_placing_ (const ::bkm_placing& x, 
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              ::xml_schema::flags f = 0);

// Serialize to std::ostream.
//

void
bkm_revision_ (::std::ostream& os,
               const ::bkm_revision& x, 
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::wstring& e = L"UTF-8",
               ::xml_schema::flags f = 0);

void
bkm_revision_ (::std::ostream& os,
               const ::bkm_revision& x, 
               ::xml_schema::error_handler& eh,
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::wstring& e = L"UTF-8",
               ::xml_schema::flags f = 0);

void
bkm_revision_ (::std::ostream& os,
               const ::bkm_revision& x, 
               ::xercesc::DOMErrorHandler& eh,
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::wstring& e = L"UTF-8",
               ::xml_schema::flags f = 0);

// Serialize to xercesc::XMLFormatTarget.
//

void
bkm_revision_ (::xercesc::XMLFormatTarget& ft,
               const ::bkm_revision& x, 
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::wstring& e = L"UTF-8",
               ::xml_schema::flags f = 0);

void
bkm_revision_ (::xercesc::XMLFormatTarget& ft,
               const ::bkm_revision& x, 
               ::xml_schema::error_handler& eh,
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::wstring& e = L"UTF-8",
               ::xml_schema::flags f = 0);

void
bkm_revision_ (::xercesc::XMLFormatTarget& ft,
               const ::bkm_revision& x, 
               ::xercesc::DOMErrorHandler& eh,
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::wstring& e = L"UTF-8",
               ::xml_schema::flags f = 0);

// Serialize to an existing xercesc::DOMDocument.
//

void
bkm_revision_ (::xercesc::DOMDocument& d,
               const ::bkm_revision& x,
               ::xml_schema::flags f = 0);

// Serialize to a new xercesc::DOMDocument.
//

::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
bkm_revision_ (const ::bkm_revision& x, 
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               ::xml_schema::flags f = 0);

// Serialize to std::ostream.
//

void
bkm_revisionitem_ (::std::ostream& os,
                   const ::bkm_revisionitem& x, 
                   const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                   const ::std::wstring& e = L"UTF-8",
                   ::xml_schema::flags f = 0);

void
bkm_revisionitem_ (::std::ostream& os,
                   const ::bkm_revisionitem& x, 
                   ::xml_schema::error_handler& eh,
                   const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                   const ::std::wstring& e = L"UTF-8",
                   ::xml_schema::flags f = 0);

void
bkm_revisionitem_ (::std::ostream& os,
                   const ::bkm_revisionitem& x, 
                   ::xercesc::DOMErrorHandler& eh,
                   const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                   const ::std::wstring& e = L"UTF-8",
                   ::xml_schema::flags f = 0);

// Serialize to xercesc::XMLFormatTarget.
//

void
bkm_revisionitem_ (::xercesc::XMLFormatTarget& ft,
                   const ::bkm_revisionitem& x, 
                   const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                   const ::std::wstring& e = L"UTF-8",
                   ::xml_schema::flags f = 0);

void
bkm_revisionitem_ (::xercesc::XMLFormatTarget& ft,
                   const ::bkm_revisionitem& x, 
                   ::xml_schema::error_handler& eh,
                   const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                   const ::std::wstring& e = L"UTF-8",
                   ::xml_schema::flags f = 0);

void
bkm_revisionitem_ (::xercesc::XMLFormatTarget& ft,
                   const ::bkm_revisionitem& x, 
                   ::xercesc::DOMErrorHandler& eh,
                   const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                   const ::std::wstring& e = L"UTF-8",
                   ::xml_schema::flags f = 0);

// Serialize to an existing xercesc::DOMDocument.
//

void
bkm_revisionitem_ (::xercesc::DOMDocument& d,
                   const ::bkm_revisionitem& x,
                   ::xml_schema::flags f = 0);

// Serialize to a new xercesc::DOMDocument.
//

::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
bkm_revisionitem_ (const ::bkm_revisionitem& x, 
                   const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                   ::xml_schema::flags f = 0);

// Serialize to std::ostream.
//

void
ret_revisionitem_ (::std::ostream& os,
                   const ::ret_revisionitem& x, 
                   const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                   const ::std::wstring& e = L"UTF-8",
                   ::xml_schema::flags f = 0);

void
ret_revisionitem_ (::std::ostream& os,
                   const ::ret_revisionitem& x, 
                   ::xml_schema::error_handler& eh,
                   const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                   const ::std::wstring& e = L"UTF-8",
                   ::xml_schema::flags f = 0);

void
ret_revisionitem_ (::std::ostream& os,
                   const ::ret_revisionitem& x, 
                   ::xercesc::DOMErrorHandler& eh,
                   const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                   const ::std::wstring& e = L"UTF-8",
                   ::xml_schema::flags f = 0);

// Serialize to xercesc::XMLFormatTarget.
//

void
ret_revisionitem_ (::xercesc::XMLFormatTarget& ft,
                   const ::ret_revisionitem& x, 
                   const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                   const ::std::wstring& e = L"UTF-8",
                   ::xml_schema::flags f = 0);

void
ret_revisionitem_ (::xercesc::XMLFormatTarget& ft,
                   const ::ret_revisionitem& x, 
                   ::xml_schema::error_handler& eh,
                   const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                   const ::std::wstring& e = L"UTF-8",
                   ::xml_schema::flags f = 0);

void
ret_revisionitem_ (::xercesc::XMLFormatTarget& ft,
                   const ::ret_revisionitem& x, 
                   ::xercesc::DOMErrorHandler& eh,
                   const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                   const ::std::wstring& e = L"UTF-8",
                   ::xml_schema::flags f = 0);

// Serialize to an existing xercesc::DOMDocument.
//

void
ret_revisionitem_ (::xercesc::DOMDocument& d,
                   const ::ret_revisionitem& x,
                   ::xml_schema::flags f = 0);

// Serialize to a new xercesc::DOMDocument.
//

::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
ret_revisionitem_ (const ::ret_revisionitem& x, 
                   const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                   ::xml_schema::flags f = 0);

// Serialize to std::ostream.
//

void
bkm_order_ (::std::ostream& os,
            const ::bkm_order& x, 
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::wstring& e = L"UTF-8",
            ::xml_schema::flags f = 0);

void
bkm_order_ (::std::ostream& os,
            const ::bkm_order& x, 
            ::xml_schema::error_handler& eh,
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::wstring& e = L"UTF-8",
            ::xml_schema::flags f = 0);

void
bkm_order_ (::std::ostream& os,
            const ::bkm_order& x, 
            ::xercesc::DOMErrorHandler& eh,
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::wstring& e = L"UTF-8",
            ::xml_schema::flags f = 0);

// Serialize to xercesc::XMLFormatTarget.
//

void
bkm_order_ (::xercesc::XMLFormatTarget& ft,
            const ::bkm_order& x, 
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::wstring& e = L"UTF-8",
            ::xml_schema::flags f = 0);

void
bkm_order_ (::xercesc::XMLFormatTarget& ft,
            const ::bkm_order& x, 
            ::xml_schema::error_handler& eh,
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::wstring& e = L"UTF-8",
            ::xml_schema::flags f = 0);

void
bkm_order_ (::xercesc::XMLFormatTarget& ft,
            const ::bkm_order& x, 
            ::xercesc::DOMErrorHandler& eh,
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::wstring& e = L"UTF-8",
            ::xml_schema::flags f = 0);

// Serialize to an existing xercesc::DOMDocument.
//

void
bkm_order_ (::xercesc::DOMDocument& d,
            const ::bkm_order& x,
            ::xml_schema::flags f = 0);

// Serialize to a new xercesc::DOMDocument.
//

::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
bkm_order_ (const ::bkm_order& x, 
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            ::xml_schema::flags f = 0);

// Serialize to std::ostream.
//

void
bkm_addition_ (::std::ostream& os,
               const ::bkm_addition& x, 
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::wstring& e = L"UTF-8",
               ::xml_schema::flags f = 0);

void
bkm_addition_ (::std::ostream& os,
               const ::bkm_addition& x, 
               ::xml_schema::error_handler& eh,
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::wstring& e = L"UTF-8",
               ::xml_schema::flags f = 0);

void
bkm_addition_ (::std::ostream& os,
               const ::bkm_addition& x, 
               ::xercesc::DOMErrorHandler& eh,
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::wstring& e = L"UTF-8",
               ::xml_schema::flags f = 0);

// Serialize to xercesc::XMLFormatTarget.
//

void
bkm_addition_ (::xercesc::XMLFormatTarget& ft,
               const ::bkm_addition& x, 
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::wstring& e = L"UTF-8",
               ::xml_schema::flags f = 0);

void
bkm_addition_ (::xercesc::XMLFormatTarget& ft,
               const ::bkm_addition& x, 
               ::xml_schema::error_handler& eh,
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::wstring& e = L"UTF-8",
               ::xml_schema::flags f = 0);

void
bkm_addition_ (::xercesc::XMLFormatTarget& ft,
               const ::bkm_addition& x, 
               ::xercesc::DOMErrorHandler& eh,
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::wstring& e = L"UTF-8",
               ::xml_schema::flags f = 0);

// Serialize to an existing xercesc::DOMDocument.
//

void
bkm_addition_ (::xercesc::DOMDocument& d,
               const ::bkm_addition& x,
               ::xml_schema::flags f = 0);

// Serialize to a new xercesc::DOMDocument.
//

::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
bkm_addition_ (const ::bkm_addition& x, 
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               ::xml_schema::flags f = 0);

// Serialize to std::ostream.
//

void
bkm_evident_ (::std::ostream& os,
              const ::bkm_evident& x, 
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::wstring& e = L"UTF-8",
              ::xml_schema::flags f = 0);

void
bkm_evident_ (::std::ostream& os,
              const ::bkm_evident& x, 
              ::xml_schema::error_handler& eh,
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::wstring& e = L"UTF-8",
              ::xml_schema::flags f = 0);

void
bkm_evident_ (::std::ostream& os,
              const ::bkm_evident& x, 
              ::xercesc::DOMErrorHandler& eh,
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::wstring& e = L"UTF-8",
              ::xml_schema::flags f = 0);

// Serialize to xercesc::XMLFormatTarget.
//

void
bkm_evident_ (::xercesc::XMLFormatTarget& ft,
              const ::bkm_evident& x, 
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::wstring& e = L"UTF-8",
              ::xml_schema::flags f = 0);

void
bkm_evident_ (::xercesc::XMLFormatTarget& ft,
              const ::bkm_evident& x, 
              ::xml_schema::error_handler& eh,
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::wstring& e = L"UTF-8",
              ::xml_schema::flags f = 0);

void
bkm_evident_ (::xercesc::XMLFormatTarget& ft,
              const ::bkm_evident& x, 
              ::xercesc::DOMErrorHandler& eh,
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::wstring& e = L"UTF-8",
              ::xml_schema::flags f = 0);

// Serialize to an existing xercesc::DOMDocument.
//

void
bkm_evident_ (::xercesc::DOMDocument& d,
              const ::bkm_evident& x,
              ::xml_schema::flags f = 0);

// Serialize to a new xercesc::DOMDocument.
//

::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
bkm_evident_ (const ::bkm_evident& x, 
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              ::xml_schema::flags f = 0);

// Serialize to std::ostream.
//

void
bkm_backup_ (::std::ostream& os,
             const ::bkm_backup& x, 
             const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
             const ::std::wstring& e = L"UTF-8",
             ::xml_schema::flags f = 0);

void
bkm_backup_ (::std::ostream& os,
             const ::bkm_backup& x, 
             ::xml_schema::error_handler& eh,
             const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
             const ::std::wstring& e = L"UTF-8",
             ::xml_schema::flags f = 0);

void
bkm_backup_ (::std::ostream& os,
             const ::bkm_backup& x, 
             ::xercesc::DOMErrorHandler& eh,
             const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
             const ::std::wstring& e = L"UTF-8",
             ::xml_schema::flags f = 0);

// Serialize to xercesc::XMLFormatTarget.
//

void
bkm_backup_ (::xercesc::XMLFormatTarget& ft,
             const ::bkm_backup& x, 
             const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
             const ::std::wstring& e = L"UTF-8",
             ::xml_schema::flags f = 0);

void
bkm_backup_ (::xercesc::XMLFormatTarget& ft,
             const ::bkm_backup& x, 
             ::xml_schema::error_handler& eh,
             const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
             const ::std::wstring& e = L"UTF-8",
             ::xml_schema::flags f = 0);

void
bkm_backup_ (::xercesc::XMLFormatTarget& ft,
             const ::bkm_backup& x, 
             ::xercesc::DOMErrorHandler& eh,
             const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
             const ::std::wstring& e = L"UTF-8",
             ::xml_schema::flags f = 0);

// Serialize to an existing xercesc::DOMDocument.
//

void
bkm_backup_ (::xercesc::DOMDocument& d,
             const ::bkm_backup& x,
             ::xml_schema::flags f = 0);

// Serialize to a new xercesc::DOMDocument.
//

::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
bkm_backup_ (const ::bkm_backup& x, 
             const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
             ::xml_schema::flags f = 0);

// Serialize to std::ostream.
//

void
bkm_invdeftype_ (::std::ostream& os,
                 const ::bkm_invdeftype& x, 
                 const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                 const ::std::wstring& e = L"UTF-8",
                 ::xml_schema::flags f = 0);

void
bkm_invdeftype_ (::std::ostream& os,
                 const ::bkm_invdeftype& x, 
                 ::xml_schema::error_handler& eh,
                 const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                 const ::std::wstring& e = L"UTF-8",
                 ::xml_schema::flags f = 0);

void
bkm_invdeftype_ (::std::ostream& os,
                 const ::bkm_invdeftype& x, 
                 ::xercesc::DOMErrorHandler& eh,
                 const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                 const ::std::wstring& e = L"UTF-8",
                 ::xml_schema::flags f = 0);

// Serialize to xercesc::XMLFormatTarget.
//

void
bkm_invdeftype_ (::xercesc::XMLFormatTarget& ft,
                 const ::bkm_invdeftype& x, 
                 const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                 const ::std::wstring& e = L"UTF-8",
                 ::xml_schema::flags f = 0);

void
bkm_invdeftype_ (::xercesc::XMLFormatTarget& ft,
                 const ::bkm_invdeftype& x, 
                 ::xml_schema::error_handler& eh,
                 const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                 const ::std::wstring& e = L"UTF-8",
                 ::xml_schema::flags f = 0);

void
bkm_invdeftype_ (::xercesc::XMLFormatTarget& ft,
                 const ::bkm_invdeftype& x, 
                 ::xercesc::DOMErrorHandler& eh,
                 const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                 const ::std::wstring& e = L"UTF-8",
                 ::xml_schema::flags f = 0);

// Serialize to an existing xercesc::DOMDocument.
//

void
bkm_invdeftype_ (::xercesc::DOMDocument& d,
                 const ::bkm_invdeftype& x,
                 ::xml_schema::flags f = 0);

// Serialize to a new xercesc::DOMDocument.
//

::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
bkm_invdeftype_ (const ::bkm_invdeftype& x, 
                 const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                 ::xml_schema::flags f = 0);

// Serialize to std::ostream.
//

void
bkm_invoice_ (::std::ostream& os,
              const ::bkm_invoice& x, 
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::wstring& e = L"UTF-8",
              ::xml_schema::flags f = 0);

void
bkm_invoice_ (::std::ostream& os,
              const ::bkm_invoice& x, 
              ::xml_schema::error_handler& eh,
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::wstring& e = L"UTF-8",
              ::xml_schema::flags f = 0);

void
bkm_invoice_ (::std::ostream& os,
              const ::bkm_invoice& x, 
              ::xercesc::DOMErrorHandler& eh,
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::wstring& e = L"UTF-8",
              ::xml_schema::flags f = 0);

// Serialize to xercesc::XMLFormatTarget.
//

void
bkm_invoice_ (::xercesc::XMLFormatTarget& ft,
              const ::bkm_invoice& x, 
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::wstring& e = L"UTF-8",
              ::xml_schema::flags f = 0);

void
bkm_invoice_ (::xercesc::XMLFormatTarget& ft,
              const ::bkm_invoice& x, 
              ::xml_schema::error_handler& eh,
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::wstring& e = L"UTF-8",
              ::xml_schema::flags f = 0);

void
bkm_invoice_ (::xercesc::XMLFormatTarget& ft,
              const ::bkm_invoice& x, 
              ::xercesc::DOMErrorHandler& eh,
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::wstring& e = L"UTF-8",
              ::xml_schema::flags f = 0);

// Serialize to an existing xercesc::DOMDocument.
//

void
bkm_invoice_ (::xercesc::DOMDocument& d,
              const ::bkm_invoice& x,
              ::xml_schema::flags f = 0);

// Serialize to a new xercesc::DOMDocument.
//

::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
bkm_invoice_ (const ::bkm_invoice& x, 
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              ::xml_schema::flags f = 0);

// Serialize to std::ostream.
//

void
bkm_invoicedef_ (::std::ostream& os,
                 const ::bkm_invoicedef& x, 
                 const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                 const ::std::wstring& e = L"UTF-8",
                 ::xml_schema::flags f = 0);

void
bkm_invoicedef_ (::std::ostream& os,
                 const ::bkm_invoicedef& x, 
                 ::xml_schema::error_handler& eh,
                 const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                 const ::std::wstring& e = L"UTF-8",
                 ::xml_schema::flags f = 0);

void
bkm_invoicedef_ (::std::ostream& os,
                 const ::bkm_invoicedef& x, 
                 ::xercesc::DOMErrorHandler& eh,
                 const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                 const ::std::wstring& e = L"UTF-8",
                 ::xml_schema::flags f = 0);

// Serialize to xercesc::XMLFormatTarget.
//

void
bkm_invoicedef_ (::xercesc::XMLFormatTarget& ft,
                 const ::bkm_invoicedef& x, 
                 const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                 const ::std::wstring& e = L"UTF-8",
                 ::xml_schema::flags f = 0);

void
bkm_invoicedef_ (::xercesc::XMLFormatTarget& ft,
                 const ::bkm_invoicedef& x, 
                 ::xml_schema::error_handler& eh,
                 const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                 const ::std::wstring& e = L"UTF-8",
                 ::xml_schema::flags f = 0);

void
bkm_invoicedef_ (::xercesc::XMLFormatTarget& ft,
                 const ::bkm_invoicedef& x, 
                 ::xercesc::DOMErrorHandler& eh,
                 const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                 const ::std::wstring& e = L"UTF-8",
                 ::xml_schema::flags f = 0);

// Serialize to an existing xercesc::DOMDocument.
//

void
bkm_invoicedef_ (::xercesc::DOMDocument& d,
                 const ::bkm_invoicedef& x,
                 ::xml_schema::flags f = 0);

// Serialize to a new xercesc::DOMDocument.
//

::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
bkm_invoicedef_ (const ::bkm_invoicedef& x, 
                 const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                 ::xml_schema::flags f = 0);

// Serialize to std::ostream.
//

void
bkm_invoicepos_ (::std::ostream& os,
                 const ::bkm_invoicepos& x, 
                 const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                 const ::std::wstring& e = L"UTF-8",
                 ::xml_schema::flags f = 0);

void
bkm_invoicepos_ (::std::ostream& os,
                 const ::bkm_invoicepos& x, 
                 ::xml_schema::error_handler& eh,
                 const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                 const ::std::wstring& e = L"UTF-8",
                 ::xml_schema::flags f = 0);

void
bkm_invoicepos_ (::std::ostream& os,
                 const ::bkm_invoicepos& x, 
                 ::xercesc::DOMErrorHandler& eh,
                 const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                 const ::std::wstring& e = L"UTF-8",
                 ::xml_schema::flags f = 0);

// Serialize to xercesc::XMLFormatTarget.
//

void
bkm_invoicepos_ (::xercesc::XMLFormatTarget& ft,
                 const ::bkm_invoicepos& x, 
                 const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                 const ::std::wstring& e = L"UTF-8",
                 ::xml_schema::flags f = 0);

void
bkm_invoicepos_ (::xercesc::XMLFormatTarget& ft,
                 const ::bkm_invoicepos& x, 
                 ::xml_schema::error_handler& eh,
                 const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                 const ::std::wstring& e = L"UTF-8",
                 ::xml_schema::flags f = 0);

void
bkm_invoicepos_ (::xercesc::XMLFormatTarget& ft,
                 const ::bkm_invoicepos& x, 
                 ::xercesc::DOMErrorHandler& eh,
                 const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                 const ::std::wstring& e = L"UTF-8",
                 ::xml_schema::flags f = 0);

// Serialize to an existing xercesc::DOMDocument.
//

void
bkm_invoicepos_ (::xercesc::DOMDocument& d,
                 const ::bkm_invoicepos& x,
                 ::xml_schema::flags f = 0);

// Serialize to a new xercesc::DOMDocument.
//

::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
bkm_invoicepos_ (const ::bkm_invoicepos& x, 
                 const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                 ::xml_schema::flags f = 0);

// Serialize to std::ostream.
//

void
bkm_splitinvoice_ (::std::ostream& os,
                   const ::bkm_splitinvoice& x, 
                   const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                   const ::std::wstring& e = L"UTF-8",
                   ::xml_schema::flags f = 0);

void
bkm_splitinvoice_ (::std::ostream& os,
                   const ::bkm_splitinvoice& x, 
                   ::xml_schema::error_handler& eh,
                   const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                   const ::std::wstring& e = L"UTF-8",
                   ::xml_schema::flags f = 0);

void
bkm_splitinvoice_ (::std::ostream& os,
                   const ::bkm_splitinvoice& x, 
                   ::xercesc::DOMErrorHandler& eh,
                   const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                   const ::std::wstring& e = L"UTF-8",
                   ::xml_schema::flags f = 0);

// Serialize to xercesc::XMLFormatTarget.
//

void
bkm_splitinvoice_ (::xercesc::XMLFormatTarget& ft,
                   const ::bkm_splitinvoice& x, 
                   const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                   const ::std::wstring& e = L"UTF-8",
                   ::xml_schema::flags f = 0);

void
bkm_splitinvoice_ (::xercesc::XMLFormatTarget& ft,
                   const ::bkm_splitinvoice& x, 
                   ::xml_schema::error_handler& eh,
                   const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                   const ::std::wstring& e = L"UTF-8",
                   ::xml_schema::flags f = 0);

void
bkm_splitinvoice_ (::xercesc::XMLFormatTarget& ft,
                   const ::bkm_splitinvoice& x, 
                   ::xercesc::DOMErrorHandler& eh,
                   const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                   const ::std::wstring& e = L"UTF-8",
                   ::xml_schema::flags f = 0);

// Serialize to an existing xercesc::DOMDocument.
//

void
bkm_splitinvoice_ (::xercesc::DOMDocument& d,
                   const ::bkm_splitinvoice& x,
                   ::xml_schema::flags f = 0);

// Serialize to a new xercesc::DOMDocument.
//

::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
bkm_splitinvoice_ (const ::bkm_splitinvoice& x, 
                   const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                   ::xml_schema::flags f = 0);

// Serialize to std::ostream.
//

void
bkm_payment_ (::std::ostream& os,
              const ::bkm_payment& x, 
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::wstring& e = L"UTF-8",
              ::xml_schema::flags f = 0);

void
bkm_payment_ (::std::ostream& os,
              const ::bkm_payment& x, 
              ::xml_schema::error_handler& eh,
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::wstring& e = L"UTF-8",
              ::xml_schema::flags f = 0);

void
bkm_payment_ (::std::ostream& os,
              const ::bkm_payment& x, 
              ::xercesc::DOMErrorHandler& eh,
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::wstring& e = L"UTF-8",
              ::xml_schema::flags f = 0);

// Serialize to xercesc::XMLFormatTarget.
//

void
bkm_payment_ (::xercesc::XMLFormatTarget& ft,
              const ::bkm_payment& x, 
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::wstring& e = L"UTF-8",
              ::xml_schema::flags f = 0);

void
bkm_payment_ (::xercesc::XMLFormatTarget& ft,
              const ::bkm_payment& x, 
              ::xml_schema::error_handler& eh,
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::wstring& e = L"UTF-8",
              ::xml_schema::flags f = 0);

void
bkm_payment_ (::xercesc::XMLFormatTarget& ft,
              const ::bkm_payment& x, 
              ::xercesc::DOMErrorHandler& eh,
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::wstring& e = L"UTF-8",
              ::xml_schema::flags f = 0);

// Serialize to an existing xercesc::DOMDocument.
//

void
bkm_payment_ (::xercesc::DOMDocument& d,
              const ::bkm_payment& x,
              ::xml_schema::flags f = 0);

// Serialize to a new xercesc::DOMDocument.
//

::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
bkm_payment_ (const ::bkm_payment& x, 
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              ::xml_schema::flags f = 0);

// Serialize to std::ostream.
//

void
ava_unit_ (::std::ostream& os,
           const ::ava_unit& x, 
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           const ::std::wstring& e = L"UTF-8",
           ::xml_schema::flags f = 0);

void
ava_unit_ (::std::ostream& os,
           const ::ava_unit& x, 
           ::xml_schema::error_handler& eh,
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           const ::std::wstring& e = L"UTF-8",
           ::xml_schema::flags f = 0);

void
ava_unit_ (::std::ostream& os,
           const ::ava_unit& x, 
           ::xercesc::DOMErrorHandler& eh,
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           const ::std::wstring& e = L"UTF-8",
           ::xml_schema::flags f = 0);

// Serialize to xercesc::XMLFormatTarget.
//

void
ava_unit_ (::xercesc::XMLFormatTarget& ft,
           const ::ava_unit& x, 
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           const ::std::wstring& e = L"UTF-8",
           ::xml_schema::flags f = 0);

void
ava_unit_ (::xercesc::XMLFormatTarget& ft,
           const ::ava_unit& x, 
           ::xml_schema::error_handler& eh,
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           const ::std::wstring& e = L"UTF-8",
           ::xml_schema::flags f = 0);

void
ava_unit_ (::xercesc::XMLFormatTarget& ft,
           const ::ava_unit& x, 
           ::xercesc::DOMErrorHandler& eh,
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           const ::std::wstring& e = L"UTF-8",
           ::xml_schema::flags f = 0);

// Serialize to an existing xercesc::DOMDocument.
//

void
ava_unit_ (::xercesc::DOMDocument& d,
           const ::ava_unit& x,
           ::xml_schema::flags f = 0);

// Serialize to a new xercesc::DOMDocument.
//

::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
ava_unit_ (const ::ava_unit& x, 
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           ::xml_schema::flags f = 0);

// Serialize to std::ostream.
//

void
ava_order_ (::std::ostream& os,
            const ::ava_order& x, 
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::wstring& e = L"UTF-8",
            ::xml_schema::flags f = 0);

void
ava_order_ (::std::ostream& os,
            const ::ava_order& x, 
            ::xml_schema::error_handler& eh,
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::wstring& e = L"UTF-8",
            ::xml_schema::flags f = 0);

void
ava_order_ (::std::ostream& os,
            const ::ava_order& x, 
            ::xercesc::DOMErrorHandler& eh,
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::wstring& e = L"UTF-8",
            ::xml_schema::flags f = 0);

// Serialize to xercesc::XMLFormatTarget.
//

void
ava_order_ (::xercesc::XMLFormatTarget& ft,
            const ::ava_order& x, 
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::wstring& e = L"UTF-8",
            ::xml_schema::flags f = 0);

void
ava_order_ (::xercesc::XMLFormatTarget& ft,
            const ::ava_order& x, 
            ::xml_schema::error_handler& eh,
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::wstring& e = L"UTF-8",
            ::xml_schema::flags f = 0);

void
ava_order_ (::xercesc::XMLFormatTarget& ft,
            const ::ava_order& x, 
            ::xercesc::DOMErrorHandler& eh,
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::wstring& e = L"UTF-8",
            ::xml_schema::flags f = 0);

// Serialize to an existing xercesc::DOMDocument.
//

void
ava_order_ (::xercesc::DOMDocument& d,
            const ::ava_order& x,
            ::xml_schema::flags f = 0);

// Serialize to a new xercesc::DOMDocument.
//

::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
ava_order_ (const ::ava_order& x, 
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            ::xml_schema::flags f = 0);

// Serialize to std::ostream.
//

void
ava_orderpos_ (::std::ostream& os,
               const ::ava_orderpos& x, 
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::wstring& e = L"UTF-8",
               ::xml_schema::flags f = 0);

void
ava_orderpos_ (::std::ostream& os,
               const ::ava_orderpos& x, 
               ::xml_schema::error_handler& eh,
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::wstring& e = L"UTF-8",
               ::xml_schema::flags f = 0);

void
ava_orderpos_ (::std::ostream& os,
               const ::ava_orderpos& x, 
               ::xercesc::DOMErrorHandler& eh,
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::wstring& e = L"UTF-8",
               ::xml_schema::flags f = 0);

// Serialize to xercesc::XMLFormatTarget.
//

void
ava_orderpos_ (::xercesc::XMLFormatTarget& ft,
               const ::ava_orderpos& x, 
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::wstring& e = L"UTF-8",
               ::xml_schema::flags f = 0);

void
ava_orderpos_ (::xercesc::XMLFormatTarget& ft,
               const ::ava_orderpos& x, 
               ::xml_schema::error_handler& eh,
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::wstring& e = L"UTF-8",
               ::xml_schema::flags f = 0);

void
ava_orderpos_ (::xercesc::XMLFormatTarget& ft,
               const ::ava_orderpos& x, 
               ::xercesc::DOMErrorHandler& eh,
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::wstring& e = L"UTF-8",
               ::xml_schema::flags f = 0);

// Serialize to an existing xercesc::DOMDocument.
//

void
ava_orderpos_ (::xercesc::DOMDocument& d,
               const ::ava_orderpos& x,
               ::xml_schema::flags f = 0);

// Serialize to a new xercesc::DOMDocument.
//

::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
ava_orderpos_ (const ::ava_orderpos& x, 
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               ::xml_schema::flags f = 0);

// Serialize to std::ostream.
//

void
bkm_document_ (::std::ostream& os,
               const ::bkm_document& x, 
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::wstring& e = L"UTF-8",
               ::xml_schema::flags f = 0);

void
bkm_document_ (::std::ostream& os,
               const ::bkm_document& x, 
               ::xml_schema::error_handler& eh,
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::wstring& e = L"UTF-8",
               ::xml_schema::flags f = 0);

void
bkm_document_ (::std::ostream& os,
               const ::bkm_document& x, 
               ::xercesc::DOMErrorHandler& eh,
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::wstring& e = L"UTF-8",
               ::xml_schema::flags f = 0);

// Serialize to xercesc::XMLFormatTarget.
//

void
bkm_document_ (::xercesc::XMLFormatTarget& ft,
               const ::bkm_document& x, 
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::wstring& e = L"UTF-8",
               ::xml_schema::flags f = 0);

void
bkm_document_ (::xercesc::XMLFormatTarget& ft,
               const ::bkm_document& x, 
               ::xml_schema::error_handler& eh,
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::wstring& e = L"UTF-8",
               ::xml_schema::flags f = 0);

void
bkm_document_ (::xercesc::XMLFormatTarget& ft,
               const ::bkm_document& x, 
               ::xercesc::DOMErrorHandler& eh,
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::wstring& e = L"UTF-8",
               ::xml_schema::flags f = 0);

// Serialize to an existing xercesc::DOMDocument.
//

void
bkm_document_ (::xercesc::DOMDocument& d,
               const ::bkm_document& x,
               ::xml_schema::flags f = 0);

// Serialize to a new xercesc::DOMDocument.
//

::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
bkm_document_ (const ::bkm_document& x, 
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               ::xml_schema::flags f = 0);

// Serialize to std::ostream.
//

void
bkm_keyvalue_ (::std::ostream& os,
               const ::bkm_keyvalue& x, 
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::wstring& e = L"UTF-8",
               ::xml_schema::flags f = 0);

void
bkm_keyvalue_ (::std::ostream& os,
               const ::bkm_keyvalue& x, 
               ::xml_schema::error_handler& eh,
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::wstring& e = L"UTF-8",
               ::xml_schema::flags f = 0);

void
bkm_keyvalue_ (::std::ostream& os,
               const ::bkm_keyvalue& x, 
               ::xercesc::DOMErrorHandler& eh,
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::wstring& e = L"UTF-8",
               ::xml_schema::flags f = 0);

// Serialize to xercesc::XMLFormatTarget.
//

void
bkm_keyvalue_ (::xercesc::XMLFormatTarget& ft,
               const ::bkm_keyvalue& x, 
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::wstring& e = L"UTF-8",
               ::xml_schema::flags f = 0);

void
bkm_keyvalue_ (::xercesc::XMLFormatTarget& ft,
               const ::bkm_keyvalue& x, 
               ::xml_schema::error_handler& eh,
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::wstring& e = L"UTF-8",
               ::xml_schema::flags f = 0);

void
bkm_keyvalue_ (::xercesc::XMLFormatTarget& ft,
               const ::bkm_keyvalue& x, 
               ::xercesc::DOMErrorHandler& eh,
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::wstring& e = L"UTF-8",
               ::xml_schema::flags f = 0);

// Serialize to an existing xercesc::DOMDocument.
//

void
bkm_keyvalue_ (::xercesc::DOMDocument& d,
               const ::bkm_keyvalue& x,
               ::xml_schema::flags f = 0);

// Serialize to a new xercesc::DOMDocument.
//

::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
bkm_keyvalue_ (const ::bkm_keyvalue& x, 
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               ::xml_schema::flags f = 0);

// Serialize to std::ostream.
//

void
ret_order_ (::std::ostream& os,
            const ::ret_order& x, 
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::wstring& e = L"UTF-8",
            ::xml_schema::flags f = 0);

void
ret_order_ (::std::ostream& os,
            const ::ret_order& x, 
            ::xml_schema::error_handler& eh,
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::wstring& e = L"UTF-8",
            ::xml_schema::flags f = 0);

void
ret_order_ (::std::ostream& os,
            const ::ret_order& x, 
            ::xercesc::DOMErrorHandler& eh,
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::wstring& e = L"UTF-8",
            ::xml_schema::flags f = 0);

// Serialize to xercesc::XMLFormatTarget.
//

void
ret_order_ (::xercesc::XMLFormatTarget& ft,
            const ::ret_order& x, 
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::wstring& e = L"UTF-8",
            ::xml_schema::flags f = 0);

void
ret_order_ (::xercesc::XMLFormatTarget& ft,
            const ::ret_order& x, 
            ::xml_schema::error_handler& eh,
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::wstring& e = L"UTF-8",
            ::xml_schema::flags f = 0);

void
ret_order_ (::xercesc::XMLFormatTarget& ft,
            const ::ret_order& x, 
            ::xercesc::DOMErrorHandler& eh,
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::wstring& e = L"UTF-8",
            ::xml_schema::flags f = 0);

// Serialize to an existing xercesc::DOMDocument.
//

void
ret_order_ (::xercesc::DOMDocument& d,
            const ::ret_order& x,
            ::xml_schema::flags f = 0);

// Serialize to a new xercesc::DOMDocument.
//

::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
ret_order_ (const ::ret_order& x, 
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            ::xml_schema::flags f = 0);

// Serialize to std::ostream.
//

void
ret_invoice_ (::std::ostream& os,
              const ::ret_invoice& x, 
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::wstring& e = L"UTF-8",
              ::xml_schema::flags f = 0);

void
ret_invoice_ (::std::ostream& os,
              const ::ret_invoice& x, 
              ::xml_schema::error_handler& eh,
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::wstring& e = L"UTF-8",
              ::xml_schema::flags f = 0);

void
ret_invoice_ (::std::ostream& os,
              const ::ret_invoice& x, 
              ::xercesc::DOMErrorHandler& eh,
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::wstring& e = L"UTF-8",
              ::xml_schema::flags f = 0);

// Serialize to xercesc::XMLFormatTarget.
//

void
ret_invoice_ (::xercesc::XMLFormatTarget& ft,
              const ::ret_invoice& x, 
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::wstring& e = L"UTF-8",
              ::xml_schema::flags f = 0);

void
ret_invoice_ (::xercesc::XMLFormatTarget& ft,
              const ::ret_invoice& x, 
              ::xml_schema::error_handler& eh,
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::wstring& e = L"UTF-8",
              ::xml_schema::flags f = 0);

void
ret_invoice_ (::xercesc::XMLFormatTarget& ft,
              const ::ret_invoice& x, 
              ::xercesc::DOMErrorHandler& eh,
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::wstring& e = L"UTF-8",
              ::xml_schema::flags f = 0);

// Serialize to an existing xercesc::DOMDocument.
//

void
ret_invoice_ (::xercesc::DOMDocument& d,
              const ::ret_invoice& x,
              ::xml_schema::flags f = 0);

// Serialize to a new xercesc::DOMDocument.
//

::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
ret_invoice_ (const ::ret_invoice& x, 
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              ::xml_schema::flags f = 0);

// Serialize to std::ostream.
//

void
ret_payment_ (::std::ostream& os,
              const ::ret_payment& x, 
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::wstring& e = L"UTF-8",
              ::xml_schema::flags f = 0);

void
ret_payment_ (::std::ostream& os,
              const ::ret_payment& x, 
              ::xml_schema::error_handler& eh,
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::wstring& e = L"UTF-8",
              ::xml_schema::flags f = 0);

void
ret_payment_ (::std::ostream& os,
              const ::ret_payment& x, 
              ::xercesc::DOMErrorHandler& eh,
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::wstring& e = L"UTF-8",
              ::xml_schema::flags f = 0);

// Serialize to xercesc::XMLFormatTarget.
//

void
ret_payment_ (::xercesc::XMLFormatTarget& ft,
              const ::ret_payment& x, 
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::wstring& e = L"UTF-8",
              ::xml_schema::flags f = 0);

void
ret_payment_ (::xercesc::XMLFormatTarget& ft,
              const ::ret_payment& x, 
              ::xml_schema::error_handler& eh,
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::wstring& e = L"UTF-8",
              ::xml_schema::flags f = 0);

void
ret_payment_ (::xercesc::XMLFormatTarget& ft,
              const ::ret_payment& x, 
              ::xercesc::DOMErrorHandler& eh,
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::wstring& e = L"UTF-8",
              ::xml_schema::flags f = 0);

// Serialize to an existing xercesc::DOMDocument.
//

void
ret_payment_ (::xercesc::DOMDocument& d,
              const ::ret_payment& x,
              ::xml_schema::flags f = 0);

// Serialize to a new xercesc::DOMDocument.
//

::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
ret_payment_ (const ::ret_payment& x, 
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              ::xml_schema::flags f = 0);

void
operator<< (::xercesc::DOMElement&, const coordata&);

void
operator<< (::xercesc::DOMElement&, const bkm_response&);

void
operator<< (::xercesc::DOMElement&, const bkm_user&);

void
operator<< (::xercesc::DOMElement&, const bkm_range&);

void
operator<< (::xercesc::DOMElement&, const bkm_city&);

void
operator<< (::xercesc::DOMElement&, const bkm_bank&);

void
operator<< (::xercesc::DOMElement&, const bkm_parish&);

void
operator<< (::xercesc::DOMElement&, const bkm_contact&);

void
operator<< (::xercesc::DOMElement&, const bkm_counterpart&);

void
operator<< (::xercesc::DOMElement&, const bkm_project&);

void
operator<< (::xercesc::DOMElement&, const bkm_part&);

void
operator<< (::xercesc::DOMElement&, const bkm_splititem&);

void
operator<< (::xercesc::DOMElement&, const bkm_placing&);

void
operator<< (::xercesc::DOMElement&, const bkm_revision&);

void
operator<< (::xercesc::DOMElement&, const bkm_revisionitem&);

void
operator<< (::xercesc::DOMElement&, const ret_revisionitem&);

void
operator<< (::xercesc::DOMElement&, const bkm_order&);

void
operator<< (::xercesc::DOMElement&, const bkm_addition&);

void
operator<< (::xercesc::DOMElement&, const bkm_evident&);

void
operator<< (::xercesc::DOMElement&, const bkm_backup&);

void
operator<< (::xercesc::DOMElement&, const bkm_invdeftype&);

void
operator<< (::xercesc::DOMElement&, const bkm_invoice&);

void
operator<< (::xercesc::DOMElement&, const bkm_invoicedef&);

void
operator<< (::xercesc::DOMElement&, const bkm_invoicepos&);

void
operator<< (::xercesc::DOMElement&, const bkm_splitinvoice&);

void
operator<< (::xercesc::DOMElement&, const bkm_payment&);

void
operator<< (::xercesc::DOMElement&, const ava_unit&);

void
operator<< (::xercesc::DOMElement&, const ava_order&);

void
operator<< (::xercesc::DOMElement&, const ava_orderpos&);

void
operator<< (::xercesc::DOMElement&, const bkm_document&);

void
operator<< (::xercesc::DOMElement&, const bkm_keyvalue&);

void
operator<< (::xercesc::DOMElement&, const ret_order&);

void
operator<< (::xercesc::DOMElement&, const ret_invoice&);

void
operator<< (::xercesc::DOMElement&, const ret_payment&);

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // COOR_HXX
